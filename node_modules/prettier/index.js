"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js/internals/global.js"(exports2, module2) {
    var check = function(it) {
      return it && it.Math == Math && it;
    };
    module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports2, module2) {
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports2, module2) {
    var fails = require_fails();
    module2.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  }
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js/internals/function-bind-native.js"(exports2, module2) {
    var fails = require_fails();
    module2.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports2, module2) {
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module2.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports2) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports2, module2) {
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports2, module2) {
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module2.exports = function(it) {
      return stringSlice(toString(it), 8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module2.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) == "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js/internals/is-null-or-undefined.js"(exports2, module2) {
    module2.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports2, module2) {
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module2.exports = function(it) {
      if (isNullOrUndefined(it))
        throw $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports2, module2) {
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module2.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js/internals/document-all.js
var require_document_all = __commonJS({
  "node_modules/core-js/internals/document-all.js"(exports2, module2) {
    var documentAll = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
    module2.exports = {
      all: documentAll,
      IS_HTMLDDA
    };
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports2, module2) {
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports2, module2) {
    var isCallable = require_is_callable();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module2.exports = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports2, module2) {
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module2.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js/internals/engine-user-agent.js"(exports2, module2) {
    var getBuiltIn = require_get_built_in();
    module2.exports = getBuiltIn("navigator", "userAgent") || "";
  }
});

// node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js/internals/engine-v8-version.js"(exports2, module2) {
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global2.process;
    var Deno = global2.Deno;
    var versions = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match;
    var version2;
    if (v8) {
      match = v8.split(".");
      version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version2 && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version2 = +match[1];
      }
    }
    module2.exports = version2;
  }
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports2, module2) {
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports2, module2) {
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports2, module2) {
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module2.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports2, module2) {
    var $String = String;
    module2.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports2, module2) {
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports2, module2) {
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module2.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports2, module2) {
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    var $TypeError = TypeError;
    module2.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
        return val;
      throw $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports2, module2) {
    module2.exports = false;
  }
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js/internals/define-global-property.js"(exports2, module2) {
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module2.exports = function(key, value) {
      try {
        defineProperty(global2, key, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports2, module2) {
    var global2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
    module2.exports = store;
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports2, module2) {
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module2.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.26.1",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports2, module2) {
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module2.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module2.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1 .toString);
    module2.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports2, module2) {
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var WellKnownSymbolsStore = shared("wks");
    var Symbol2 = global2.Symbol;
    var symbolFor = Symbol2 && Symbol2["for"];
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module2.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
        var description = "Symbol." + name;
        if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
          WellKnownSymbolsStore[name] = Symbol2[name];
        } else if (USE_SYMBOL_AS_UID && symbolFor) {
          WellKnownSymbolsStore[name] = symbolFor(description);
        } else {
          WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
        }
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports2, module2) {
    var call = require_function_call();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module2.exports = function(input, pref) {
      if (!isObject(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result))
          return result;
        throw $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports2, module2) {
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module2.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports2, module2) {
    var global2 = require_global();
    var isObject = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports2, module2) {
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module2.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports2) {
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (hasOwn(O, P))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports2, module2) {
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module2.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype != 42;
    });
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports2, module2) {
    var isObject = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isObject(argument))
        return argument;
      throw $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports2) {
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports2, module2) {
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports2, module2) {
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && function something() {
    }.name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module2.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module2.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports2, module2) {
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap2 = global2.WeakMap;
    module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports2, module2) {
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module2.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports2, module2) {
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap2 = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module2.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "node_modules/core-js/internals/make-built-in.js"(exports2, module2) {
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var defineProperty = Object.defineProperty;
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module2.exports = function(value, name, options) {
      if (String(name).slice(0, 7) === "Symbol(") {
        name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = TEMPLATE.join(typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js/internals/define-built-in.js"(exports2, module2) {
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module2.exports = function(O, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value))
        makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple)
          O[key] = value;
        else
          defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key];
          else if (O[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O[key] = value;
        else
          definePropertyModule.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
  }
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js/internals/math-trunc.js"(exports2, module2) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports2, module2) {
    var trunc = require_math_trunc();
    module2.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports2, module2) {
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module2.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports2, module2) {
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module2.exports = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports2, module2) {
    var toLength = require_to_length();
    module2.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports2, module2) {
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index) {
            value = O[index++];
            if (value != value)
              return true;
          }
        else
          for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module2.exports = {
      includes: createMethod(true),
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module2.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i)
        if (hasOwn(O, key = names[i++])) {
          ~indexOf(result, key) || push(result, key);
        }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports2, module2) {
    module2.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports2) {
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports2) {
    exports2.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports2, module2) {
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports2, module2) {
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module2.exports = function(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports2, module2) {
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module2.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports2, module2) {
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module2.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global2[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
    };
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports2, module2) {
    var classof = require_classof_raw();
    module2.exports = Array.isArray || function isArray(argument) {
      return classof(argument) == "Array";
    };
  }
});

// node_modules/core-js/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports2, module2) {
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module2.exports = function(it) {
      if (it > MAX_SAFE_INTEGER)
        throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports2, module2) {
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module2.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module2.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/flatten-into-array.js
var require_flatten_into_array = __commonJS({
  "node_modules/core-js/internals/flatten-into-array.js"(exports2, module2) {
    "use strict";
    var isArray = require_is_array();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var bind = require_function_bind_context();
    var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start;
      var sourceIndex = 0;
      var mapFn = mapper ? bind(mapper, thisArg) : false;
      var element, elementLen;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          if (depth > 0 && isArray(element)) {
            elementLen = lengthOfArrayLike(element);
            targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
          } else {
            doesNotExceedSafeInteger(targetIndex + 1);
            target[targetIndex] = element;
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    };
    module2.exports = flattenIntoArray;
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports2, module2) {
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module2.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports2, module2) {
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js/internals/is-constructor.js"(exports2, module2) {
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop = function() {
    };
    var empty = [];
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop, empty, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module2.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/internals/array-species-constructor.js"(exports2, module2) {
    var isArray = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module2.exports = function(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype)))
          C = void 0;
        else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null)
            C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// node_modules/core-js/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/internals/array-species-create.js"(exports2, module2) {
    var arraySpeciesConstructor = require_array_species_constructor();
    module2.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js/modules/es.array.flat-map.js
var require_es_array_flat_map = __commonJS({
  "node_modules/core-js/modules/es.array.flat-map.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flatMap: function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return A;
      }
    });
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports2, module2) {
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module2.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports2, module2) {
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module2.exports = function(it) {
      if (!isNullOrUndefined(it))
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports2, module2) {
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module2.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports2, module2) {
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module2.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports2, module2) {
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module2.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/internals/create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js/internals/create-property.js"(exports2, module2) {
    "use strict";
    var toPropertyKey = require_to_property_key();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = function(object, key, value) {
      var propertyKey = toPropertyKey(key);
      if (propertyKey in object)
        definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
      else
        object[propertyKey] = value;
    };
  }
});

// node_modules/core-js/modules/es.object.from-entries.js
var require_es_object_from_entries = __commonJS({
  "node_modules/core-js/modules/es.object.from-entries.js"() {
    var $ = require_export();
    var iterate = require_iterate();
    var createProperty = require_create_property();
    $({ target: "Object", stat: true }, {
      fromEntries: function fromEntries(iterable) {
        var obj = {};
        iterate(iterable, function(k, v) {
          createProperty(obj, k, v);
        }, { AS_ENTRIES: true });
        return obj;
      }
    });
  }
});

// node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "node_modules/core-js/internals/define-built-in-accessor.js"(exports2, module2) {
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module2.exports = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports2, module2) {
    "use strict";
    var anObject = require_an_object();
    module2.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// node_modules/core-js/modules/es.regexp.flags.js
var require_es_regexp_flags = __commonJS({
  "node_modules/core-js/modules/es.regexp.flags.js"() {
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var regExpFlags = require_regexp_flags();
    var fails = require_fails();
    var RegExp2 = global2.RegExp;
    var RegExpPrototype = RegExp2.prototype;
    var FORCED = DESCRIPTORS && fails(function() {
      var INDICES_SUPPORT = true;
      try {
        RegExp2(".", "d");
      } catch (error) {
        INDICES_SUPPORT = false;
      }
      var O = {};
      var calls = "";
      var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
      var addGetter = function(key2, chr) {
        Object.defineProperty(O, key2, { get: function() {
          calls += chr;
          return true;
        } });
      };
      var pairs = {
        dotAll: "s",
        global: "g",
        ignoreCase: "i",
        multiline: "m",
        sticky: "y"
      };
      if (INDICES_SUPPORT)
        pairs.hasIndices = "d";
      for (var key in pairs)
        addGetter(key, pairs[key]);
      var result = Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call(O);
      return result !== expected || calls !== expected;
    });
    if (FORCED)
      defineBuiltInAccessor(RegExpPrototype, "flags", {
        configurable: true,
        get: regExpFlags
      });
  }
});

// node_modules/core-js/modules/es.array.flat.js
var require_es_array_flat = __commonJS({
  "node_modules/core-js/modules/es.array.flat.js"() {
    "use strict";
    var $ = require_export();
    var flattenIntoArray = require_flatten_into_array();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var arraySpeciesCreate = require_array_species_create();
    $({ target: "Array", proto: true }, {
      flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : void 0;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
        return A;
      }
    });
  }
});

// dist/_index.js.cjs.js
var _excluded = ["cliName", "cliCategory", "cliDescription"];
var _excluded2 = ["_"];
var _excluded3 = ["overrides"];
var _excluded4 = ["languageId"];
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
require_es_array_flat_map();
require_es_object_from_entries();
require_es_regexp_flags();
require_es_array_flat();
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {
    exports: {}
  }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
  value: mod,
  enumerable: true
}) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", {
  value: true
}), mod);
var require_base = __commonJS2({
  "node_modules/diff/lib/diff/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = Diff;
    function Diff() {
    }
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        this.options = options;
        var self2 = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0;
            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split("");
      },
      join: function join(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value2, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value2.length ? oldValue : value2;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
  }
});
var require_array = __commonJS2({
  "node_modules/diff/lib/diff/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffArrays = diffArrays;
    exports2.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    var arrayDiff = new _base["default"]();
    exports2.arrayDiff = arrayDiff;
    arrayDiff.tokenize = function(value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  }
});
var escape_string_regexp_exports = {};
__export(escape_string_regexp_exports, {
  default: () => escapeStringRegexp
});
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var init_escape_string_regexp = __esm({
  "node_modules/escape-string-regexp/index.js"() {
  }
});
var require_get_last = __commonJS2({
  "src/utils/get-last.js"(exports2, module2) {
    "use strict";
    var getLast = (arr) => arr[arr.length - 1];
    module2.exports = getLast;
  }
});
var require_debug = __commonJS2({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});
var require_constants = __commonJS2({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});
var require_re = __commonJS2({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});
var require_parse_options = __commonJS2({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? {
      loose: true
    } : opts.filter((k) => options[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module2.exports = parseOptions;
  }
});
var require_identifiers = __commonJS2({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});
var require_semver = __commonJS2({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var {
      MAX_LENGTH,
      MAX_SAFE_INTEGER
    } = require_constants();
    var {
      re,
      t
    } = require_re();
    var parseOptions = require_parse_options();
    var {
      compareIdentifiers
    } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});
var require_compare = __commonJS2({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});
var require_lt = __commonJS2({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});
var require_gte = __commonJS2({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});
var require_arrayify = __commonJS2({
  "src/utils/arrayify.js"(exports2, module2) {
    "use strict";
    module2.exports = (object, keyName) => Object.entries(object).map(([key, value]) => Object.assign({
      [keyName]: key
    }, value));
  }
});
var require_lib = __commonJS2({
  "node_modules/outdent/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.outdent = void 0;
    function noop() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
    }
    function createWeakMap() {
      if (typeof WeakMap !== "undefined") {
        return /* @__PURE__ */ new WeakMap();
      } else {
        return fakeSetOrMap();
      }
    }
    function fakeSetOrMap() {
      return {
        add: noop,
        delete: noop,
        get: noop,
        set: noop,
        has: function(k) {
          return false;
        }
      };
    }
    var hop = Object.prototype.hasOwnProperty;
    var has = function(obj, prop) {
      return hop.call(obj, prop);
    };
    function extend(target, source) {
      for (var prop in source) {
        if (has(source, prop)) {
          target[prop] = source[prop];
        }
      }
      return target;
    }
    var reLeadingNewline = /^[ \t]*(?:\r\n|\r|\n)/;
    var reTrailingNewline = /(?:\r\n|\r|\n)[ \t]*$/;
    var reStartsWithNewlineOrIsEmpty = /^(?:[\r\n]|$)/;
    var reDetectIndentation = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/;
    var reOnlyWhitespaceWithAtLeastOneNewline = /^[ \t]*[\r\n][ \t\r\n]*$/;
    function _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {
      var indentationLevel = 0;
      var match = strings[0].match(reDetectIndentation);
      if (match) {
        indentationLevel = match[1].length;
      }
      var reSource = "(\\r\\n|\\r|\\n).{0," + indentationLevel + "}";
      var reMatchIndent = new RegExp(reSource, "g");
      if (firstInterpolatedValueSetsIndentationLevel) {
        strings = strings.slice(1);
      }
      var newline = options.newline, trimLeadingNewline = options.trimLeadingNewline, trimTrailingNewline = options.trimTrailingNewline;
      var normalizeNewlines = typeof newline === "string";
      var l = strings.length;
      var outdentedStrings = strings.map(function(v, i) {
        v = v.replace(reMatchIndent, "$1");
        if (i === 0 && trimLeadingNewline) {
          v = v.replace(reLeadingNewline, "");
        }
        if (i === l - 1 && trimTrailingNewline) {
          v = v.replace(reTrailingNewline, "");
        }
        if (normalizeNewlines) {
          v = v.replace(/\r\n|\n|\r/g, function(_) {
            return newline;
          });
        }
        return v;
      });
      return outdentedStrings;
    }
    function concatStringsAndValues(strings, values) {
      var ret = "";
      for (var i = 0, l = strings.length; i < l; i++) {
        ret += strings[i];
        if (i < l - 1) {
          ret += values[i];
        }
      }
      return ret;
    }
    function isTemplateStringsArray(v) {
      return has(v, "raw") && has(v, "length");
    }
    function createInstance(options) {
      var arrayAutoIndentCache = createWeakMap();
      var arrayFirstInterpSetsIndentCache = createWeakMap();
      function outdent(stringsOrOptions) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          values[_i - 1] = arguments[_i];
        }
        if (isTemplateStringsArray(stringsOrOptions)) {
          var strings = stringsOrOptions;
          var firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]);
          var cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;
          var renderedArray = cache.get(strings);
          if (!renderedArray) {
            renderedArray = _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options);
            cache.set(strings, renderedArray);
          }
          if (values.length === 0) {
            return renderedArray[0];
          }
          var rendered = concatStringsAndValues(renderedArray, firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values);
          return rendered;
        } else {
          return createInstance(extend(extend({}, options), stringsOrOptions || {}));
        }
      }
      var fullOutdent = extend(outdent, {
        string: function(str) {
          return _outdentArray([str], false, options)[0];
        }
      });
      return fullOutdent;
    }
    var defaultOutdent = createInstance({
      trimLeadingNewline: true,
      trimTrailingNewline: true
    });
    exports2.outdent = defaultOutdent;
    exports2.default = defaultOutdent;
    if (typeof module2 !== "undefined") {
      try {
        module2.exports = defaultOutdent;
        Object.defineProperty(defaultOutdent, "__esModule", {
          value: true
        });
        defaultOutdent.default = defaultOutdent;
        defaultOutdent.outdent = defaultOutdent;
      } catch (e) {
      }
    }
  }
});
var require_core_options = __commonJS2({
  "src/main/core-options.js"(exports2, module2) {
    "use strict";
    var {
      outdent
    } = require_lib();
    var CATEGORY_CONFIG = "Config";
    var CATEGORY_EDITOR = "Editor";
    var CATEGORY_FORMAT = "Format";
    var CATEGORY_OTHER = "Other";
    var CATEGORY_OUTPUT = "Output";
    var CATEGORY_GLOBAL = "Global";
    var CATEGORY_SPECIAL = "Special";
    var options = {
      cursorOffset: {
        since: "1.4.0",
        category: CATEGORY_SPECIAL,
        type: "int",
        default: -1,
        range: {
          start: -1,
          end: Number.POSITIVE_INFINITY,
          step: 1
        },
        description: outdent`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
        cliCategory: CATEGORY_EDITOR
      },
      endOfLine: {
        since: "1.15.0",
        category: CATEGORY_GLOBAL,
        type: "choice",
        default: [{
          since: "1.15.0",
          value: "auto"
        }, {
          since: "2.0.0",
          value: "lf"
        }],
        description: "Which end of line characters to apply.",
        choices: [{
          value: "lf",
          description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
        }, {
          value: "crlf",
          description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
        }, {
          value: "cr",
          description: "Carriage Return character only (\\r), used very rarely"
        }, {
          value: "auto",
          description: outdent`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
        }]
      },
      filepath: {
        since: "1.4.0",
        category: CATEGORY_SPECIAL,
        type: "path",
        description: "Specify the input filepath. This will be used to do parser inference.",
        cliName: "stdin-filepath",
        cliCategory: CATEGORY_OTHER,
        cliDescription: "Path to the file to pretend that stdin comes from."
      },
      insertPragma: {
        since: "1.8.0",
        category: CATEGORY_SPECIAL,
        type: "boolean",
        default: false,
        description: "Insert @format pragma into file's first docblock comment.",
        cliCategory: CATEGORY_OTHER
      },
      parser: {
        since: "0.0.10",
        category: CATEGORY_GLOBAL,
        type: "choice",
        default: [{
          since: "0.0.10",
          value: "babylon"
        }, {
          since: "1.13.0",
          value: void 0
        }],
        description: "Which parser to use.",
        exception: (value) => typeof value === "string" || typeof value === "function",
        choices: [{
          value: "flow",
          description: "Flow"
        }, {
          value: "babel",
          since: "1.16.0",
          description: "JavaScript"
        }, {
          value: "babel-flow",
          since: "1.16.0",
          description: "Flow"
        }, {
          value: "babel-ts",
          since: "2.0.0",
          description: "TypeScript"
        }, {
          value: "typescript",
          since: "1.4.0",
          description: "TypeScript"
        }, {
          value: "acorn",
          since: "2.6.0",
          description: "JavaScript"
        }, {
          value: "espree",
          since: "2.2.0",
          description: "JavaScript"
        }, {
          value: "meriyah",
          since: "2.2.0",
          description: "JavaScript"
        }, {
          value: "css",
          since: "1.7.1",
          description: "CSS"
        }, {
          value: "less",
          since: "1.7.1",
          description: "Less"
        }, {
          value: "scss",
          since: "1.7.1",
          description: "SCSS"
        }, {
          value: "json",
          since: "1.5.0",
          description: "JSON"
        }, {
          value: "json5",
          since: "1.13.0",
          description: "JSON5"
        }, {
          value: "json-stringify",
          since: "1.13.0",
          description: "JSON.stringify"
        }, {
          value: "graphql",
          since: "1.5.0",
          description: "GraphQL"
        }, {
          value: "markdown",
          since: "1.8.0",
          description: "Markdown"
        }, {
          value: "mdx",
          since: "1.15.0",
          description: "MDX"
        }, {
          value: "vue",
          since: "1.10.0",
          description: "Vue"
        }, {
          value: "yaml",
          since: "1.14.0",
          description: "YAML"
        }, {
          value: "glimmer",
          since: "2.3.0",
          description: "Ember / Handlebars"
        }, {
          value: "html",
          since: "1.15.0",
          description: "HTML"
        }, {
          value: "angular",
          since: "1.15.0",
          description: "Angular"
        }, {
          value: "lwc",
          since: "1.17.0",
          description: "Lightning Web Components"
        }]
      },
      plugins: {
        since: "1.10.0",
        type: "path",
        array: true,
        default: [{
          value: []
        }],
        category: CATEGORY_GLOBAL,
        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
        exception: (value) => typeof value === "string" || typeof value === "object",
        cliName: "plugin",
        cliCategory: CATEGORY_CONFIG
      },
      pluginSearchDirs: {
        since: "1.13.0",
        type: "path",
        array: true,
        default: [{
          value: []
        }],
        category: CATEGORY_GLOBAL,
        description: outdent`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
        exception: (value) => typeof value === "string" || typeof value === "object",
        cliName: "plugin-search-dir",
        cliCategory: CATEGORY_CONFIG
      },
      printWidth: {
        since: "0.0.0",
        category: CATEGORY_GLOBAL,
        type: "int",
        default: 80,
        description: "The line length where Prettier will try wrap.",
        range: {
          start: 0,
          end: Number.POSITIVE_INFINITY,
          step: 1
        }
      },
      rangeEnd: {
        since: "1.4.0",
        category: CATEGORY_SPECIAL,
        type: "int",
        default: Number.POSITIVE_INFINITY,
        range: {
          start: 0,
          end: Number.POSITIVE_INFINITY,
          step: 1
        },
        description: outdent`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
        cliCategory: CATEGORY_EDITOR
      },
      rangeStart: {
        since: "1.4.0",
        category: CATEGORY_SPECIAL,
        type: "int",
        default: 0,
        range: {
          start: 0,
          end: Number.POSITIVE_INFINITY,
          step: 1
        },
        description: outdent`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
        cliCategory: CATEGORY_EDITOR
      },
      requirePragma: {
        since: "1.7.0",
        category: CATEGORY_SPECIAL,
        type: "boolean",
        default: false,
        description: outdent`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
        cliCategory: CATEGORY_OTHER
      },
      tabWidth: {
        type: "int",
        category: CATEGORY_GLOBAL,
        default: 2,
        description: "Number of spaces per indentation level.",
        range: {
          start: 0,
          end: Number.POSITIVE_INFINITY,
          step: 1
        }
      },
      useTabs: {
        since: "1.0.0",
        category: CATEGORY_GLOBAL,
        type: "boolean",
        default: false,
        description: "Indent with tabs instead of spaces."
      },
      embeddedLanguageFormatting: {
        since: "2.1.0",
        category: CATEGORY_GLOBAL,
        type: "choice",
        default: [{
          since: "2.1.0",
          value: "auto"
        }],
        description: "Control how Prettier formats quoted code embedded in the file.",
        choices: [{
          value: "auto",
          description: "Format embedded code if Prettier can automatically identify it."
        }, {
          value: "off",
          description: "Never automatically format embedded code."
        }]
      }
    };
    module2.exports = {
      CATEGORY_CONFIG,
      CATEGORY_EDITOR,
      CATEGORY_FORMAT,
      CATEGORY_OTHER,
      CATEGORY_OUTPUT,
      CATEGORY_GLOBAL,
      CATEGORY_SPECIAL,
      options
    };
  }
});
var require_support = __commonJS2({
  "src/main/support.js"(exports2, module2) {
    "use strict";
    var semver = {
      compare: require_compare(),
      lt: require_lt(),
      gte: require_gte()
    };
    var arrayify = require_arrayify();
    var currentVersion = require("./package.json").version;
    var coreOptions = require_core_options().options;
    function getSupportInfo2({
      plugins: plugins2 = [],
      showUnreleased = false,
      showDeprecated = false,
      showInternal = false
    } = {}) {
      const version2 = currentVersion.split("-", 1)[0];
      const languages = plugins2.flatMap((plugin) => plugin.languages || []).filter(filterSince);
      const options = arrayify(Object.assign({}, ...plugins2.map(({
        options: options2
      }) => options2), coreOptions), "name").filter((option) => filterSince(option) && filterDeprecated(option)).sort((a, b) => a.name === b.name ? 0 : a.name < b.name ? -1 : 1).map(mapInternal).map((option) => {
        option = Object.assign({}, option);
        if (Array.isArray(option.default)) {
          option.default = option.default.length === 1 ? option.default[0].value : option.default.filter(filterSince).sort((info1, info2) => semver.compare(info2.since, info1.since))[0].value;
        }
        if (Array.isArray(option.choices)) {
          option.choices = option.choices.filter((option2) => filterSince(option2) && filterDeprecated(option2));
          if (option.name === "parser") {
            collectParsersFromLanguages(option, languages, plugins2);
          }
        }
        const pluginDefaults = Object.fromEntries(plugins2.filter((plugin) => plugin.defaultOptions && plugin.defaultOptions[option.name] !== void 0).map((plugin) => [plugin.name, plugin.defaultOptions[option.name]]));
        return Object.assign(Object.assign({}, option), {}, {
          pluginDefaults
        });
      });
      return {
        languages,
        options
      };
      function filterSince(object) {
        return showUnreleased || !("since" in object) || object.since && semver.gte(version2, object.since);
      }
      function filterDeprecated(object) {
        return showDeprecated || !("deprecated" in object) || object.deprecated && semver.lt(version2, object.deprecated);
      }
      function mapInternal(object) {
        if (showInternal) {
          return object;
        }
        const {
          cliName,
          cliCategory,
          cliDescription
        } = object, newObject = _objectWithoutProperties(object, _excluded);
        return newObject;
      }
    }
    function collectParsersFromLanguages(option, languages, plugins2) {
      const existingValues = new Set(option.choices.map((choice) => choice.value));
      for (const language of languages) {
        if (language.parsers) {
          for (const value of language.parsers) {
            if (!existingValues.has(value)) {
              existingValues.add(value);
              const plugin = plugins2.find((plugin2) => plugin2.parsers && plugin2.parsers[value]);
              let description = language.name;
              if (plugin && plugin.name) {
                description += ` (plugin: ${plugin.name})`;
              }
              option.choices.push({
                value,
                description
              });
            }
          }
        }
      }
    }
    module2.exports = {
      getSupportInfo: getSupportInfo2
    };
  }
});
var require_is_non_empty_array = __commonJS2({
  "src/utils/is-non-empty-array.js"(exports2, module2) {
    "use strict";
    function isNonEmptyArray(object) {
      return Array.isArray(object) && object.length > 0;
    }
    module2.exports = isNonEmptyArray;
  }
});
function ansiRegex({
  onlyFirst = false
} = {}) {
  const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
var init_ansi_regex = __esm({
  "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
  }
});
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(ansiRegex(), "");
}
var init_strip_ansi = __esm({
  "node_modules/strip-ansi/index.js"() {
    init_ansi_regex();
  }
});
function isFullwidthCodePoint(codePoint) {
  if (!Number.isInteger(codePoint)) {
    return false;
  }
  return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);
}
var init_is_fullwidth_code_point = __esm({
  "node_modules/is-fullwidth-code-point/index.js"() {
  }
});
var require_emoji_regex = __commonJS2({
  "node_modules/emoji-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});
var string_width_exports = {};
__export(string_width_exports, {
  default: () => stringWidth
});
function stringWidth(string) {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  string = stripAnsi(string);
  if (string.length === 0) {
    return 0;
  }
  string = string.replace((0, import_emoji_regex.default)(), "  ");
  let width = 0;
  for (let index = 0; index < string.length; index++) {
    const codePoint = string.codePointAt(index);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
      continue;
    }
    if (codePoint >= 768 && codePoint <= 879) {
      continue;
    }
    if (codePoint > 65535) {
      index++;
    }
    width += isFullwidthCodePoint(codePoint) ? 2 : 1;
  }
  return width;
}
var import_emoji_regex;
var init_string_width = __esm({
  "node_modules/string-width/index.js"() {
    init_strip_ansi();
    init_is_fullwidth_code_point();
    import_emoji_regex = __toESM(require_emoji_regex());
  }
});
var require_get_string_width = __commonJS2({
  "src/utils/get-string-width.js"(exports2, module2) {
    "use strict";
    var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;
    var notAsciiRegex = /[^\x20-\x7F]/;
    function getStringWidth(text) {
      if (!text) {
        return 0;
      }
      if (!notAsciiRegex.test(text)) {
        return text.length;
      }
      return stringWidth2(text);
    }
    module2.exports = getStringWidth;
  }
});
var require_skip = __commonJS2({
  "src/utils/text/skip.js"(exports2, module2) {
    "use strict";
    function skip(chars) {
      return (text, index, opts) => {
        const backwards = opts && opts.backwards;
        if (index === false) {
          return false;
        }
        const {
          length
        } = text;
        let cursor = index;
        while (cursor >= 0 && cursor < length) {
          const c = text.charAt(cursor);
          if (chars instanceof RegExp) {
            if (!chars.test(c)) {
              return cursor;
            }
          } else if (!chars.includes(c)) {
            return cursor;
          }
          backwards ? cursor-- : cursor++;
        }
        if (cursor === -1 || cursor === length) {
          return cursor;
        }
        return false;
      };
    }
    var skipWhitespace = skip(/\s/);
    var skipSpaces = skip(" 	");
    var skipToLineEnd = skip(",; 	");
    var skipEverythingButNewLine = skip(/[^\n\r]/);
    module2.exports = {
      skipWhitespace,
      skipSpaces,
      skipToLineEnd,
      skipEverythingButNewLine
    };
  }
});
var require_skip_inline_comment = __commonJS2({
  "src/utils/text/skip-inline-comment.js"(exports2, module2) {
    "use strict";
    function skipInlineComment(text, index) {
      if (index === false) {
        return false;
      }
      if (text.charAt(index) === "/" && text.charAt(index + 1) === "*") {
        for (let i = index + 2; i < text.length; ++i) {
          if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {
            return i + 2;
          }
        }
      }
      return index;
    }
    module2.exports = skipInlineComment;
  }
});
var require_skip_trailing_comment = __commonJS2({
  "src/utils/text/skip-trailing-comment.js"(exports2, module2) {
    "use strict";
    var {
      skipEverythingButNewLine
    } = require_skip();
    function skipTrailingComment(text, index) {
      if (index === false) {
        return false;
      }
      if (text.charAt(index) === "/" && text.charAt(index + 1) === "/") {
        return skipEverythingButNewLine(text, index);
      }
      return index;
    }
    module2.exports = skipTrailingComment;
  }
});
var require_skip_newline = __commonJS2({
  "src/utils/text/skip-newline.js"(exports2, module2) {
    "use strict";
    function skipNewline(text, index, opts) {
      const backwards = opts && opts.backwards;
      if (index === false) {
        return false;
      }
      const atIndex = text.charAt(index);
      if (backwards) {
        if (text.charAt(index - 1) === "\r" && atIndex === "\n") {
          return index - 2;
        }
        if (atIndex === "\n" || atIndex === "\r" || atIndex === "\u2028" || atIndex === "\u2029") {
          return index - 1;
        }
      } else {
        if (atIndex === "\r" && text.charAt(index + 1) === "\n") {
          return index + 2;
        }
        if (atIndex === "\n" || atIndex === "\r" || atIndex === "\u2028" || atIndex === "\u2029") {
          return index + 1;
        }
      }
      return index;
    }
    module2.exports = skipNewline;
  }
});
var require_get_next_non_space_non_comment_character_index_with_start_index = __commonJS2({
  "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(exports2, module2) {
    "use strict";
    var skipInlineComment = require_skip_inline_comment();
    var skipNewline = require_skip_newline();
    var skipTrailingComment = require_skip_trailing_comment();
    var {
      skipSpaces
    } = require_skip();
    function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {
      let oldIdx = null;
      let nextIdx = idx;
      while (nextIdx !== oldIdx) {
        oldIdx = nextIdx;
        nextIdx = skipSpaces(text, nextIdx);
        nextIdx = skipInlineComment(text, nextIdx);
        nextIdx = skipTrailingComment(text, nextIdx);
        nextIdx = skipNewline(text, nextIdx);
      }
      return nextIdx;
    }
    module2.exports = getNextNonSpaceNonCommentCharacterIndexWithStartIndex;
  }
});
var require_util = __commonJS2({
  "src/common/util.js"(exports2, module2) {
    "use strict";
    var {
      default: escapeStringRegexp2
    } = (init_escape_string_regexp(), __toCommonJS(escape_string_regexp_exports));
    var getLast = require_get_last();
    var {
      getSupportInfo: getSupportInfo2
    } = require_support();
    var isNonEmptyArray = require_is_non_empty_array();
    var getStringWidth = require_get_string_width();
    var {
      skipWhitespace,
      skipSpaces,
      skipToLineEnd,
      skipEverythingButNewLine
    } = require_skip();
    var skipInlineComment = require_skip_inline_comment();
    var skipTrailingComment = require_skip_trailing_comment();
    var skipNewline = require_skip_newline();
    var getNextNonSpaceNonCommentCharacterIndexWithStartIndex = require_get_next_non_space_non_comment_character_index_with_start_index();
    var getPenultimate = (arr) => arr[arr.length - 2];
    function skip(chars) {
      return (text, index, opts) => {
        const backwards = opts && opts.backwards;
        if (index === false) {
          return false;
        }
        const {
          length
        } = text;
        let cursor = index;
        while (cursor >= 0 && cursor < length) {
          const c = text.charAt(cursor);
          if (chars instanceof RegExp) {
            if (!chars.test(c)) {
              return cursor;
            }
          } else if (!chars.includes(c)) {
            return cursor;
          }
          backwards ? cursor-- : cursor++;
        }
        if (cursor === -1 || cursor === length) {
          return cursor;
        }
        return false;
      };
    }
    function hasNewline(text, index, opts = {}) {
      const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
      const idx2 = skipNewline(text, idx, opts);
      return idx !== idx2;
    }
    function hasNewlineInRange(text, start, end) {
      for (let i = start; i < end; ++i) {
        if (text.charAt(i) === "\n") {
          return true;
        }
      }
      return false;
    }
    function isPreviousLineEmpty(text, node, locStart) {
      let idx = locStart(node) - 1;
      idx = skipSpaces(text, idx, {
        backwards: true
      });
      idx = skipNewline(text, idx, {
        backwards: true
      });
      idx = skipSpaces(text, idx, {
        backwards: true
      });
      const idx2 = skipNewline(text, idx, {
        backwards: true
      });
      return idx !== idx2;
    }
    function isNextLineEmptyAfterIndex(text, index) {
      let oldIdx = null;
      let idx = index;
      while (idx !== oldIdx) {
        oldIdx = idx;
        idx = skipToLineEnd(text, idx);
        idx = skipInlineComment(text, idx);
        idx = skipSpaces(text, idx);
      }
      idx = skipTrailingComment(text, idx);
      idx = skipNewline(text, idx);
      return idx !== false && hasNewline(text, idx);
    }
    function isNextLineEmpty(text, node, locEnd) {
      return isNextLineEmptyAfterIndex(text, locEnd(node));
    }
    function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {
      return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));
    }
    function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {
      return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));
    }
    function hasSpaces(text, index, opts = {}) {
      const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
      return idx !== index;
    }
    function getAlignmentSize(value, tabWidth, startIndex = 0) {
      let size = 0;
      for (let i = startIndex; i < value.length; ++i) {
        if (value[i] === "	") {
          size = size + tabWidth - size % tabWidth;
        } else {
          size++;
        }
      }
      return size;
    }
    function getIndentSize(value, tabWidth) {
      const lastNewlineIndex = value.lastIndexOf("\n");
      if (lastNewlineIndex === -1) {
        return 0;
      }
      return getAlignmentSize(value.slice(lastNewlineIndex + 1).match(/^[\t ]*/)[0], tabWidth);
    }
    function getPreferredQuote(rawContent, preferredQuote) {
      const double = {
        quote: '"',
        regex: /"/g,
        escaped: "&quot;"
      };
      const single = {
        quote: "'",
        regex: /'/g,
        escaped: "&apos;"
      };
      const preferred = preferredQuote === "'" ? single : double;
      const alternate = preferred === single ? double : single;
      let result = preferred;
      if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {
        const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;
        const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;
        result = numPreferredQuotes > numAlternateQuotes ? alternate : preferred;
      }
      return result;
    }
    function printString(raw, options) {
      const rawContent = raw.slice(1, -1);
      const enclosingQuote = options.parser === "json" || options.parser === "json5" && options.quoteProps === "preserve" && !options.singleQuote ? '"' : options.__isInHtmlAttribute ? "'" : getPreferredQuote(rawContent, options.singleQuote ? "'" : '"').quote;
      return makeString(rawContent, enclosingQuote, !(options.parser === "css" || options.parser === "less" || options.parser === "scss" || options.__embeddedInHtml));
    }
    function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {
      const otherQuote = enclosingQuote === '"' ? "'" : '"';
      const regex = /\\(.)|(["'])/gs;
      const newContent = rawContent.replace(regex, (match, escaped, quote) => {
        if (escaped === otherQuote) {
          return escaped;
        }
        if (quote === enclosingQuote) {
          return "\\" + quote;
        }
        if (quote) {
          return quote;
        }
        return unescapeUnnecessaryEscapes && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(escaped) ? escaped : "\\" + escaped;
      });
      return enclosingQuote + newContent + enclosingQuote;
    }
    function printNumber(rawNumber) {
      return rawNumber.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
    }
    function getMaxContinuousCount(str, target) {
      const results = str.match(new RegExp(`(${escapeStringRegexp2(target)})+`, "g"));
      if (results === null) {
        return 0;
      }
      return results.reduce((maxCount, result) => Math.max(maxCount, result.length / target.length), 0);
    }
    function getMinNotPresentContinuousCount(str, target) {
      const matches = str.match(new RegExp(`(${escapeStringRegexp2(target)})+`, "g"));
      if (matches === null) {
        return 0;
      }
      const countPresent = /* @__PURE__ */ new Map();
      let max = 0;
      for (const match of matches) {
        const count = match.length / target.length;
        countPresent.set(count, true);
        if (count > max) {
          max = count;
        }
      }
      for (let i = 1; i < max; i++) {
        if (!countPresent.get(i)) {
          return i;
        }
      }
      return max + 1;
    }
    function addCommentHelper(node, comment) {
      const comments = node.comments || (node.comments = []);
      comments.push(comment);
      comment.printed = false;
      comment.nodeDescription = describeNodeForDebugging(node);
    }
    function addLeadingComment(node, comment) {
      comment.leading = true;
      comment.trailing = false;
      addCommentHelper(node, comment);
    }
    function addDanglingComment(node, comment, marker) {
      comment.leading = false;
      comment.trailing = false;
      if (marker) {
        comment.marker = marker;
      }
      addCommentHelper(node, comment);
    }
    function addTrailingComment(node, comment) {
      comment.leading = false;
      comment.trailing = true;
      addCommentHelper(node, comment);
    }
    function inferParserByLanguage(language, options) {
      const {
        languages
      } = getSupportInfo2({
        plugins: options.plugins
      });
      const matched = languages.find(({
        name
      }) => name.toLowerCase() === language) || languages.find(({
        aliases
      }) => Array.isArray(aliases) && aliases.includes(language)) || languages.find(({
        extensions
      }) => Array.isArray(extensions) && extensions.includes(`.${language}`));
      return matched && matched.parsers[0];
    }
    function isFrontMatterNode(node) {
      return node && node.type === "front-matter";
    }
    function createGroupIdMapper(description) {
      const groupIds = /* @__PURE__ */ new WeakMap();
      return function(node) {
        if (!groupIds.has(node)) {
          groupIds.set(node, Symbol(description));
        }
        return groupIds.get(node);
      };
    }
    function describeNodeForDebugging(node) {
      const nodeType = node.type || node.kind || "(unknown type)";
      let nodeName = String(node.name || node.id && (typeof node.id === "object" ? node.id.name : node.id) || node.key && (typeof node.key === "object" ? node.key.name : node.key) || node.value && (typeof node.value === "object" ? "" : String(node.value)) || node.operator || "");
      if (nodeName.length > 20) {
        nodeName = nodeName.slice(0, 19) + "\u2026";
      }
      return nodeType + (nodeName ? " " + nodeName : "");
    }
    module2.exports = {
      inferParserByLanguage,
      getStringWidth,
      getMaxContinuousCount,
      getMinNotPresentContinuousCount,
      getPenultimate,
      getLast,
      getNextNonSpaceNonCommentCharacterIndexWithStartIndex,
      getNextNonSpaceNonCommentCharacterIndex,
      getNextNonSpaceNonCommentCharacter,
      skip,
      skipWhitespace,
      skipSpaces,
      skipToLineEnd,
      skipEverythingButNewLine,
      skipInlineComment,
      skipTrailingComment,
      skipNewline,
      isNextLineEmptyAfterIndex,
      isNextLineEmpty,
      isPreviousLineEmpty,
      hasNewline,
      hasNewlineInRange,
      hasSpaces,
      getAlignmentSize,
      getIndentSize,
      getPreferredQuote,
      printString,
      printNumber,
      makeString,
      addLeadingComment,
      addDanglingComment,
      addTrailingComment,
      isFrontMatterNode,
      isNonEmptyArray,
      createGroupIdMapper
    };
  }
});
var require_end_of_line = __commonJS2({
  "src/common/end-of-line.js"(exports2, module2) {
    "use strict";
    function guessEndOfLine(text) {
      const index = text.indexOf("\r");
      if (index >= 0) {
        return text.charAt(index + 1) === "\n" ? "crlf" : "cr";
      }
      return "lf";
    }
    function convertEndOfLineToChars(value) {
      switch (value) {
        case "cr":
          return "\r";
        case "crlf":
          return "\r\n";
        default:
          return "\n";
      }
    }
    function countEndOfLineChars(text, eol) {
      let regex;
      switch (eol) {
        case "\n":
          regex = /\n/g;
          break;
        case "\r":
          regex = /\r/g;
          break;
        case "\r\n":
          regex = /\r\n/g;
          break;
        default:
          throw new Error(`Unexpected "eol" ${JSON.stringify(eol)}.`);
      }
      const endOfLines = text.match(regex);
      return endOfLines ? endOfLines.length : 0;
    }
    function normalizeEndOfLine(text) {
      return text.replace(/\r\n?/g, "\n");
    }
    module2.exports = {
      guessEndOfLine,
      convertEndOfLineToChars,
      countEndOfLineChars,
      normalizeEndOfLine
    };
  }
});
var require_errors = __commonJS2({
  "src/common/errors.js"(exports2, module2) {
    "use strict";
    var ConfigError = class extends Error {
    };
    var DebugError = class extends Error {
    };
    var UndefinedParserError = class extends Error {
    };
    var ArgExpansionBailout = class extends Error {
    };
    module2.exports = {
      ConfigError,
      DebugError,
      UndefinedParserError,
      ArgExpansionBailout
    };
  }
});
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports2) {
  for (var p in m)
    if (p !== "default" && !exports2.hasOwnProperty(p))
      exports2[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({
        value: v2,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics;
var __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});
var require_api = __commonJS2({
  "node_modules/vnopts/lib/descriptors/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.apiDescriptor = {
      key: (key) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(key) ? key : JSON.stringify(key),
      value(value) {
        if (value === null || typeof value !== "object") {
          return JSON.stringify(value);
        }
        if (Array.isArray(value)) {
          return `[${value.map((subValue) => exports2.apiDescriptor.value(subValue)).join(", ")}]`;
        }
        const keys = Object.keys(value);
        return keys.length === 0 ? "{}" : `{ ${keys.map((key) => `${exports2.apiDescriptor.key(key)}: ${exports2.apiDescriptor.value(value[key])}`).join(", ")} }`;
      },
      pair: ({
        key,
        value
      }) => exports2.apiDescriptor.value({
        [key]: value
      })
    };
  }
});
var require_descriptors2 = __commonJS2({
  "node_modules/vnopts/lib/descriptors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_api(), exports2);
  }
});
var require_escape_string_regexp = __commonJS2({
  "node_modules/vnopts/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});
var require_color_name = __commonJS2({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});
var require_conversions = __commonJS2({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: {
        channels: 3,
        labels: "rgb"
      },
      hsl: {
        channels: 3,
        labels: "hsl"
      },
      hsv: {
        channels: 3,
        labels: "hsv"
      },
      hwb: {
        channels: 3,
        labels: "hwb"
      },
      cmyk: {
        channels: 4,
        labels: "cmyk"
      },
      xyz: {
        channels: 3,
        labels: "xyz"
      },
      lab: {
        channels: 3,
        labels: "lab"
      },
      lch: {
        channels: 3,
        labels: "lch"
      },
      hex: {
        channels: 1,
        labels: ["hex"]
      },
      keyword: {
        channels: 1,
        labels: ["keyword"]
      },
      ansi16: {
        channels: 1,
        labels: ["ansi16"]
      },
      ansi256: {
        channels: 1,
        labels: ["ansi256"]
      },
      hcg: {
        channels: 3,
        labels: ["h", "c", "g"]
      },
      apple: {
        channels: 3,
        labels: ["r16", "g16", "b16"]
      },
      gray: {
        channels: 1,
        labels: ["gray"]
      }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", {
          value: channels
        });
        Object.defineProperty(convert[model], "labels", {
          value: labels
        });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [h * 360, s * 100, v * 100];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});
var require_route = __commonJS2({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});
var require_color_convert = __commonJS2({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {
        value: conversions[fromModel].channels
      });
      Object.defineProperty(convert[fromModel], "labels", {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});
var require_ansi_styles = __commonJS2({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});
var require_has_flag = __commonJS2({
  "node_modules/vnopts/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});
var require_supports_color = __commonJS2({
  "node_modules/vnopts/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});
var require_templates = __commonJS2({
  "node_modules/vnopts/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({
            inverse,
            styles: parseStyle(style)
          });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});
var require_chalk = __commonJS2({
  "node_modules/vnopts/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp2 = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});
var require_common = __commonJS2({
  "node_modules/vnopts/lib/handlers/deprecated/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var chalk_1 = require_chalk();
    exports2.commonDeprecatedHandler = (keyOrPair, redirectTo, {
      descriptor
    }) => {
      const messages = [`${chalk_1.default.yellow(typeof keyOrPair === "string" ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair))} is deprecated`];
      if (redirectTo) {
        messages.push(`we now treat it as ${chalk_1.default.blue(typeof redirectTo === "string" ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))}`);
      }
      return messages.join("; ") + ".";
    };
  }
});
var require_deprecated = __commonJS2({
  "node_modules/vnopts/lib/handlers/deprecated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_common(), exports2);
  }
});
var require_common2 = __commonJS2({
  "node_modules/vnopts/lib/handlers/invalid/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var chalk_1 = require_chalk();
    exports2.commonInvalidHandler = (key, value, utils) => [`Invalid ${chalk_1.default.red(utils.descriptor.key(key))} value.`, `Expected ${chalk_1.default.blue(utils.schemas[key].expected(utils))},`, `but received ${chalk_1.default.red(utils.descriptor.value(value))}.`].join(" ");
  }
});
var require_invalid = __commonJS2({
  "node_modules/vnopts/lib/handlers/invalid/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_common2(), exports2);
  }
});
var require_leven = __commonJS2({
  "node_modules/vnopts/node_modules/leven/index.js"(exports2, module2) {
    "use strict";
    var arr = [];
    var charCodeCache = [];
    module2.exports = function(a, b) {
      if (a === b) {
        return 0;
      }
      var swap = a;
      if (a.length > b.length) {
        a = b;
        b = swap;
      }
      var aLen = a.length;
      var bLen = b.length;
      if (aLen === 0) {
        return bLen;
      }
      if (bLen === 0) {
        return aLen;
      }
      while (aLen > 0 && a.charCodeAt(~-aLen) === b.charCodeAt(~-bLen)) {
        aLen--;
        bLen--;
      }
      if (aLen === 0) {
        return bLen;
      }
      var start = 0;
      while (start < aLen && a.charCodeAt(start) === b.charCodeAt(start)) {
        start++;
      }
      aLen -= start;
      bLen -= start;
      if (aLen === 0) {
        return bLen;
      }
      var bCharCode;
      var ret;
      var tmp;
      var tmp2;
      var i = 0;
      var j = 0;
      while (i < aLen) {
        charCodeCache[start + i] = a.charCodeAt(start + i);
        arr[i] = ++i;
      }
      while (j < bLen) {
        bCharCode = b.charCodeAt(start + j);
        tmp = j++;
        ret = j;
        for (i = 0; i < aLen; i++) {
          tmp2 = bCharCode === charCodeCache[start + i] ? tmp : tmp + 1;
          tmp = arr[i];
          ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
        }
      }
      return ret;
    };
  }
});
var require_leven2 = __commonJS2({
  "node_modules/vnopts/lib/handlers/unknown/leven.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var chalk_1 = require_chalk();
    var leven = require_leven();
    exports2.levenUnknownHandler = (key, value, {
      descriptor,
      logger,
      schemas
    }) => {
      const messages = [`Ignored unknown option ${chalk_1.default.yellow(descriptor.pair({
        key,
        value
      }))}.`];
      const suggestion = Object.keys(schemas).sort().find((knownKey) => leven(key, knownKey) < 3);
      if (suggestion) {
        messages.push(`Did you mean ${chalk_1.default.blue(descriptor.key(suggestion))}?`);
      }
      logger.warn(messages.join(" "));
    };
  }
});
var require_unknown = __commonJS2({
  "node_modules/vnopts/lib/handlers/unknown/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_leven2(), exports2);
  }
});
var require_handlers = __commonJS2({
  "node_modules/vnopts/lib/handlers/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_deprecated(), exports2);
    tslib_1.__exportStar(require_invalid(), exports2);
    tslib_1.__exportStar(require_unknown(), exports2);
  }
});
var require_schema = __commonJS2({
  "node_modules/vnopts/lib/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var HANDLER_KEYS = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
    function createSchema(SchemaConstructor, parameters) {
      const schema = new SchemaConstructor(parameters);
      const subSchema = Object.create(schema);
      for (const handlerKey of HANDLER_KEYS) {
        if (handlerKey in parameters) {
          subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length);
        }
      }
      return subSchema;
    }
    exports2.createSchema = createSchema;
    var Schema = class {
      constructor(parameters) {
        this.name = parameters.name;
      }
      static create(parameters) {
        return createSchema(this, parameters);
      }
      default(_utils) {
        return void 0;
      }
      expected(_utils) {
        return "nothing";
      }
      validate(_value, _utils) {
        return false;
      }
      deprecated(_value, _utils) {
        return false;
      }
      forward(_value, _utils) {
        return void 0;
      }
      redirect(_value, _utils) {
        return void 0;
      }
      overlap(currentValue, _newValue, _utils) {
        return currentValue;
      }
      preprocess(value, _utils) {
        return value;
      }
      postprocess(value, _utils) {
        return value;
      }
    };
    exports2.Schema = Schema;
    function normalizeHandler(handler, superSchema, handlerArgumentsLength) {
      return typeof handler === "function" ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1)) : () => handler;
    }
  }
});
var require_alias = __commonJS2({
  "node_modules/vnopts/lib/schemas/alias.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var schema_1 = require_schema();
    var AliasSchema = class extends schema_1.Schema {
      constructor(parameters) {
        super(parameters);
        this._sourceName = parameters.sourceName;
      }
      expected(utils) {
        return utils.schemas[this._sourceName].expected(utils);
      }
      validate(value, utils) {
        return utils.schemas[this._sourceName].validate(value, utils);
      }
      redirect(_value, _utils) {
        return this._sourceName;
      }
    };
    exports2.AliasSchema = AliasSchema;
  }
});
var require_any = __commonJS2({
  "node_modules/vnopts/lib/schemas/any.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var schema_1 = require_schema();
    var AnySchema = class extends schema_1.Schema {
      expected() {
        return "anything";
      }
      validate() {
        return true;
      }
    };
    exports2.AnySchema = AnySchema;
  }
});
var require_array2 = __commonJS2({
  "node_modules/vnopts/lib/schemas/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var schema_1 = require_schema();
    var ArraySchema = class extends schema_1.Schema {
      constructor(_a) {
        var {
          valueSchema,
          name = valueSchema.name
        } = _a, handlers = tslib_1.__rest(_a, ["valueSchema", "name"]);
        super(Object.assign({}, handlers, {
          name
        }));
        this._valueSchema = valueSchema;
      }
      expected(utils) {
        return `an array of ${this._valueSchema.expected(utils)}`;
      }
      validate(value, utils) {
        if (!Array.isArray(value)) {
          return false;
        }
        const invalidValues = [];
        for (const subValue of value) {
          const subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);
          if (subValidateResult !== true) {
            invalidValues.push(subValidateResult.value);
          }
        }
        return invalidValues.length === 0 ? true : {
          value: invalidValues
        };
      }
      deprecated(value, utils) {
        const deprecatedResult = [];
        for (const subValue of value) {
          const subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);
          if (subDeprecatedResult !== false) {
            deprecatedResult.push(...subDeprecatedResult.map(({
              value: deprecatedValue
            }) => ({
              value: [deprecatedValue]
            })));
          }
        }
        return deprecatedResult;
      }
      forward(value, utils) {
        const forwardResult = [];
        for (const subValue of value) {
          const subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);
          forwardResult.push(...subForwardResult.map(wrapTransferResult));
        }
        return forwardResult;
      }
      redirect(value, utils) {
        const remain = [];
        const redirect = [];
        for (const subValue of value) {
          const subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);
          if ("remain" in subRedirectResult) {
            remain.push(subRedirectResult.remain);
          }
          redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));
        }
        return remain.length === 0 ? {
          redirect
        } : {
          redirect,
          remain
        };
      }
      overlap(currentValue, newValue) {
        return currentValue.concat(newValue);
      }
    };
    exports2.ArraySchema = ArraySchema;
    function wrapTransferResult({
      from,
      to
    }) {
      return {
        from: [from],
        to
      };
    }
  }
});
var require_boolean = __commonJS2({
  "node_modules/vnopts/lib/schemas/boolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var schema_1 = require_schema();
    var BooleanSchema = class extends schema_1.Schema {
      expected() {
        return "true or false";
      }
      validate(value) {
        return typeof value === "boolean";
      }
    };
    exports2.BooleanSchema = BooleanSchema;
  }
});
var require_utils = __commonJS2({
  "node_modules/vnopts/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function recordFromArray(array, mainKey) {
      const record = /* @__PURE__ */ Object.create(null);
      for (const value of array) {
        const key = value[mainKey];
        if (record[key]) {
          throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key)}`);
        }
        record[key] = value;
      }
      return record;
    }
    exports2.recordFromArray = recordFromArray;
    function mapFromArray(array, mainKey) {
      const map = /* @__PURE__ */ new Map();
      for (const value of array) {
        const key = value[mainKey];
        if (map.has(key)) {
          throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key)}`);
        }
        map.set(key, value);
      }
      return map;
    }
    exports2.mapFromArray = mapFromArray;
    function createAutoChecklist() {
      const map = /* @__PURE__ */ Object.create(null);
      return (id) => {
        const idString = JSON.stringify(id);
        if (map[idString]) {
          return true;
        }
        map[idString] = true;
        return false;
      };
    }
    exports2.createAutoChecklist = createAutoChecklist;
    function partition(array, predicate) {
      const trueArray = [];
      const falseArray = [];
      for (const value of array) {
        if (predicate(value)) {
          trueArray.push(value);
        } else {
          falseArray.push(value);
        }
      }
      return [trueArray, falseArray];
    }
    exports2.partition = partition;
    function isInt(value) {
      return value === Math.floor(value);
    }
    exports2.isInt = isInt;
    function comparePrimitive(a, b) {
      if (a === b) {
        return 0;
      }
      const typeofA = typeof a;
      const typeofB = typeof b;
      const orders = ["undefined", "object", "boolean", "number", "string"];
      if (typeofA !== typeofB) {
        return orders.indexOf(typeofA) - orders.indexOf(typeofB);
      }
      if (typeofA !== "string") {
        return Number(a) - Number(b);
      }
      return a.localeCompare(b);
    }
    exports2.comparePrimitive = comparePrimitive;
    function normalizeDefaultResult(result) {
      return result === void 0 ? {} : result;
    }
    exports2.normalizeDefaultResult = normalizeDefaultResult;
    function normalizeValidateResult(result, value) {
      return result === true ? true : result === false ? {
        value
      } : result;
    }
    exports2.normalizeValidateResult = normalizeValidateResult;
    function normalizeDeprecatedResult(result, value, doNotNormalizeTrue = false) {
      return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{
        value
      }] : "value" in result ? [result] : result.length === 0 ? false : result;
    }
    exports2.normalizeDeprecatedResult = normalizeDeprecatedResult;
    function normalizeTransferResult(result, value) {
      return typeof result === "string" || "key" in result ? {
        from: value,
        to: result
      } : "from" in result ? {
        from: result.from,
        to: result.to
      } : {
        from: value,
        to: result.to
      };
    }
    exports2.normalizeTransferResult = normalizeTransferResult;
    function normalizeForwardResult(result, value) {
      return result === void 0 ? [] : Array.isArray(result) ? result.map((transferResult) => normalizeTransferResult(transferResult, value)) : [normalizeTransferResult(result, value)];
    }
    exports2.normalizeForwardResult = normalizeForwardResult;
    function normalizeRedirectResult(result, value) {
      const redirect = normalizeForwardResult(typeof result === "object" && "redirect" in result ? result.redirect : result, value);
      return redirect.length === 0 ? {
        remain: value,
        redirect
      } : typeof result === "object" && "remain" in result ? {
        remain: result.remain,
        redirect
      } : {
        redirect
      };
    }
    exports2.normalizeRedirectResult = normalizeRedirectResult;
  }
});
var require_choice = __commonJS2({
  "node_modules/vnopts/lib/schemas/choice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var schema_1 = require_schema();
    var utils_1 = require_utils();
    var ChoiceSchema = class extends schema_1.Schema {
      constructor(parameters) {
        super(parameters);
        this._choices = utils_1.mapFromArray(parameters.choices.map((choice) => choice && typeof choice === "object" ? choice : {
          value: choice
        }), "value");
      }
      expected({
        descriptor
      }) {
        const choiceValues = Array.from(this._choices.keys()).map((value) => this._choices.get(value)).filter((choiceInfo) => !choiceInfo.deprecated).map((choiceInfo) => choiceInfo.value).sort(utils_1.comparePrimitive).map(descriptor.value);
        const head = choiceValues.slice(0, -2);
        const tail = choiceValues.slice(-2);
        return head.concat(tail.join(" or ")).join(", ");
      }
      validate(value) {
        return this._choices.has(value);
      }
      deprecated(value) {
        const choiceInfo = this._choices.get(value);
        return choiceInfo && choiceInfo.deprecated ? {
          value
        } : false;
      }
      forward(value) {
        const choiceInfo = this._choices.get(value);
        return choiceInfo ? choiceInfo.forward : void 0;
      }
      redirect(value) {
        const choiceInfo = this._choices.get(value);
        return choiceInfo ? choiceInfo.redirect : void 0;
      }
    };
    exports2.ChoiceSchema = ChoiceSchema;
  }
});
var require_number = __commonJS2({
  "node_modules/vnopts/lib/schemas/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var schema_1 = require_schema();
    var NumberSchema = class extends schema_1.Schema {
      expected() {
        return "a number";
      }
      validate(value, _utils) {
        return typeof value === "number";
      }
    };
    exports2.NumberSchema = NumberSchema;
  }
});
var require_integer = __commonJS2({
  "node_modules/vnopts/lib/schemas/integer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var utils_1 = require_utils();
    var number_1 = require_number();
    var IntegerSchema = class extends number_1.NumberSchema {
      expected() {
        return "an integer";
      }
      validate(value, utils) {
        return utils.normalizeValidateResult(super.validate(value, utils), value) === true && utils_1.isInt(value);
      }
    };
    exports2.IntegerSchema = IntegerSchema;
  }
});
var require_string = __commonJS2({
  "node_modules/vnopts/lib/schemas/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var schema_1 = require_schema();
    var StringSchema = class extends schema_1.Schema {
      expected() {
        return "a string";
      }
      validate(value) {
        return typeof value === "string";
      }
    };
    exports2.StringSchema = StringSchema;
  }
});
var require_schemas = __commonJS2({
  "node_modules/vnopts/lib/schemas/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_alias(), exports2);
    tslib_1.__exportStar(require_any(), exports2);
    tslib_1.__exportStar(require_array2(), exports2);
    tslib_1.__exportStar(require_boolean(), exports2);
    tslib_1.__exportStar(require_choice(), exports2);
    tslib_1.__exportStar(require_integer(), exports2);
    tslib_1.__exportStar(require_number(), exports2);
    tslib_1.__exportStar(require_string(), exports2);
  }
});
var require_defaults = __commonJS2({
  "node_modules/vnopts/lib/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var api_1 = require_api();
    var common_1 = require_common();
    var invalid_1 = require_invalid();
    var leven_1 = require_leven2();
    exports2.defaultDescriptor = api_1.apiDescriptor;
    exports2.defaultUnknownHandler = leven_1.levenUnknownHandler;
    exports2.defaultInvalidHandler = invalid_1.commonInvalidHandler;
    exports2.defaultDeprecatedHandler = common_1.commonDeprecatedHandler;
  }
});
var require_normalize = __commonJS2({
  "node_modules/vnopts/lib/normalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var defaults_1 = require_defaults();
    var utils_1 = require_utils();
    exports2.normalize = (options, schemas, opts) => new Normalizer(schemas, opts).normalize(options);
    var Normalizer = class {
      constructor(schemas, opts) {
        const {
          logger = console,
          descriptor = defaults_1.defaultDescriptor,
          unknown = defaults_1.defaultUnknownHandler,
          invalid = defaults_1.defaultInvalidHandler,
          deprecated = defaults_1.defaultDeprecatedHandler
        } = opts || {};
        this._utils = {
          descriptor,
          logger: logger || {
            warn: () => {
            }
          },
          schemas: utils_1.recordFromArray(schemas, "name"),
          normalizeDefaultResult: utils_1.normalizeDefaultResult,
          normalizeDeprecatedResult: utils_1.normalizeDeprecatedResult,
          normalizeForwardResult: utils_1.normalizeForwardResult,
          normalizeRedirectResult: utils_1.normalizeRedirectResult,
          normalizeValidateResult: utils_1.normalizeValidateResult
        };
        this._unknownHandler = unknown;
        this._invalidHandler = invalid;
        this._deprecatedHandler = deprecated;
        this.cleanHistory();
      }
      cleanHistory() {
        this._hasDeprecationWarned = utils_1.createAutoChecklist();
      }
      normalize(options) {
        const normalized = {};
        const restOptionsArray = [options];
        const applyNormalization = () => {
          while (restOptionsArray.length !== 0) {
            const currentOptions = restOptionsArray.shift();
            const transferredOptionsArray = this._applyNormalization(currentOptions, normalized);
            restOptionsArray.push(...transferredOptionsArray);
          }
        };
        applyNormalization();
        for (const key of Object.keys(this._utils.schemas)) {
          const schema = this._utils.schemas[key];
          if (!(key in normalized)) {
            const defaultResult = utils_1.normalizeDefaultResult(schema.default(this._utils));
            if ("value" in defaultResult) {
              restOptionsArray.push({
                [key]: defaultResult.value
              });
            }
          }
        }
        applyNormalization();
        for (const key of Object.keys(this._utils.schemas)) {
          const schema = this._utils.schemas[key];
          if (key in normalized) {
            normalized[key] = schema.postprocess(normalized[key], this._utils);
          }
        }
        return normalized;
      }
      _applyNormalization(options, normalized) {
        const transferredOptionsArray = [];
        const [knownOptionNames, unknownOptionNames] = utils_1.partition(Object.keys(options), (key) => key in this._utils.schemas);
        for (const key of knownOptionNames) {
          const schema = this._utils.schemas[key];
          const value = schema.preprocess(options[key], this._utils);
          const validateResult = utils_1.normalizeValidateResult(schema.validate(value, this._utils), value);
          if (validateResult !== true) {
            const {
              value: invalidValue
            } = validateResult;
            const errorMessageOrError = this._invalidHandler(key, invalidValue, this._utils);
            throw typeof errorMessageOrError === "string" ? new Error(errorMessageOrError) : errorMessageOrError;
          }
          const appendTransferredOptions = ({
            from,
            to
          }) => {
            transferredOptionsArray.push(typeof to === "string" ? {
              [to]: from
            } : {
              [to.key]: to.value
            });
          };
          const warnDeprecated = ({
            value: currentValue,
            redirectTo
          }) => {
            const deprecatedResult = utils_1.normalizeDeprecatedResult(schema.deprecated(currentValue, this._utils), value, true);
            if (deprecatedResult === false) {
              return;
            }
            if (deprecatedResult === true) {
              if (!this._hasDeprecationWarned(key)) {
                this._utils.logger.warn(this._deprecatedHandler(key, redirectTo, this._utils));
              }
            } else {
              for (const {
                value: deprecatedValue
              } of deprecatedResult) {
                const pair = {
                  key,
                  value: deprecatedValue
                };
                if (!this._hasDeprecationWarned(pair)) {
                  const redirectToPair = typeof redirectTo === "string" ? {
                    key: redirectTo,
                    value: deprecatedValue
                  } : redirectTo;
                  this._utils.logger.warn(this._deprecatedHandler(pair, redirectToPair, this._utils));
                }
              }
            }
          };
          const forwardResult = utils_1.normalizeForwardResult(schema.forward(value, this._utils), value);
          forwardResult.forEach(appendTransferredOptions);
          const redirectResult = utils_1.normalizeRedirectResult(schema.redirect(value, this._utils), value);
          redirectResult.redirect.forEach(appendTransferredOptions);
          if ("remain" in redirectResult) {
            const remainingValue = redirectResult.remain;
            normalized[key] = key in normalized ? schema.overlap(normalized[key], remainingValue, this._utils) : remainingValue;
            warnDeprecated({
              value: remainingValue
            });
          }
          for (const {
            from,
            to
          } of redirectResult.redirect) {
            warnDeprecated({
              value: from,
              redirectTo: to
            });
          }
        }
        for (const key of unknownOptionNames) {
          const value = options[key];
          const unknownResult = this._unknownHandler(key, value, this._utils);
          if (unknownResult) {
            for (const unknownKey of Object.keys(unknownResult)) {
              const unknownOption = {
                [unknownKey]: unknownResult[unknownKey]
              };
              if (unknownKey in this._utils.schemas) {
                transferredOptionsArray.push(unknownOption);
              } else {
                Object.assign(normalized, unknownOption);
              }
            }
          }
        }
        return transferredOptionsArray;
      }
    };
    exports2.Normalizer = Normalizer;
  }
});
var require_lib2 = __commonJS2({
  "node_modules/vnopts/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_descriptors2(), exports2);
    tslib_1.__exportStar(require_handlers(), exports2);
    tslib_1.__exportStar(require_schemas(), exports2);
    tslib_1.__exportStar(require_normalize(), exports2);
    tslib_1.__exportStar(require_schema(), exports2);
  }
});
var require_options_normalizer = __commonJS2({
  "src/main/options-normalizer.js"(exports2, module2) {
    "use strict";
    var vnopts = require_lib2();
    var getLast = require_get_last();
    var cliDescriptor = {
      key: (key) => key.length === 1 ? `-${key}` : `--${key}`,
      value: (value) => vnopts.apiDescriptor.value(value),
      pair: ({
        key,
        value
      }) => value === false ? `--no-${key}` : value === true ? cliDescriptor.key(key) : value === "" ? `${cliDescriptor.key(key)} without an argument` : `${cliDescriptor.key(key)}=${value}`
    };
    var getFlagSchema = ({
      colorsModule,
      levenshteinDistance
    }) => class FlagSchema extends vnopts.ChoiceSchema {
      constructor({
        name,
        flags
      }) {
        super({
          name,
          choices: flags
        });
        this._flags = [...flags].sort();
      }
      preprocess(value, utils) {
        if (typeof value === "string" && value.length > 0 && !this._flags.includes(value)) {
          const suggestion = this._flags.find((flag) => levenshteinDistance(flag, value) < 3);
          if (suggestion) {
            utils.logger.warn([`Unknown flag ${colorsModule.yellow(utils.descriptor.value(value))},`, `did you mean ${colorsModule.blue(utils.descriptor.value(suggestion))}?`].join(" "));
            return suggestion;
          }
        }
        return value;
      }
      expected() {
        return "a flag";
      }
    };
    var hasDeprecationWarned;
    function normalizeOptions(options, optionInfos, {
      logger = false,
      isCLI = false,
      passThrough = false,
      colorsModule = null,
      levenshteinDistance = null
    } = {}) {
      const unknown = !passThrough ? (key, value, options2) => {
        const _options2$schemas = options2.schemas, {
          _
        } = _options2$schemas, schemas2 = _objectWithoutProperties(_options2$schemas, _excluded2);
        return vnopts.levenUnknownHandler(key, value, Object.assign(Object.assign({}, options2), {}, {
          schemas: schemas2
        }));
      } : Array.isArray(passThrough) ? (key, value) => !passThrough.includes(key) ? void 0 : {
        [key]: value
      } : (key, value) => ({
        [key]: value
      });
      const descriptor = isCLI ? cliDescriptor : vnopts.apiDescriptor;
      const schemas = optionInfosToSchemas(optionInfos, {
        isCLI,
        colorsModule,
        levenshteinDistance
      });
      const normalizer = new vnopts.Normalizer(schemas, {
        logger,
        unknown,
        descriptor
      });
      const shouldSuppressDuplicateDeprecationWarnings = logger !== false;
      if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {
        normalizer._hasDeprecationWarned = hasDeprecationWarned;
      }
      const normalized = normalizer.normalize(options);
      if (shouldSuppressDuplicateDeprecationWarnings) {
        hasDeprecationWarned = normalizer._hasDeprecationWarned;
      }
      if (isCLI && normalized["plugin-search"] === false) {
        normalized["plugin-search-dir"] = false;
      }
      return normalized;
    }
    function optionInfosToSchemas(optionInfos, {
      isCLI,
      colorsModule,
      levenshteinDistance
    }) {
      const schemas = [];
      if (isCLI) {
        schemas.push(vnopts.AnySchema.create({
          name: "_"
        }));
      }
      for (const optionInfo of optionInfos) {
        schemas.push(optionInfoToSchema(optionInfo, {
          isCLI,
          optionInfos,
          colorsModule,
          levenshteinDistance
        }));
        if (optionInfo.alias && isCLI) {
          schemas.push(vnopts.AliasSchema.create({
            name: optionInfo.alias,
            sourceName: optionInfo.name
          }));
        }
      }
      return schemas;
    }
    function optionInfoToSchema(optionInfo, {
      isCLI,
      optionInfos,
      colorsModule,
      levenshteinDistance
    }) {
      const {
        name
      } = optionInfo;
      if (name === "plugin-search-dir" || name === "pluginSearchDirs") {
        return vnopts.AnySchema.create({
          name,
          preprocess(value) {
            if (value === false) {
              return value;
            }
            value = Array.isArray(value) ? value : [value];
            return value;
          },
          validate(value) {
            if (value === false) {
              return true;
            }
            return value.every((dir) => typeof dir === "string");
          },
          expected() {
            return "false or paths to plugin search dir";
          }
        });
      }
      const parameters = {
        name
      };
      let SchemaConstructor;
      const handlers = {};
      switch (optionInfo.type) {
        case "int":
          SchemaConstructor = vnopts.IntegerSchema;
          if (isCLI) {
            parameters.preprocess = Number;
          }
          break;
        case "string":
          SchemaConstructor = vnopts.StringSchema;
          break;
        case "choice":
          SchemaConstructor = vnopts.ChoiceSchema;
          parameters.choices = optionInfo.choices.map((choiceInfo) => typeof choiceInfo === "object" && choiceInfo.redirect ? Object.assign(Object.assign({}, choiceInfo), {}, {
            redirect: {
              to: {
                key: optionInfo.name,
                value: choiceInfo.redirect
              }
            }
          }) : choiceInfo);
          break;
        case "boolean":
          SchemaConstructor = vnopts.BooleanSchema;
          break;
        case "flag":
          SchemaConstructor = getFlagSchema({
            colorsModule,
            levenshteinDistance
          });
          parameters.flags = optionInfos.flatMap((optionInfo2) => [optionInfo2.alias, optionInfo2.description && optionInfo2.name, optionInfo2.oppositeDescription && `no-${optionInfo2.name}`].filter(Boolean));
          break;
        case "path":
          SchemaConstructor = vnopts.StringSchema;
          break;
        default:
          throw new Error(`Unexpected type ${optionInfo.type}`);
      }
      if (optionInfo.exception) {
        parameters.validate = (value, schema, utils) => optionInfo.exception(value) || schema.validate(value, utils);
      } else {
        parameters.validate = (value, schema, utils) => value === void 0 || schema.validate(value, utils);
      }
      if (optionInfo.redirect) {
        handlers.redirect = (value) => !value ? void 0 : {
          to: {
            key: optionInfo.redirect.option,
            value: optionInfo.redirect.value
          }
        };
      }
      if (optionInfo.deprecated) {
        handlers.deprecated = true;
      }
      if (isCLI && !optionInfo.array) {
        const originalPreprocess = parameters.preprocess || ((x) => x);
        parameters.preprocess = (value, schema, utils) => schema.preprocess(originalPreprocess(Array.isArray(value) ? getLast(value) : value), utils);
      }
      return optionInfo.array ? vnopts.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, isCLI ? {
        preprocess: (v) => Array.isArray(v) ? v : [v]
      } : {}), handlers), {}, {
        valueSchema: SchemaConstructor.create(parameters)
      })) : SchemaConstructor.create(Object.assign(Object.assign({}, parameters), handlers));
    }
    function normalizeApiOptions(options, optionInfos, opts) {
      return normalizeOptions(options, optionInfos, opts);
    }
    function normalizeCliOptions(options, optionInfos, opts) {
      if (false) {
        if (!opts.colorsModule) {
          throw new Error("'colorsModule' option is required.");
        }
        if (!opts.levenshteinDistance) {
          throw new Error("'levenshteinDistance' option is required.");
        }
      }
      return normalizeOptions(options, optionInfos, Object.assign({
        isCLI: true
      }, opts));
    }
    module2.exports = {
      normalizeApiOptions,
      normalizeCliOptions
    };
  }
});
var require_loc = __commonJS2({
  "src/language-js/loc.js"(exports2, module2) {
    "use strict";
    var isNonEmptyArray = require_is_non_empty_array();
    function locStart(node) {
      var _node$declaration$dec, _node$declaration;
      const start = node.range ? node.range[0] : node.start;
      const decorators = (_node$declaration$dec = (_node$declaration = node.declaration) === null || _node$declaration === void 0 ? void 0 : _node$declaration.decorators) !== null && _node$declaration$dec !== void 0 ? _node$declaration$dec : node.decorators;
      if (isNonEmptyArray(decorators)) {
        return Math.min(locStart(decorators[0]), start);
      }
      return start;
    }
    function locEnd(node) {
      return node.range ? node.range[1] : node.end;
    }
    function hasSameLocStart(nodeA, nodeB) {
      const nodeAStart = locStart(nodeA);
      return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);
    }
    function hasSameLocEnd(nodeA, nodeB) {
      const nodeAEnd = locEnd(nodeA);
      return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);
    }
    function hasSameLoc(nodeA, nodeB) {
      return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);
    }
    module2.exports = {
      locStart,
      locEnd,
      hasSameLocStart,
      hasSameLoc
    };
  }
});
var require_load_parser = __commonJS2({
  "src/main/load-parser.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var {
      ConfigError
    } = require_errors();
    var {
      locStart,
      locEnd
    } = require_loc();
    function requireParser(parser) {
      try {
        return {
          parse: require(path.resolve(process.cwd(), parser)),
          astFormat: "estree",
          locStart,
          locEnd
        };
      } catch {
        throw new ConfigError(`Couldn't resolve parser "${parser}"`);
      }
    }
    module2.exports = requireParser;
  }
});
var require_js_tokens = __commonJS2({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token = {
        type: "invalid",
        value: match[0],
        closed: void 0
      };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});
var require_identifier = __commonJS2({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = true;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          const trail = name.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp)) {
            return false;
          }
        } else if (!isIdentifierChar(cp)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});
var require_keyword = __commonJS2({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});
var require_lib3 = __commonJS2({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});
var require_escape_string_regexp2 = __commonJS2({
  "node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});
var require_has_flag2 = __commonJS2({
  "node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});
var require_supports_color2 = __commonJS2({
  "node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});
var require_templates2 = __commonJS2({
  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", "\x1B"], ["a", "\x07"]]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({
            inverse,
            styles: parseStyle(style)
          });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});
var require_chalk2 = __commonJS2({
  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp2 = require_escape_string_regexp2();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color2().stdout;
    var template = require_templates2();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});
var require_lib4 = __commonJS2({
  "node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = highlight;
    exports2.getChalk = getChalk;
    exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens();
    var _helperValidatorIdentifier = require_lib3();
    var _chalk = require_chalk2();
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsxIdentifier: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize = function* (text) {
        let match;
        while (match = _jsTokens.default.exec(text)) {
          const token = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token, match.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type,
        value
      } of tokenize(text)) {
        const colorize = defs[type];
        if (colorize) {
          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\n");
        } else {
          highlighted += value;
        }
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return !!_chalk.supportsColor || options.forceColor;
    }
    function getChalk(options) {
      return options.forceColor ? new _chalk.constructor({
        enabled: true,
        level: 1
      }) : _chalk;
    }
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        const chalk = getChalk(options);
        const defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  }
});
var require_lib5 = __commonJS2({
  "node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default;
    var _highlight = require_lib4();
    var deprecationWarningShown = false;
    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
      const chalk = (0, _highlight.getChalk)(opts);
      const defs = getDefs(chalk);
      const maybeHighlight = (chalkFn, string) => {
        return highlighted ? chalkFn(string) : string;
      };
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  }
});
var require_parser = __commonJS2({
  "src/main/parser.js"(exports2, module2) {
    "use strict";
    var {
      ConfigError
    } = require_errors();
    var jsLoc = require_loc();
    var loadParser = require_load_parser();
    var {
      locStart,
      locEnd
    } = jsLoc;
    var ownNames = Object.getOwnPropertyNames;
    var ownDescriptor = Object.getOwnPropertyDescriptor;
    function getParsers(options) {
      const parsers = {};
      for (const plugin of options.plugins) {
        if (!plugin.parsers) {
          continue;
        }
        for (const name of ownNames(plugin.parsers)) {
          Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));
        }
      }
      return parsers;
    }
    function resolveParser(opts, parsers = getParsers(opts)) {
      if (typeof opts.parser === "function") {
        return {
          parse: opts.parser,
          astFormat: "estree",
          locStart,
          locEnd
        };
      }
      if (typeof opts.parser === "string") {
        if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {
          return parsers[opts.parser];
        }
        if (false) {
          throw new ConfigError(`Couldn't resolve parser "${opts.parser}". Parsers must be explicitly added to the standalone bundle.`);
        }
        return loadParser(opts.parser);
      }
    }
    function parse(text, opts) {
      const parsers = getParsers(opts);
      const parsersForCustomParserApi = Object.defineProperties({}, Object.fromEntries(Object.keys(parsers).map((parserName) => [parserName, {
        enumerable: true,
        get() {
          return parsers[parserName].parse;
        }
      }])));
      const parser = resolveParser(opts, parsers);
      try {
        if (parser.preprocess) {
          text = parser.preprocess(text, opts);
        }
        return {
          text,
          ast: parser.parse(text, parsersForCustomParserApi, opts)
        };
      } catch (error) {
        const {
          loc
        } = error;
        if (loc) {
          const {
            codeFrameColumns
          } = require_lib5();
          error.codeFrame = codeFrameColumns(text, loc, {
            highlightCode: true
          });
          error.message += "\n" + error.codeFrame;
          throw error;
        }
        throw error;
      }
    }
    module2.exports = {
      parse,
      resolveParser
    };
  }
});
var require_readlines = __commonJS2({
  "node_modules/n-readlines/readlines.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var LineByLine = class {
      constructor(file, options) {
        options = options || {};
        if (!options.readChunk)
          options.readChunk = 1024;
        if (!options.newLineCharacter) {
          options.newLineCharacter = 10;
        } else {
          options.newLineCharacter = options.newLineCharacter.charCodeAt(0);
        }
        if (typeof file === "number") {
          this.fd = file;
        } else {
          this.fd = fs.openSync(file, "r");
        }
        this.options = options;
        this.newLineCharacter = options.newLineCharacter;
        this.reset();
      }
      _searchInBuffer(buffer, hexNeedle) {
        let found = -1;
        for (let i = 0; i <= buffer.length; i++) {
          let b_byte = buffer[i];
          if (b_byte === hexNeedle) {
            found = i;
            break;
          }
        }
        return found;
      }
      reset() {
        this.eofReached = false;
        this.linesCache = [];
        this.fdPosition = 0;
      }
      close() {
        fs.closeSync(this.fd);
        this.fd = null;
      }
      _extractLines(buffer) {
        let line;
        const lines = [];
        let bufferPosition = 0;
        let lastNewLineBufferPosition = 0;
        while (true) {
          let bufferPositionValue = buffer[bufferPosition++];
          if (bufferPositionValue === this.newLineCharacter) {
            line = buffer.slice(lastNewLineBufferPosition, bufferPosition);
            lines.push(line);
            lastNewLineBufferPosition = bufferPosition;
          } else if (bufferPositionValue === void 0) {
            break;
          }
        }
        let leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);
        if (leftovers.length) {
          lines.push(leftovers);
        }
        return lines;
      }
      _readChunk(lineLeftovers) {
        let totalBytesRead = 0;
        let bytesRead;
        const buffers = [];
        do {
          const readBuffer = new Buffer(this.options.readChunk);
          bytesRead = fs.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);
          totalBytesRead = totalBytesRead + bytesRead;
          this.fdPosition = this.fdPosition + bytesRead;
          buffers.push(readBuffer);
        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);
        let bufferData = Buffer.concat(buffers);
        if (bytesRead < this.options.readChunk) {
          this.eofReached = true;
          bufferData = bufferData.slice(0, totalBytesRead);
        }
        if (totalBytesRead) {
          this.linesCache = this._extractLines(bufferData);
          if (lineLeftovers) {
            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);
          }
        }
        return totalBytesRead;
      }
      next() {
        if (!this.fd)
          return false;
        let line = false;
        if (this.eofReached && this.linesCache.length === 0) {
          return line;
        }
        let bytesRead;
        if (!this.linesCache.length) {
          bytesRead = this._readChunk();
        }
        if (this.linesCache.length) {
          line = this.linesCache.shift();
          const lastLineCharacter = line[line.length - 1];
          if (lastLineCharacter !== this.newLineCharacter) {
            bytesRead = this._readChunk(line);
            if (bytesRead) {
              line = this.linesCache.shift();
            }
          }
        }
        if (this.eofReached && this.linesCache.length === 0) {
          this.close();
        }
        if (line && line[line.length - 1] === this.newLineCharacter) {
          line = line.slice(0, line.length - 1);
        }
        return line;
      }
    };
    module2.exports = LineByLine;
  }
});
var require_get_interpreter = __commonJS2({
  "src/utils/get-interpreter.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var readlines = require_readlines();
    function getInterpreter(filepath) {
      if (typeof filepath !== "string") {
        return "";
      }
      let fd;
      try {
        fd = fs.openSync(filepath, "r");
      } catch {
        return "";
      }
      try {
        const liner = new readlines(fd);
        const firstLine = liner.next().toString("utf8");
        const m1 = firstLine.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
        if (m1) {
          return m1[1];
        }
        const m2 = firstLine.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
        if (m2) {
          return m2[1];
        }
        return "";
      } catch {
        return "";
      } finally {
        try {
          fs.closeSync(fd);
        } catch {
        }
      }
    }
    module2.exports = getInterpreter;
  }
});
var require_options = __commonJS2({
  "src/main/options.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var {
      UndefinedParserError
    } = require_errors();
    var {
      getSupportInfo: getSupportInfo2
    } = require_support();
    var normalizer = require_options_normalizer();
    var {
      resolveParser
    } = require_parser();
    var hiddenDefaults = {
      astFormat: "estree",
      printer: {},
      originalText: void 0,
      locStart: null,
      locEnd: null
    };
    function normalize(options, opts = {}) {
      const rawOptions = Object.assign({}, options);
      const supportOptions = getSupportInfo2({
        plugins: options.plugins,
        showUnreleased: true,
        showDeprecated: true
      }).options;
      const defaults = Object.assign(Object.assign({}, hiddenDefaults), Object.fromEntries(supportOptions.filter((optionInfo) => optionInfo.default !== void 0).map((option) => [option.name, option.default])));
      if (!rawOptions.parser) {
        if (!rawOptions.filepath) {
          const logger = opts.logger || console;
          logger.warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.");
          rawOptions.parser = "babel";
        } else {
          rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);
          if (!rawOptions.parser) {
            throw new UndefinedParserError(`No parser could be inferred for file: ${rawOptions.filepath}`);
          }
        }
      }
      const parser = resolveParser(normalizer.normalizeApiOptions(rawOptions, [supportOptions.find((x) => x.name === "parser")], {
        passThrough: true,
        logger: false
      }));
      rawOptions.astFormat = parser.astFormat;
      rawOptions.locEnd = parser.locEnd;
      rawOptions.locStart = parser.locStart;
      const plugin = getPlugin(rawOptions);
      rawOptions.printer = plugin.printers[rawOptions.astFormat];
      const pluginDefaults = Object.fromEntries(supportOptions.filter((optionInfo) => optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== void 0).map((optionInfo) => [optionInfo.name, optionInfo.pluginDefaults[plugin.name]]));
      const mixedDefaults = Object.assign(Object.assign({}, defaults), pluginDefaults);
      for (const [k, value] of Object.entries(mixedDefaults)) {
        if (rawOptions[k] === null || rawOptions[k] === void 0) {
          rawOptions[k] = value;
        }
      }
      if (rawOptions.parser === "json") {
        rawOptions.trailingComma = "none";
      }
      return normalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({
        passThrough: Object.keys(hiddenDefaults)
      }, opts));
    }
    function getPlugin(options) {
      const {
        astFormat
      } = options;
      if (!astFormat) {
        throw new Error("getPlugin() requires astFormat to be set");
      }
      const printerPlugin = options.plugins.find((plugin) => plugin.printers && plugin.printers[astFormat]);
      if (!printerPlugin) {
        throw new Error(`Couldn't find plugin for AST format "${astFormat}"`);
      }
      return printerPlugin;
    }
    function inferParser(filepath, plugins2) {
      const filename = path.basename(filepath).toLowerCase();
      const languages = getSupportInfo2({
        plugins: plugins2
      }).languages.filter((language2) => language2.since !== null);
      let language = languages.find((language2) => language2.extensions && language2.extensions.some((extension) => filename.endsWith(extension)) || language2.filenames && language2.filenames.some((name) => name.toLowerCase() === filename));
      if (!language && !filename.includes(".")) {
        const getInterpreter = require_get_interpreter();
        const interpreter = getInterpreter(filepath);
        language = languages.find((language2) => language2.interpreters && language2.interpreters.includes(interpreter));
      }
      return language && language.parsers[0];
    }
    module2.exports = {
      normalize,
      hiddenDefaults,
      inferParser
    };
  }
});
var require_massage_ast = __commonJS2({
  "src/main/massage-ast.js"(exports2, module2) {
    "use strict";
    function massageAST(ast, options, parent) {
      if (Array.isArray(ast)) {
        return ast.map((e) => massageAST(e, options, parent)).filter(Boolean);
      }
      if (!ast || typeof ast !== "object") {
        return ast;
      }
      const cleanFunction = options.printer.massageAstNode;
      let ignoredProperties;
      if (cleanFunction && cleanFunction.ignoredProperties) {
        ignoredProperties = cleanFunction.ignoredProperties;
      } else {
        ignoredProperties = /* @__PURE__ */ new Set();
      }
      const newObj = {};
      for (const [key, value] of Object.entries(ast)) {
        if (!ignoredProperties.has(key) && typeof value !== "function") {
          newObj[key] = massageAST(value, options, ast);
        }
      }
      if (cleanFunction) {
        const result = cleanFunction(ast, newObj, parent);
        if (result === null) {
          return;
        }
        if (result) {
          return result;
        }
      }
      return newObj;
    }
    module2.exports = massageAST;
  }
});
var require_comments = __commonJS2({
  "src/main/comments.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var {
      builders: {
        line,
        hardline,
        breakParent,
        indent,
        lineSuffix,
        join,
        cursor
      }
    } = require("./doc.js");
    var {
      hasNewline,
      skipNewline,
      skipSpaces,
      isPreviousLineEmpty,
      addLeadingComment,
      addDanglingComment,
      addTrailingComment
    } = require_util();
    var childNodesCache = /* @__PURE__ */ new WeakMap();
    function getSortedChildNodes(node, options, resultArray) {
      if (!node) {
        return;
      }
      const {
        printer,
        locStart,
        locEnd
      } = options;
      if (resultArray) {
        if (printer.canAttachComment && printer.canAttachComment(node)) {
          let i;
          for (i = resultArray.length - 1; i >= 0; --i) {
            if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {
              break;
            }
          }
          resultArray.splice(i + 1, 0, node);
          return;
        }
      } else if (childNodesCache.has(node)) {
        return childNodesCache.get(node);
      }
      const childNodes = printer.getCommentChildNodes && printer.getCommentChildNodes(node, options) || typeof node === "object" && Object.entries(node).filter(([key]) => key !== "enclosingNode" && key !== "precedingNode" && key !== "followingNode" && key !== "tokens" && key !== "comments" && key !== "parent").map(([, value]) => value);
      if (!childNodes) {
        return;
      }
      if (!resultArray) {
        resultArray = [];
        childNodesCache.set(node, resultArray);
      }
      for (const childNode of childNodes) {
        getSortedChildNodes(childNode, options, resultArray);
      }
      return resultArray;
    }
    function decorateComment(node, comment, options, enclosingNode) {
      const {
        locStart,
        locEnd
      } = options;
      const commentStart = locStart(comment);
      const commentEnd = locEnd(comment);
      const childNodes = getSortedChildNodes(node, options);
      let precedingNode;
      let followingNode;
      let left = 0;
      let right = childNodes.length;
      while (left < right) {
        const middle = left + right >> 1;
        const child = childNodes[middle];
        const start = locStart(child);
        const end = locEnd(child);
        if (start <= commentStart && commentEnd <= end) {
          return decorateComment(child, comment, options, child);
        }
        if (end <= commentStart) {
          precedingNode = child;
          left = middle + 1;
          continue;
        }
        if (commentEnd <= start) {
          followingNode = child;
          right = middle;
          continue;
        }
        throw new Error("Comment location overlaps with node location");
      }
      if (enclosingNode && enclosingNode.type === "TemplateLiteral") {
        const {
          quasis
        } = enclosingNode;
        const commentIndex = findExpressionIndexForComment(quasis, comment, options);
        if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {
          precedingNode = null;
        }
        if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {
          followingNode = null;
        }
      }
      return {
        enclosingNode,
        precedingNode,
        followingNode
      };
    }
    var returnFalse = () => false;
    function attach(comments, ast, text, options) {
      if (!Array.isArray(comments)) {
        return;
      }
      const tiesToBreak = [];
      const {
        locStart,
        locEnd,
        printer: {
          handleComments = {}
        }
      } = options;
      const {
        avoidAstMutation,
        ownLine: handleOwnLineComment = returnFalse,
        endOfLine: handleEndOfLineComment = returnFalse,
        remaining: handleRemainingComment = returnFalse
      } = handleComments;
      const decoratedComments = comments.map((comment, index) => Object.assign(Object.assign({}, decorateComment(ast, comment, options)), {}, {
        comment,
        text,
        options,
        ast,
        isLastComment: comments.length - 1 === index
      }));
      for (const [index, context] of decoratedComments.entries()) {
        const {
          comment,
          precedingNode,
          enclosingNode,
          followingNode,
          text: text2,
          options: options2,
          ast: ast2,
          isLastComment
        } = context;
        if (options2.parser === "json" || options2.parser === "json5" || options2.parser === "__js_expression" || options2.parser === "__vue_expression" || options2.parser === "__vue_ts_expression") {
          if (locStart(comment) - locStart(ast2) <= 0) {
            addLeadingComment(ast2, comment);
            continue;
          }
          if (locEnd(comment) - locEnd(ast2) >= 0) {
            addTrailingComment(ast2, comment);
            continue;
          }
        }
        let args;
        if (avoidAstMutation) {
          args = [context];
        } else {
          comment.enclosingNode = enclosingNode;
          comment.precedingNode = precedingNode;
          comment.followingNode = followingNode;
          args = [comment, text2, options2, ast2, isLastComment];
        }
        if (isOwnLineComment(text2, options2, decoratedComments, index)) {
          comment.placement = "ownLine";
          if (handleOwnLineComment(...args)) {
          } else if (followingNode) {
            addLeadingComment(followingNode, comment);
          } else if (precedingNode) {
            addTrailingComment(precedingNode, comment);
          } else if (enclosingNode) {
            addDanglingComment(enclosingNode, comment);
          } else {
            addDanglingComment(ast2, comment);
          }
        } else if (isEndOfLineComment(text2, options2, decoratedComments, index)) {
          comment.placement = "endOfLine";
          if (handleEndOfLineComment(...args)) {
          } else if (precedingNode) {
            addTrailingComment(precedingNode, comment);
          } else if (followingNode) {
            addLeadingComment(followingNode, comment);
          } else if (enclosingNode) {
            addDanglingComment(enclosingNode, comment);
          } else {
            addDanglingComment(ast2, comment);
          }
        } else {
          comment.placement = "remaining";
          if (handleRemainingComment(...args)) {
          } else if (precedingNode && followingNode) {
            const tieCount = tiesToBreak.length;
            if (tieCount > 0) {
              const lastTie = tiesToBreak[tieCount - 1];
              if (lastTie.followingNode !== followingNode) {
                breakTies(tiesToBreak, text2, options2);
              }
            }
            tiesToBreak.push(context);
          } else if (precedingNode) {
            addTrailingComment(precedingNode, comment);
          } else if (followingNode) {
            addLeadingComment(followingNode, comment);
          } else if (enclosingNode) {
            addDanglingComment(enclosingNode, comment);
          } else {
            addDanglingComment(ast2, comment);
          }
        }
      }
      breakTies(tiesToBreak, text, options);
      if (!avoidAstMutation) {
        for (const comment of comments) {
          delete comment.precedingNode;
          delete comment.enclosingNode;
          delete comment.followingNode;
        }
      }
    }
    var isAllEmptyAndNoLineBreak = (text) => !/[\S\n\u2028\u2029]/.test(text);
    function isOwnLineComment(text, options, decoratedComments, commentIndex) {
      const {
        comment,
        precedingNode
      } = decoratedComments[commentIndex];
      const {
        locStart,
        locEnd
      } = options;
      let start = locStart(comment);
      if (precedingNode) {
        for (let index = commentIndex - 1; index >= 0; index--) {
          const {
            comment: comment2,
            precedingNode: currentCommentPrecedingNode
          } = decoratedComments[index];
          if (currentCommentPrecedingNode !== precedingNode || !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment2), start))) {
            break;
          }
          start = locStart(comment2);
        }
      }
      return hasNewline(text, start, {
        backwards: true
      });
    }
    function isEndOfLineComment(text, options, decoratedComments, commentIndex) {
      const {
        comment,
        followingNode
      } = decoratedComments[commentIndex];
      const {
        locStart,
        locEnd
      } = options;
      let end = locEnd(comment);
      if (followingNode) {
        for (let index = commentIndex + 1; index < decoratedComments.length; index++) {
          const {
            comment: comment2,
            followingNode: currentCommentFollowingNode
          } = decoratedComments[index];
          if (currentCommentFollowingNode !== followingNode || !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment2)))) {
            break;
          }
          end = locEnd(comment2);
        }
      }
      return hasNewline(text, end);
    }
    function breakTies(tiesToBreak, text, options) {
      const tieCount = tiesToBreak.length;
      if (tieCount === 0) {
        return;
      }
      const {
        precedingNode,
        followingNode,
        enclosingNode
      } = tiesToBreak[0];
      const gapRegExp = options.printer.getGapRegex && options.printer.getGapRegex(enclosingNode) || /^[\s(]*$/;
      let gapEndPos = options.locStart(followingNode);
      let indexOfFirstLeadingComment;
      for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
        const {
          comment,
          precedingNode: currentCommentPrecedingNode,
          followingNode: currentCommentFollowingNode
        } = tiesToBreak[indexOfFirstLeadingComment - 1];
        assert.strictEqual(currentCommentPrecedingNode, precedingNode);
        assert.strictEqual(currentCommentFollowingNode, followingNode);
        const gap = text.slice(options.locEnd(comment), gapEndPos);
        if (gapRegExp.test(gap)) {
          gapEndPos = options.locStart(comment);
        } else {
          break;
        }
      }
      for (const [i, {
        comment
      }] of tiesToBreak.entries()) {
        if (i < indexOfFirstLeadingComment) {
          addTrailingComment(precedingNode, comment);
        } else {
          addLeadingComment(followingNode, comment);
        }
      }
      for (const node of [precedingNode, followingNode]) {
        if (node.comments && node.comments.length > 1) {
          node.comments.sort((a, b) => options.locStart(a) - options.locStart(b));
        }
      }
      tiesToBreak.length = 0;
    }
    function printComment(path, options) {
      const comment = path.getValue();
      comment.printed = true;
      return options.printer.printComment(path, options);
    }
    function findExpressionIndexForComment(quasis, comment, options) {
      const startPos = options.locStart(comment) - 1;
      for (let i = 1; i < quasis.length; ++i) {
        if (startPos < options.locStart(quasis[i])) {
          return i - 1;
        }
      }
      return 0;
    }
    function printLeadingComment(path, options) {
      const comment = path.getValue();
      const parts = [printComment(path, options)];
      const {
        printer,
        originalText,
        locStart,
        locEnd
      } = options;
      const isBlock = printer.isBlockComment && printer.isBlockComment(comment);
      if (isBlock) {
        const lineBreak = hasNewline(originalText, locEnd(comment)) ? hasNewline(originalText, locStart(comment), {
          backwards: true
        }) ? hardline : line : " ";
        parts.push(lineBreak);
      } else {
        parts.push(hardline);
      }
      const index = skipNewline(originalText, skipSpaces(originalText, locEnd(comment)));
      if (index !== false && hasNewline(originalText, index)) {
        parts.push(hardline);
      }
      return parts;
    }
    function printTrailingComment(path, options) {
      const comment = path.getValue();
      const printed = printComment(path, options);
      const {
        printer,
        originalText,
        locStart
      } = options;
      const isBlock = printer.isBlockComment && printer.isBlockComment(comment);
      if (hasNewline(originalText, locStart(comment), {
        backwards: true
      })) {
        const isLineBeforeEmpty = isPreviousLineEmpty(originalText, comment, locStart);
        return lineSuffix([hardline, isLineBeforeEmpty ? hardline : "", printed]);
      }
      let parts = [" ", printed];
      if (!isBlock) {
        parts = [lineSuffix(parts), breakParent];
      }
      return parts;
    }
    function printDanglingComments(path, options, sameIndent, filter) {
      const parts = [];
      const node = path.getValue();
      if (!node || !node.comments) {
        return "";
      }
      path.each(() => {
        const comment = path.getValue();
        if (!comment.leading && !comment.trailing && (!filter || filter(comment))) {
          parts.push(printComment(path, options));
        }
      }, "comments");
      if (parts.length === 0) {
        return "";
      }
      if (sameIndent) {
        return join(hardline, parts);
      }
      return indent([hardline, join(hardline, parts)]);
    }
    function printCommentsSeparately(path, options, ignored) {
      const value = path.getValue();
      if (!value) {
        return {};
      }
      let comments = value.comments || [];
      if (ignored) {
        comments = comments.filter((comment) => !ignored.has(comment));
      }
      const isCursorNode = value === options.cursorNode;
      if (comments.length === 0) {
        const maybeCursor = isCursorNode ? cursor : "";
        return {
          leading: maybeCursor,
          trailing: maybeCursor
        };
      }
      const leadingParts = [];
      const trailingParts = [];
      path.each(() => {
        const comment = path.getValue();
        if (ignored && ignored.has(comment)) {
          return;
        }
        const {
          leading,
          trailing
        } = comment;
        if (leading) {
          leadingParts.push(printLeadingComment(path, options));
        } else if (trailing) {
          trailingParts.push(printTrailingComment(path, options));
        }
      }, "comments");
      if (isCursorNode) {
        leadingParts.unshift(cursor);
        trailingParts.push(cursor);
      }
      return {
        leading: leadingParts,
        trailing: trailingParts
      };
    }
    function printComments(path, doc2, options, ignored) {
      const {
        leading,
        trailing
      } = printCommentsSeparately(path, options, ignored);
      if (!leading && !trailing) {
        return doc2;
      }
      return [leading, doc2, trailing];
    }
    function ensureAllCommentsPrinted(astComments) {
      if (!astComments) {
        return;
      }
      for (const comment of astComments) {
        if (!comment.printed) {
          throw new Error('Comment "' + comment.value.trim() + '" was not printed. Please report this error!');
        }
        delete comment.printed;
      }
    }
    module2.exports = {
      attach,
      printComments,
      printCommentsSeparately,
      printDanglingComments,
      getSortedChildNodes,
      ensureAllCommentsPrinted
    };
  }
});
var require_ast_path = __commonJS2({
  "src/common/ast-path.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    function getNodeHelper(path, count) {
      const stackIndex = getNodeStackIndexHelper(path.stack, count);
      return stackIndex === -1 ? null : path.stack[stackIndex];
    }
    function getNodeStackIndexHelper(stack, count) {
      for (let i = stack.length - 1; i >= 0; i -= 2) {
        const value = stack[i];
        if (value && !Array.isArray(value) && --count < 0) {
          return i;
        }
      }
      return -1;
    }
    var AstPath = class {
      constructor(value) {
        this.stack = [value];
      }
      getName() {
        const {
          stack
        } = this;
        const {
          length
        } = stack;
        if (length > 1) {
          return stack[length - 2];
        }
        return null;
      }
      getValue() {
        return getLast(this.stack);
      }
      getNode(count = 0) {
        return getNodeHelper(this, count);
      }
      getParentNode(count = 0) {
        return getNodeHelper(this, count + 1);
      }
      call(callback, ...names) {
        const {
          stack
        } = this;
        const {
          length
        } = stack;
        let value = getLast(stack);
        for (const name of names) {
          value = value[name];
          stack.push(name, value);
        }
        const result = callback(this);
        stack.length = length;
        return result;
      }
      callParent(callback, count = 0) {
        const stackIndex = getNodeStackIndexHelper(this.stack, count + 1);
        const parentValues = this.stack.splice(stackIndex + 1);
        const result = callback(this);
        this.stack.push(...parentValues);
        return result;
      }
      each(callback, ...names) {
        const {
          stack
        } = this;
        const {
          length
        } = stack;
        let value = getLast(stack);
        for (const name of names) {
          value = value[name];
          stack.push(name, value);
        }
        for (let i = 0; i < value.length; ++i) {
          stack.push(i, value[i]);
          callback(this, i, value);
          stack.length -= 2;
        }
        stack.length = length;
      }
      map(callback, ...names) {
        const result = [];
        this.each((path, index, value) => {
          result[index] = callback(path, index, value);
        }, ...names);
        return result;
      }
      try(callback) {
        const {
          stack
        } = this;
        const stackBackup = [...stack];
        try {
          return callback();
        } finally {
          stack.length = 0;
          stack.push(...stackBackup);
        }
      }
      match(...predicates) {
        let stackPointer = this.stack.length - 1;
        let name = null;
        let node = this.stack[stackPointer--];
        for (const predicate of predicates) {
          if (node === void 0) {
            return false;
          }
          let number = null;
          if (typeof name === "number") {
            number = name;
            name = this.stack[stackPointer--];
            node = this.stack[stackPointer--];
          }
          if (predicate && !predicate(node, name, number)) {
            return false;
          }
          name = this.stack[stackPointer--];
          node = this.stack[stackPointer--];
        }
        return true;
      }
      findAncestor(predicate) {
        let stackPointer = this.stack.length - 1;
        let name = null;
        let node = this.stack[stackPointer--];
        while (node) {
          let number = null;
          if (typeof name === "number") {
            number = name;
            name = this.stack[stackPointer--];
            node = this.stack[stackPointer--];
          }
          if (name !== null && predicate(node, name, number)) {
            return node;
          }
          name = this.stack[stackPointer--];
          node = this.stack[stackPointer--];
        }
      }
    };
    module2.exports = AstPath;
  }
});
var require_multiparser = __commonJS2({
  "src/main/multiparser.js"(exports2, module2) {
    "use strict";
    var {
      utils: {
        stripTrailingHardline
      }
    } = require("./doc.js");
    var {
      normalize
    } = require_options();
    var comments = require_comments();
    function printSubtree(path, print, options, printAstToDoc) {
      if (options.printer.embed && options.embeddedLanguageFormatting === "auto") {
        return options.printer.embed(path, print, (text, partialNextOptions, textToDocOptions) => textToDoc(text, partialNextOptions, options, printAstToDoc, textToDocOptions), options);
      }
    }
    function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc, {
      stripTrailingHardline: shouldStripTrailingHardline = false
    } = {}) {
      const nextOptions = normalize(Object.assign(Object.assign(Object.assign({}, parentOptions), partialNextOptions), {}, {
        parentParser: parentOptions.parser,
        originalText: text
      }), {
        passThrough: true
      });
      const result = require_parser().parse(text, nextOptions);
      const {
        ast
      } = result;
      text = result.text;
      const astComments = ast.comments;
      delete ast.comments;
      comments.attach(astComments, ast, text, nextOptions);
      nextOptions[Symbol.for("comments")] = astComments || [];
      nextOptions[Symbol.for("tokens")] = ast.tokens || [];
      const doc2 = printAstToDoc(ast, nextOptions);
      comments.ensureAllCommentsPrinted(astComments);
      if (shouldStripTrailingHardline) {
        if (typeof doc2 === "string") {
          return doc2.replace(/(?:\r?\n)*$/, "");
        }
        return stripTrailingHardline(doc2);
      }
      return doc2;
    }
    module2.exports = {
      printSubtree
    };
  }
});
var require_ast_to_doc = __commonJS2({
  "src/main/ast-to-doc.js"(exports2, module2) {
    "use strict";
    var AstPath = require_ast_path();
    var {
      builders: {
        hardline,
        addAlignmentToDoc
      },
      utils: {
        propagateBreaks
      }
    } = require("./doc.js");
    var {
      printComments
    } = require_comments();
    var multiparser = require_multiparser();
    function printAstToDoc(ast, options, alignmentSize = 0) {
      const {
        printer
      } = options;
      if (printer.preprocess) {
        ast = printer.preprocess(ast, options);
      }
      const cache = /* @__PURE__ */ new Map();
      const path = new AstPath(ast);
      let doc2 = mainPrint();
      if (alignmentSize > 0) {
        doc2 = addAlignmentToDoc([hardline, doc2], alignmentSize, options.tabWidth);
      }
      propagateBreaks(doc2);
      return doc2;
      function mainPrint(selector, args) {
        if (selector === void 0 || selector === path) {
          return mainPrintInternal(args);
        }
        if (Array.isArray(selector)) {
          return path.call(() => mainPrintInternal(args), ...selector);
        }
        return path.call(() => mainPrintInternal(args), selector);
      }
      function mainPrintInternal(args) {
        const value = path.getValue();
        const shouldCache = value && typeof value === "object" && args === void 0;
        if (shouldCache && cache.has(value)) {
          return cache.get(value);
        }
        const doc3 = callPluginPrintFunction(path, options, mainPrint, args);
        if (shouldCache) {
          cache.set(value, doc3);
        }
        return doc3;
      }
    }
    function printPrettierIgnoredNode(node, options) {
      const {
        originalText,
        [Symbol.for("comments")]: comments,
        locStart,
        locEnd
      } = options;
      const start = locStart(node);
      const end = locEnd(node);
      const printedComments = /* @__PURE__ */ new Set();
      for (const comment of comments) {
        if (locStart(comment) >= start && locEnd(comment) <= end) {
          comment.printed = true;
          printedComments.add(comment);
        }
      }
      return {
        doc: originalText.slice(start, end),
        printedComments
      };
    }
    function callPluginPrintFunction(path, options, printPath, args) {
      const node = path.getValue();
      const {
        printer
      } = options;
      let doc2;
      let printedComments;
      if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {
        ({
          doc: doc2,
          printedComments
        } = printPrettierIgnoredNode(node, options));
      } else {
        if (node) {
          try {
            doc2 = multiparser.printSubtree(path, printPath, options, printAstToDoc);
          } catch (error) {
            if (process.env.PRETTIER_DEBUG) {
              throw error;
            }
          }
        }
        if (!doc2) {
          doc2 = printer.print(path, options, printPath, args);
        }
      }
      if (!printer.willPrintOwnComments || !printer.willPrintOwnComments(path, options)) {
        doc2 = printComments(path, doc2, options, printedComments);
      }
      return doc2;
    }
    module2.exports = printAstToDoc;
  }
});
var require_range_util = __commonJS2({
  "src/main/range-util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var comments = require_comments();
    var isJsonParser = ({
      parser
    }) => parser === "json" || parser === "json5" || parser === "json-stringify";
    function findCommonAncestor(startNodeAndParents, endNodeAndParents) {
      const startNodeAndAncestors = [startNodeAndParents.node, ...startNodeAndParents.parentNodes];
      const endNodeAndAncestors = /* @__PURE__ */ new Set([endNodeAndParents.node, ...endNodeAndParents.parentNodes]);
      return startNodeAndAncestors.find((node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node));
    }
    function dropRootParents(parents) {
      let lastParentIndex = parents.length - 1;
      for (; ; ) {
        const parent = parents[lastParentIndex];
        if (parent && (parent.type === "Program" || parent.type === "File")) {
          lastParentIndex--;
        } else {
          break;
        }
      }
      return parents.slice(0, lastParentIndex + 1);
    }
    function findSiblingAncestors(startNodeAndParents, endNodeAndParents, {
      locStart,
      locEnd
    }) {
      let resultStartNode = startNodeAndParents.node;
      let resultEndNode = endNodeAndParents.node;
      if (resultStartNode === resultEndNode) {
        return {
          startNode: resultStartNode,
          endNode: resultEndNode
        };
      }
      const startNodeStart = locStart(startNodeAndParents.node);
      for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {
        if (locStart(endParent) >= startNodeStart) {
          resultEndNode = endParent;
        } else {
          break;
        }
      }
      const endNodeEnd = locEnd(endNodeAndParents.node);
      for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {
        if (locEnd(startParent) <= endNodeEnd) {
          resultStartNode = startParent;
        } else {
          break;
        }
        if (resultStartNode === resultEndNode) {
          break;
        }
      }
      return {
        startNode: resultStartNode,
        endNode: resultEndNode
      };
    }
    function findNodeAtOffset(node, offset, options, predicate, parentNodes = [], type) {
      const {
        locStart,
        locEnd
      } = options;
      const start = locStart(node);
      const end = locEnd(node);
      if (offset > end || offset < start || type === "rangeEnd" && offset === start || type === "rangeStart" && offset === end) {
        return;
      }
      for (const childNode of comments.getSortedChildNodes(node, options)) {
        const childResult = findNodeAtOffset(childNode, offset, options, predicate, [node, ...parentNodes], type);
        if (childResult) {
          return childResult;
        }
      }
      if (!predicate || predicate(node, parentNodes[0])) {
        return {
          node,
          parentNodes
        };
      }
    }
    function isJsSourceElement(type, parentType) {
      return parentType !== "DeclareExportDeclaration" && type !== "TypeParameterDeclaration" && (type === "Directive" || type === "TypeAlias" || type === "TSExportAssignment" || type.startsWith("Declare") || type.startsWith("TSDeclare") || type.endsWith("Statement") || type.endsWith("Declaration"));
    }
    var jsonSourceElements = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
    var graphqlSourceElements = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
    function isSourceElement(opts, node, parentNode) {
      if (!node) {
        return false;
      }
      switch (opts.parser) {
        case "flow":
        case "babel":
        case "babel-flow":
        case "babel-ts":
        case "typescript":
        case "acorn":
        case "espree":
        case "meriyah":
        case "__babel_estree":
          return isJsSourceElement(node.type, parentNode && parentNode.type);
        case "json":
        case "json5":
        case "json-stringify":
          return jsonSourceElements.has(node.type);
        case "graphql":
          return graphqlSourceElements.has(node.kind);
        case "vue":
          return node.tag !== "root";
      }
      return false;
    }
    function calculateRange(text, opts, ast) {
      let {
        rangeStart: start,
        rangeEnd: end,
        locStart,
        locEnd
      } = opts;
      assert.ok(end > start);
      const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\S/);
      const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;
      if (!isAllWhitespace) {
        start += firstNonWhitespaceCharacterIndex;
        for (; end > start; --end) {
          if (/\S/.test(text[end - 1])) {
            break;
          }
        }
      }
      const startNodeAndParents = findNodeAtOffset(ast, start, opts, (node, parentNode) => isSourceElement(opts, node, parentNode), [], "rangeStart");
      const endNodeAndParents = isAllWhitespace ? startNodeAndParents : findNodeAtOffset(ast, end, opts, (node) => isSourceElement(opts, node), [], "rangeEnd");
      if (!startNodeAndParents || !endNodeAndParents) {
        return {
          rangeStart: 0,
          rangeEnd: 0
        };
      }
      let startNode;
      let endNode;
      if (isJsonParser(opts)) {
        const commonAncestor = findCommonAncestor(startNodeAndParents, endNodeAndParents);
        startNode = commonAncestor;
        endNode = commonAncestor;
      } else {
        ({
          startNode,
          endNode
        } = findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts));
      }
      return {
        rangeStart: Math.min(locStart(startNode), locStart(endNode)),
        rangeEnd: Math.max(locEnd(startNode), locEnd(endNode))
      };
    }
    module2.exports = {
      calculateRange,
      findNodeAtOffset
    };
  }
});
var require_core = __commonJS2({
  "src/main/core.js"(exports2, module2) {
    "use strict";
    var {
      diffArrays
    } = require_array();
    var {
      printer: {
        printDocToString
      },
      debug: {
        printDocToDebug
      }
    } = require("./doc.js");
    var {
      getAlignmentSize
    } = require_util();
    var {
      guessEndOfLine,
      convertEndOfLineToChars,
      countEndOfLineChars,
      normalizeEndOfLine
    } = require_end_of_line();
    var normalizeOptions = require_options().normalize;
    var massageAST = require_massage_ast();
    var comments = require_comments();
    var parser = require_parser();
    var printAstToDoc = require_ast_to_doc();
    var rangeUtil = require_range_util();
    var BOM = "\uFEFF";
    var CURSOR = Symbol("cursor");
    function attachComments(text, ast, opts) {
      const astComments = ast.comments;
      if (astComments) {
        delete ast.comments;
        comments.attach(astComments, ast, text, opts);
      }
      opts[Symbol.for("comments")] = astComments || [];
      opts[Symbol.for("tokens")] = ast.tokens || [];
      opts.originalText = text;
      return astComments;
    }
    function coreFormat(originalText, opts, addAlignmentSize = 0) {
      if (!originalText || originalText.trim().length === 0) {
        return {
          formatted: "",
          cursorOffset: -1,
          comments: []
        };
      }
      const {
        ast,
        text
      } = parser.parse(originalText, opts);
      if (opts.cursorOffset >= 0) {
        const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);
        if (nodeResult && nodeResult.node) {
          opts.cursorNode = nodeResult.node;
        }
      }
      const astComments = attachComments(text, ast, opts);
      const doc2 = printAstToDoc(ast, opts, addAlignmentSize);
      const result = printDocToString(doc2, opts);
      comments.ensureAllCommentsPrinted(astComments);
      if (addAlignmentSize > 0) {
        const trimmed = result.formatted.trim();
        if (result.cursorNodeStart !== void 0) {
          result.cursorNodeStart -= result.formatted.indexOf(trimmed);
        }
        result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);
      }
      if (opts.cursorOffset >= 0) {
        let oldCursorNodeStart;
        let oldCursorNodeText;
        let cursorOffsetRelativeToOldCursorNode;
        let newCursorNodeStart;
        let newCursorNodeText;
        if (opts.cursorNode && result.cursorNodeText) {
          oldCursorNodeStart = opts.locStart(opts.cursorNode);
          oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));
          cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;
          newCursorNodeStart = result.cursorNodeStart;
          newCursorNodeText = result.cursorNodeText;
        } else {
          oldCursorNodeStart = 0;
          oldCursorNodeText = text;
          cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;
          newCursorNodeStart = 0;
          newCursorNodeText = result.formatted;
        }
        if (oldCursorNodeText === newCursorNodeText) {
          return {
            formatted: result.formatted,
            cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,
            comments: astComments
          };
        }
        const oldCursorNodeCharArray = [...oldCursorNodeText];
        oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);
        const newCursorNodeCharArray = [...newCursorNodeText];
        const cursorNodeDiff = diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);
        let cursorOffset = newCursorNodeStart;
        for (const entry of cursorNodeDiff) {
          if (entry.removed) {
            if (entry.value.includes(CURSOR)) {
              break;
            }
          } else {
            cursorOffset += entry.count;
          }
        }
        return {
          formatted: result.formatted,
          cursorOffset,
          comments: astComments
        };
      }
      return {
        formatted: result.formatted,
        cursorOffset: -1,
        comments: astComments
      };
    }
    function formatRange(originalText, opts) {
      const {
        ast,
        text
      } = parser.parse(originalText, opts);
      const {
        rangeStart,
        rangeEnd
      } = rangeUtil.calculateRange(text, opts, ast);
      const rangeString = text.slice(rangeStart, rangeEnd);
      const rangeStart2 = Math.min(rangeStart, text.lastIndexOf("\n", rangeStart) + 1);
      const indentString = text.slice(rangeStart2, rangeStart).match(/^\s*/)[0];
      const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);
      const rangeResult = coreFormat(rangeString, Object.assign(Object.assign({}, opts), {}, {
        rangeStart: 0,
        rangeEnd: Number.POSITIVE_INFINITY,
        cursorOffset: opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd ? opts.cursorOffset - rangeStart : -1,
        endOfLine: "lf"
      }), alignmentSize);
      const rangeTrimmed = rangeResult.formatted.trimEnd();
      let {
        cursorOffset
      } = opts;
      if (cursorOffset > rangeEnd) {
        cursorOffset += rangeTrimmed.length - rangeString.length;
      } else if (rangeResult.cursorOffset >= 0) {
        cursorOffset = rangeResult.cursorOffset + rangeStart;
      }
      let formatted = text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);
      if (opts.endOfLine !== "lf") {
        const eol = convertEndOfLineToChars(opts.endOfLine);
        if (cursorOffset >= 0 && eol === "\r\n") {
          cursorOffset += countEndOfLineChars(formatted.slice(0, cursorOffset), "\n");
        }
        formatted = formatted.replace(/\n/g, eol);
      }
      return {
        formatted,
        cursorOffset,
        comments: rangeResult.comments
      };
    }
    function ensureIndexInText(text, index, defaultValue) {
      if (typeof index !== "number" || Number.isNaN(index) || index < 0 || index > text.length) {
        return defaultValue;
      }
      return index;
    }
    function normalizeIndexes(text, options) {
      let {
        cursorOffset,
        rangeStart,
        rangeEnd
      } = options;
      cursorOffset = ensureIndexInText(text, cursorOffset, -1);
      rangeStart = ensureIndexInText(text, rangeStart, 0);
      rangeEnd = ensureIndexInText(text, rangeEnd, text.length);
      return Object.assign(Object.assign({}, options), {}, {
        cursorOffset,
        rangeStart,
        rangeEnd
      });
    }
    function normalizeInputAndOptions(text, options) {
      let {
        cursorOffset,
        rangeStart,
        rangeEnd,
        endOfLine
      } = normalizeIndexes(text, options);
      const hasBOM = text.charAt(0) === BOM;
      if (hasBOM) {
        text = text.slice(1);
        cursorOffset--;
        rangeStart--;
        rangeEnd--;
      }
      if (endOfLine === "auto") {
        endOfLine = guessEndOfLine(text);
      }
      if (text.includes("\r")) {
        const countCrlfBefore = (index) => countEndOfLineChars(text.slice(0, Math.max(index, 0)), "\r\n");
        cursorOffset -= countCrlfBefore(cursorOffset);
        rangeStart -= countCrlfBefore(rangeStart);
        rangeEnd -= countCrlfBefore(rangeEnd);
        text = normalizeEndOfLine(text);
      }
      return {
        hasBOM,
        text,
        options: normalizeIndexes(text, Object.assign(Object.assign({}, options), {}, {
          cursorOffset,
          rangeStart,
          rangeEnd,
          endOfLine
        }))
      };
    }
    function hasPragma(text, options) {
      const selectedParser = parser.resolveParser(options);
      return !selectedParser.hasPragma || selectedParser.hasPragma(text);
    }
    function formatWithCursor2(originalText, originalOptions) {
      let {
        hasBOM,
        text,
        options
      } = normalizeInputAndOptions(originalText, normalizeOptions(originalOptions));
      if (options.rangeStart >= options.rangeEnd && text !== "" || options.requirePragma && !hasPragma(text, options)) {
        return {
          formatted: originalText,
          cursorOffset: originalOptions.cursorOffset,
          comments: []
        };
      }
      let result;
      if (options.rangeStart > 0 || options.rangeEnd < text.length) {
        result = formatRange(text, options);
      } else {
        if (!options.requirePragma && options.insertPragma && options.printer.insertPragma && !hasPragma(text, options)) {
          text = options.printer.insertPragma(text);
        }
        result = coreFormat(text, options);
      }
      if (hasBOM) {
        result.formatted = BOM + result.formatted;
        if (result.cursorOffset >= 0) {
          result.cursorOffset++;
        }
      }
      return result;
    }
    module2.exports = {
      formatWithCursor: formatWithCursor2,
      parse(originalText, originalOptions, massage) {
        const {
          text,
          options
        } = normalizeInputAndOptions(originalText, normalizeOptions(originalOptions));
        const parsed = parser.parse(text, options);
        if (massage) {
          parsed.ast = massageAST(parsed.ast, options);
        }
        return parsed;
      },
      formatAST(ast, options) {
        options = normalizeOptions(options);
        const doc2 = printAstToDoc(ast, options);
        return printDocToString(doc2, options);
      },
      formatDoc(doc2, options) {
        return formatWithCursor2(printDocToDebug(doc2), Object.assign(Object.assign({}, options), {}, {
          parser: "__js_expression"
        })).formatted;
      },
      printToDoc(originalText, options) {
        options = normalizeOptions(options);
        const {
          ast,
          text
        } = parser.parse(originalText, options);
        attachComments(text, ast, options);
        return printAstToDoc(ast, options);
      },
      printDocToString(doc2, options) {
        return printDocToString(doc2, normalizeOptions(options));
      }
    };
  }
});
var require_utils2 = __commonJS2({
  "node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});
var require_stringify = __commonJS2({
  "node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});
var require_is_number = __commonJS2({
  "node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});
var require_to_regex_range = __commonJS2({
  "node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = Object.assign({
        relaxZeros: true
      }, options);
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = {
        min,
        max,
        a,
        b
      };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return {
          pattern: start,
          count: [],
          digits: 0
        };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return {
        pattern,
        count: [count],
        digits
      };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let {
          string
        } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});
var require_fill_range = __commonJS2({
  "node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, Object.assign({
          wrap: false
        }, options));
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = {
        negatives: [],
        positives: []
      };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, Object.assign({
          wrap: false
        }, options));
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, {
          wrap: false,
          options
        });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, {
          transform: step
        });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = Object.assign({}, options);
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});
var require_compile = __commonJS2({
  "node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils2();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, Object.assign(Object.assign({}, options), {}, {
            wrap: false,
            toRegex: true
          }));
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});
var require_expand = __commonJS2({
  "node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils2();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});
var require_constants2 = __commonJS2({
  "node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});
var require_parse = __commonJS2({
  "node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = {
        type: "root",
        input,
        nodes: []
      };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({
        type: "bos"
      });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({
            type: "text",
            value: (options.keepEscaping ? value : "") + advance()
          });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({
            type: "text",
            value: "\\" + value
          });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({
            type: "text",
            value
          });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({
            type: "paren",
            nodes: []
          });
          stack.push(block);
          push({
            type: "text",
            value
          });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({
              type: "text",
              value
            });
            continue;
          }
          block = stack.pop();
          push({
            type: "text",
            value
          });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({
            type: "text",
            value
          });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({
            type: "open",
            value
          });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({
              type: "text",
              value
            });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({
            type,
            value
          });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, {
              type: "text",
              value: stringify(block)
            }];
          }
          push({
            type: "comma",
            value
          });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({
              type: "text",
              value
            });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({
            type: "dot",
            value
          });
          continue;
        }
        push({
          type: "text",
          value
        });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({
        type: "eos"
      });
      return ast;
    };
    module2.exports = parse;
  }
});
var require_braces = __commonJS2({
  "node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});
var require_constants3 = __commonJS2({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = Object.assign(Object.assign({}, POSIX_CHARS), {}, {
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    });
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": {
            type: "negate",
            open: "(?:(?!(?:",
            close: `))${chars.STAR})`
          },
          "?": {
            type: "qmark",
            open: "(?:",
            close: ")?"
          },
          "+": {
            type: "plus",
            open: "(?:",
            close: ")+"
          },
          "*": {
            type: "star",
            open: "(?:",
            close: ")*"
          },
          "@": {
            type: "at",
            open: "(?:",
            close: ")"
          }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});
var require_utils3 = __commonJS2({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});
var require_scan = __commonJS2({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants3();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = {
        value: "",
        depth: 0,
        isGlob: false
      };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = {
            value: "",
            depth: 0,
            isGlob: false
          };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});
var require_parse2 = __commonJS2({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var utils = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = Object.assign({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = {
        type: "bos",
        value: "",
        output: opts.prepend || ""
      };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = Object.assign(Object.assign({}, EXTGLOB_CHARS[value2]), {}, {
          conditions: 1,
          inner: ""
        });
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({
          type,
          value: value2,
          output: state.output ? "" : ONE_CHAR
        });
        push({
          type: "paren",
          extglob: true,
          value: advance(),
          output
        });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, Object.assign(Object.assign({}, options), {}, {
              fastpaths: false
            })).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({
          type: "paren",
          extglob: true,
          value,
          output
        });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({
              type: "text",
              value
            });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({
              type: "text",
              value
            });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({
            value
          });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({
            value
          });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({
              type: "text",
              value
            });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({
            type: "paren",
            value
          });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({
            type: "paren",
            value,
            output: state.parens ? ")" : "\\)"
          });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({
            type: "bracket",
            value
          });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({
              type: "text",
              value,
              output: `\\${value}`
            });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({
              type: "text",
              value,
              output: `\\${value}`
            });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({
            value
          });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({
              type: "text",
              value,
              output: value
            });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({
            type: "brace",
            value,
            output
          });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({
            type: "text",
            value
          });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({
            type: "comma",
            value,
            output
          });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({
            type: "slash",
            value,
            output: SLASH_LITERAL
          });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({
              type: "text",
              value,
              output: DOT_LITERAL
            });
            continue;
          }
          push({
            type: "dot",
            value,
            output: DOT_LITERAL
          });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({
              type: "text",
              value,
              output
            });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({
              type: "qmark",
              value,
              output: QMARK_NO_DOT
            });
            continue;
          }
          push({
            type: "qmark",
            value,
            output: QMARK
          });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({
              type: "plus",
              value,
              output: PLUS_LITERAL
            });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({
              type: "plus",
              value
            });
            continue;
          }
          push({
            type: "plus",
            value: PLUS_LITERAL
          });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({
              type: "at",
              extglob: true,
              value,
              output: ""
            });
            continue;
          }
          push({
            type: "text",
            value
          });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({
            type: "text",
            value
          });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({
              type: "star",
              value,
              output: ""
            });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({
              type: "star",
              value,
              output: ""
            });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({
              type: "slash",
              value: "/",
              output: ""
            });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({
              type: "slash",
              value: "/",
              output: ""
            });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = {
          type: "star",
          value,
          output: star
        };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({
          type: "maybe_slash",
          value: "",
          output: `${SLASH_LITERAL}?`
        });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = Object.assign({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = {
        negated: false,
        prefix: ""
      };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});
var require_picomatch = __commonJS2({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse2();
    var utils = require_utils3();
    var constants = require_constants3();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = Object.assign(Object.assign({}, options), {}, {
          ignore: null,
          onMatch: null,
          onResult: null
        });
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const {
          isMatch,
          match,
          output
        } = picomatch.test(input, regex, options, {
          glob,
          posix
        });
        const result = {
          glob,
          state,
          regex,
          posix,
          input,
          output,
          match,
          isMatch
        };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, {
      glob,
      posix
    } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return {
          isMatch: false,
          output: ""
        };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return {
        isMatch: Boolean(match),
        match,
        output
      };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, Object.assign(Object.assign({}, options), {}, {
        fastpaths: false
      }));
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = {
        negated: false,
        fastpaths: true
      };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});
var require_picomatch2 = __commonJS2({
  "node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});
var require_micromatch = __commonJS2({
  "node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils3();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), Object.assign(Object.assign({}, options), {}, {
          onResult
        }), true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, Object.assign(Object.assign({}, options), {}, {
        onResult
      })));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, Object.assign(Object.assign({}, options), {}, {
        contains: true
      }));
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), Object.assign(Object.assign({}, options), {}, {
        capture: true
      }));
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, Object.assign(Object.assign({}, options), {}, {
        expand: true
      }));
    };
    module2.exports = micromatch;
  }
});
var require_parser2 = __commonJS2({
  "node_modules/@iarna/toml/lib/parser.js"(exports2, module2) {
    "use strict";
    var ParserEND = 1114112;
    var ParserError = class extends Error {
      constructor(msg, filename, linenumber) {
        super("[ParserError] " + msg, filename, linenumber);
        this.name = "ParserError";
        this.code = "ParserError";
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ParserError);
      }
    };
    var State = class {
      constructor(parser) {
        this.parser = parser;
        this.buf = "";
        this.returned = null;
        this.result = null;
        this.resultTable = null;
        this.resultArr = null;
      }
    };
    var Parser = class {
      constructor() {
        this.pos = 0;
        this.col = 0;
        this.line = 0;
        this.obj = {};
        this.ctx = this.obj;
        this.stack = [];
        this._buf = "";
        this.char = null;
        this.ii = 0;
        this.state = new State(this.parseStart);
      }
      parse(str) {
        if (str.length === 0 || str.length == null)
          return;
        this._buf = String(str);
        this.ii = -1;
        this.char = -1;
        let getNext;
        while (getNext === false || this.nextChar()) {
          getNext = this.runOne();
        }
        this._buf = null;
      }
      nextChar() {
        if (this.char === 10) {
          ++this.line;
          this.col = -1;
        }
        ++this.ii;
        this.char = this._buf.codePointAt(this.ii);
        ++this.pos;
        ++this.col;
        return this.haveBuffer();
      }
      haveBuffer() {
        return this.ii < this._buf.length;
      }
      runOne() {
        return this.state.parser.call(this, this.state.returned);
      }
      finish() {
        this.char = ParserEND;
        let last;
        do {
          last = this.state.parser;
          this.runOne();
        } while (this.state.parser !== last);
        this.ctx = null;
        this.state = null;
        this._buf = null;
        return this.obj;
      }
      next(fn) {
        if (typeof fn !== "function")
          throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
        this.state.parser = fn;
      }
      goto(fn) {
        this.next(fn);
        return this.runOne();
      }
      call(fn, returnWith) {
        if (returnWith)
          this.next(returnWith);
        this.stack.push(this.state);
        this.state = new State(fn);
      }
      callNow(fn, returnWith) {
        this.call(fn, returnWith);
        return this.runOne();
      }
      return(value) {
        if (this.stack.length === 0)
          throw this.error(new ParserError("Stack underflow"));
        if (value === void 0)
          value = this.state.buf;
        this.state = this.stack.pop();
        this.state.returned = value;
      }
      returnNow(value) {
        this.return(value);
        return this.runOne();
      }
      consume() {
        if (this.char === ParserEND)
          throw this.error(new ParserError("Unexpected end-of-buffer"));
        this.state.buf += this._buf[this.ii];
      }
      error(err) {
        err.line = this.line;
        err.col = this.col;
        err.pos = this.pos;
        return err;
      }
      parseStart() {
        throw new ParserError("Must declare a parseStart method");
      }
    };
    Parser.END = ParserEND;
    Parser.Error = ParserError;
    module2.exports = Parser;
  }
});
var require_create_datetime = __commonJS2({
  "node_modules/@iarna/toml/lib/create-datetime.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      const date = new Date(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});
var require_format_num = __commonJS2({
  "node_modules/@iarna/toml/lib/format-num.js"(exports2, module2) {
    "use strict";
    module2.exports = (d, num) => {
      num = String(num);
      while (num.length < d)
        num = "0" + num;
      return num;
    };
  }
});
var require_create_datetime_float = __commonJS2({
  "node_modules/@iarna/toml/lib/create-datetime-float.js"(exports2, module2) {
    "use strict";
    var f = require_format_num();
    var FloatingDateTime = class extends Date {
      constructor(value) {
        super(value + "Z");
        this.isFloating = true;
      }
      toISOString() {
        const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
        const time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
        return `${date}T${time}`;
      }
    };
    module2.exports = (value) => {
      const date = new FloatingDateTime(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});
var require_create_date = __commonJS2({
  "node_modules/@iarna/toml/lib/create-date.js"(exports2, module2) {
    "use strict";
    var f = require_format_num();
    var DateTime = global.Date;
    var Date2 = class extends DateTime {
      constructor(value) {
        super(value);
        this.isDate = true;
      }
      toISOString() {
        return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
      }
    };
    module2.exports = (value) => {
      const date = new Date2(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});
var require_create_time = __commonJS2({
  "node_modules/@iarna/toml/lib/create-time.js"(exports2, module2) {
    "use strict";
    var f = require_format_num();
    var Time = class extends Date {
      constructor(value) {
        super(`0000-01-01T${value}Z`);
        this.isTime = true;
      }
      toISOString() {
        return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
      }
    };
    module2.exports = (value) => {
      const date = new Time(value);
      if (isNaN(date)) {
        throw new TypeError("Invalid Datetime");
      } else {
        return date;
      }
    };
  }
});
var require_toml_parser = __commonJS2({
  "node_modules/@iarna/toml/lib/toml-parser.js"(exports2, module2) {
    "use strict";
    module2.exports = makeParserClass(require_parser2());
    module2.exports.makeParserClass = makeParserClass;
    var TomlError = class extends Error {
      constructor(msg) {
        super(msg);
        this.name = "TomlError";
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, TomlError);
        this.fromTOML = true;
        this.wrapped = null;
      }
    };
    TomlError.wrap = (err) => {
      const terr = new TomlError(err.message);
      terr.code = err.code;
      terr.wrapped = err;
      return terr;
    };
    module2.exports.TomlError = TomlError;
    var createDateTime = require_create_datetime();
    var createDateTimeFloat = require_create_datetime_float();
    var createDate = require_create_date();
    var createTime = require_create_time();
    var CTRL_I = 9;
    var CTRL_J = 10;
    var CTRL_M = 13;
    var CTRL_CHAR_BOUNDARY = 31;
    var CHAR_SP = 32;
    var CHAR_QUOT = 34;
    var CHAR_NUM = 35;
    var CHAR_APOS = 39;
    var CHAR_PLUS = 43;
    var CHAR_COMMA = 44;
    var CHAR_HYPHEN = 45;
    var CHAR_PERIOD = 46;
    var CHAR_0 = 48;
    var CHAR_1 = 49;
    var CHAR_7 = 55;
    var CHAR_9 = 57;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_A = 65;
    var CHAR_E = 69;
    var CHAR_F = 70;
    var CHAR_T = 84;
    var CHAR_U = 85;
    var CHAR_Z = 90;
    var CHAR_LOWBAR = 95;
    var CHAR_a = 97;
    var CHAR_b = 98;
    var CHAR_e = 101;
    var CHAR_f = 102;
    var CHAR_i = 105;
    var CHAR_l = 108;
    var CHAR_n = 110;
    var CHAR_o = 111;
    var CHAR_r = 114;
    var CHAR_s = 115;
    var CHAR_t = 116;
    var CHAR_u = 117;
    var CHAR_x = 120;
    var CHAR_z = 122;
    var CHAR_LCUB = 123;
    var CHAR_RCUB = 125;
    var CHAR_LSQB = 91;
    var CHAR_BSOL = 92;
    var CHAR_RSQB = 93;
    var CHAR_DEL = 127;
    var SURROGATE_FIRST = 55296;
    var SURROGATE_LAST = 57343;
    var escapes = {
      [CHAR_b]: "\b",
      [CHAR_t]: "	",
      [CHAR_n]: "\n",
      [CHAR_f]: "\f",
      [CHAR_r]: "\r",
      [CHAR_QUOT]: '"',
      [CHAR_BSOL]: "\\"
    };
    function isDigit(cp) {
      return cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isHexit(cp) {
      return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isBit(cp) {
      return cp === CHAR_1 || cp === CHAR_0;
    }
    function isOctit(cp) {
      return cp >= CHAR_0 && cp <= CHAR_7;
    }
    function isAlphaNumQuoteHyphen(cp) {
      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    function isAlphaNumHyphen(cp) {
      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    var _type = Symbol("type");
    var _declared = Symbol("declared");
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var defineProperty = Object.defineProperty;
    var descriptor = {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    };
    function hasKey(obj, key) {
      if (hasOwnProperty.call(obj, key))
        return true;
      if (key === "__proto__")
        defineProperty(obj, "__proto__", descriptor);
      return false;
    }
    var INLINE_TABLE = Symbol("inline-table");
    function InlineTable() {
      return Object.defineProperties({}, {
        [_type]: {
          value: INLINE_TABLE
        }
      });
    }
    function isInlineTable(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === INLINE_TABLE;
    }
    var TABLE = Symbol("table");
    function Table() {
      return Object.defineProperties({}, {
        [_type]: {
          value: TABLE
        },
        [_declared]: {
          value: false,
          writable: true
        }
      });
    }
    function isTable(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === TABLE;
    }
    var _contentType = Symbol("content-type");
    var INLINE_LIST = Symbol("inline-list");
    function InlineList(type) {
      return Object.defineProperties([], {
        [_type]: {
          value: INLINE_LIST
        },
        [_contentType]: {
          value: type
        }
      });
    }
    function isInlineList(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === INLINE_LIST;
    }
    var LIST = Symbol("list");
    function List() {
      return Object.defineProperties([], {
        [_type]: {
          value: LIST
        }
      });
    }
    function isList(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === LIST;
    }
    var _custom;
    try {
      const utilInspect = require("util").inspect;
      _custom = utilInspect.custom;
    } catch (_) {
    }
    var _inspect = _custom || "inspect";
    var BoxedBigInt = class {
      constructor(value) {
        try {
          this.value = global.BigInt.asIntN(64, value);
        } catch (_) {
          this.value = null;
        }
        Object.defineProperty(this, _type, {
          value: INTEGER
        });
      }
      isNaN() {
        return this.value === null;
      }
      toString() {
        return String(this.value);
      }
      [_inspect]() {
        return `[BigInt: ${this.toString()}]}`;
      }
      valueOf() {
        return this.value;
      }
    };
    var INTEGER = Symbol("integer");
    function Integer(value) {
      let num = Number(value);
      if (Object.is(num, -0))
        num = 0;
      if (global.BigInt && !Number.isSafeInteger(num)) {
        return new BoxedBigInt(value);
      } else {
        return Object.defineProperties(new Number(num), {
          isNaN: {
            value: function() {
              return isNaN(this);
            }
          },
          [_type]: {
            value: INTEGER
          },
          [_inspect]: {
            value: () => `[Integer: ${value}]`
          }
        });
      }
    }
    function isInteger(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === INTEGER;
    }
    var FLOAT = Symbol("float");
    function Float(value) {
      return Object.defineProperties(new Number(value), {
        [_type]: {
          value: FLOAT
        },
        [_inspect]: {
          value: () => `[Float: ${value}]`
        }
      });
    }
    function isFloat(obj) {
      if (obj === null || typeof obj !== "object")
        return false;
      return obj[_type] === FLOAT;
    }
    function tomlType(value) {
      const type = typeof value;
      if (type === "object") {
        if (value === null)
          return "null";
        if (value instanceof Date)
          return "datetime";
        if (_type in value) {
          switch (value[_type]) {
            case INLINE_TABLE:
              return "inline-table";
            case INLINE_LIST:
              return "inline-list";
            case TABLE:
              return "table";
            case LIST:
              return "list";
            case FLOAT:
              return "float";
            case INTEGER:
              return "integer";
          }
        }
      }
      return type;
    }
    function makeParserClass(Parser) {
      class TOMLParser extends Parser {
        constructor() {
          super();
          this.ctx = this.obj = Table();
        }
        atEndOfWord() {
          return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
        }
        atEndOfLine() {
          return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
        }
        parseStart() {
          if (this.char === Parser.END) {
            return null;
          } else if (this.char === CHAR_LSQB) {
            return this.call(this.parseTableOrList);
          } else if (this.char === CHAR_NUM) {
            return this.call(this.parseComment);
          } else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
            return null;
          } else if (isAlphaNumQuoteHyphen(this.char)) {
            return this.callNow(this.parseAssignStatement);
          } else {
            throw this.error(new TomlError(`Unknown character "${this.char}"`));
          }
        }
        parseWhitespaceToEOL() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
            return null;
          } else if (this.char === CHAR_NUM) {
            return this.goto(this.parseComment);
          } else if (this.char === Parser.END || this.char === CTRL_J) {
            return this.return();
          } else {
            throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
          }
        }
        parseAssignStatement() {
          return this.callNow(this.parseAssign, this.recordAssignStatement);
        }
        recordAssignStatement(kv) {
          let target = this.ctx;
          let finalKey = kv.key.pop();
          for (let kw of kv.key) {
            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            }
            target = target[kw] = target[kw] || Table();
          }
          if (hasKey(target, finalKey)) {
            throw this.error(new TomlError("Can't redefine existing key"));
          }
          if (isInteger(kv.value) || isFloat(kv.value)) {
            target[finalKey] = kv.value.valueOf();
          } else {
            target[finalKey] = kv.value;
          }
          return this.goto(this.parseWhitespaceToEOL);
        }
        parseAssign() {
          return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        recordAssignKeyword(key) {
          if (this.state.resultTable) {
            this.state.resultTable.push(key);
          } else {
            this.state.resultTable = [key];
          }
          return this.goto(this.parseAssignKeywordPreDot);
        }
        parseAssignKeywordPreDot() {
          if (this.char === CHAR_PERIOD) {
            return this.next(this.parseAssignKeywordPostDot);
          } else if (this.char !== CHAR_SP && this.char !== CTRL_I) {
            return this.goto(this.parseAssignEqual);
          }
        }
        parseAssignKeywordPostDot() {
          if (this.char !== CHAR_SP && this.char !== CTRL_I) {
            return this.callNow(this.parseKeyword, this.recordAssignKeyword);
          }
        }
        parseAssignEqual() {
          if (this.char === CHAR_EQUALS) {
            return this.next(this.parseAssignPreValue);
          } else {
            throw this.error(new TomlError('Invalid character, expected "="'));
          }
        }
        parseAssignPreValue() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else {
            return this.callNow(this.parseValue, this.recordAssignValue);
          }
        }
        recordAssignValue(value) {
          return this.returnNow({
            key: this.state.resultTable,
            value
          });
        }
        parseComment() {
          do {
            if (this.char === Parser.END || this.char === CTRL_J) {
              return this.return();
            }
          } while (this.nextChar());
        }
        parseTableOrList() {
          if (this.char === CHAR_LSQB) {
            this.next(this.parseList);
          } else {
            return this.goto(this.parseTable);
          }
        }
        parseTable() {
          this.ctx = this.obj;
          return this.goto(this.parseTableNext);
        }
        parseTableNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else {
            return this.callNow(this.parseKeyword, this.parseTableMore);
          }
        }
        parseTableMore(keyword) {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === CHAR_RSQB) {
            if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            } else {
              this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
              this.ctx[_declared] = true;
            }
            return this.next(this.parseWhitespaceToEOL);
          } else if (this.char === CHAR_PERIOD) {
            if (!hasKey(this.ctx, keyword)) {
              this.ctx = this.ctx[keyword] = Table();
            } else if (isTable(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword];
            } else if (isList(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            } else {
              throw this.error(new TomlError("Can't redefine existing key"));
            }
            return this.next(this.parseTableNext);
          } else {
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
          }
        }
        parseList() {
          this.ctx = this.obj;
          return this.goto(this.parseListNext);
        }
        parseListNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else {
            return this.callNow(this.parseKeyword, this.parseListMore);
          }
        }
        parseListMore(keyword) {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === CHAR_RSQB) {
            if (!hasKey(this.ctx, keyword)) {
              this.ctx[keyword] = List();
            }
            if (isInlineList(this.ctx[keyword])) {
              throw this.error(new TomlError("Can't extend an inline array"));
            } else if (isList(this.ctx[keyword])) {
              const next = Table();
              this.ctx[keyword].push(next);
              this.ctx = next;
            } else {
              throw this.error(new TomlError("Can't redefine an existing key"));
            }
            return this.next(this.parseListEnd);
          } else if (this.char === CHAR_PERIOD) {
            if (!hasKey(this.ctx, keyword)) {
              this.ctx = this.ctx[keyword] = Table();
            } else if (isInlineList(this.ctx[keyword])) {
              throw this.error(new TomlError("Can't extend an inline array"));
            } else if (isInlineTable(this.ctx[keyword])) {
              throw this.error(new TomlError("Can't extend an inline table"));
            } else if (isList(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            } else if (isTable(this.ctx[keyword])) {
              this.ctx = this.ctx[keyword];
            } else {
              throw this.error(new TomlError("Can't redefine an existing key"));
            }
            return this.next(this.parseListNext);
          } else {
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
          }
        }
        parseListEnd(keyword) {
          if (this.char === CHAR_RSQB) {
            return this.next(this.parseWhitespaceToEOL);
          } else {
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
          }
        }
        parseValue() {
          if (this.char === Parser.END) {
            throw this.error(new TomlError("Key without value"));
          } else if (this.char === CHAR_QUOT) {
            return this.next(this.parseDoubleString);
          }
          if (this.char === CHAR_APOS) {
            return this.next(this.parseSingleString);
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            return this.goto(this.parseNumberSign);
          } else if (this.char === CHAR_i) {
            return this.next(this.parseInf);
          } else if (this.char === CHAR_n) {
            return this.next(this.parseNan);
          } else if (isDigit(this.char)) {
            return this.goto(this.parseNumberOrDateTime);
          } else if (this.char === CHAR_t || this.char === CHAR_f) {
            return this.goto(this.parseBoolean);
          } else if (this.char === CHAR_LSQB) {
            return this.call(this.parseInlineList, this.recordValue);
          } else if (this.char === CHAR_LCUB) {
            return this.call(this.parseInlineTable, this.recordValue);
          } else {
            throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
          }
        }
        recordValue(value) {
          return this.returnNow(value);
        }
        parseInf() {
          if (this.char === CHAR_n) {
            return this.next(this.parseInf2);
          } else {
            throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
          }
        }
        parseInf2() {
          if (this.char === CHAR_f) {
            if (this.state.buf === "-") {
              return this.return(-Infinity);
            } else {
              return this.return(Infinity);
            }
          } else {
            throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
          }
        }
        parseNan() {
          if (this.char === CHAR_a) {
            return this.next(this.parseNan2);
          } else {
            throw this.error(new TomlError('Unexpected character, expected "nan"'));
          }
        }
        parseNan2() {
          if (this.char === CHAR_n) {
            return this.return(NaN);
          } else {
            throw this.error(new TomlError('Unexpected character, expected "nan"'));
          }
        }
        parseKeyword() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseBasicString);
          } else if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralString);
          } else {
            return this.goto(this.parseBareKey);
          }
        }
        parseBareKey() {
          do {
            if (this.char === Parser.END) {
              throw this.error(new TomlError("Key ended without value"));
            } else if (isAlphaNumHyphen(this.char)) {
              this.consume();
            } else if (this.state.buf.length === 0) {
              throw this.error(new TomlError("Empty bare keys are not allowed"));
            } else {
              return this.returnNow();
            }
          } while (this.nextChar());
        }
        parseSingleString() {
          if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralMultiStringMaybe);
          } else {
            return this.goto(this.parseLiteralString);
          }
        }
        parseLiteralString() {
          do {
            if (this.char === CHAR_APOS) {
              return this.return();
            } else if (this.atEndOfLine()) {
              throw this.error(new TomlError("Unterminated string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        parseLiteralMultiStringMaybe() {
          if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralMultiString);
          } else {
            return this.returnNow();
          }
        }
        parseLiteralMultiString() {
          if (this.char === CTRL_M) {
            return null;
          } else if (this.char === CTRL_J) {
            return this.next(this.parseLiteralMultiStringContent);
          } else {
            return this.goto(this.parseLiteralMultiStringContent);
          }
        }
        parseLiteralMultiStringContent() {
          do {
            if (this.char === CHAR_APOS) {
              return this.next(this.parseLiteralMultiEnd);
            } else if (this.char === Parser.END) {
              throw this.error(new TomlError("Unterminated multi-line string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        parseLiteralMultiEnd() {
          if (this.char === CHAR_APOS) {
            return this.next(this.parseLiteralMultiEnd2);
          } else {
            this.state.buf += "'";
            return this.goto(this.parseLiteralMultiStringContent);
          }
        }
        parseLiteralMultiEnd2() {
          if (this.char === CHAR_APOS) {
            return this.return();
          } else {
            this.state.buf += "''";
            return this.goto(this.parseLiteralMultiStringContent);
          }
        }
        parseDoubleString() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseMultiStringMaybe);
          } else {
            return this.goto(this.parseBasicString);
          }
        }
        parseBasicString() {
          do {
            if (this.char === CHAR_BSOL) {
              return this.call(this.parseEscape, this.recordEscapeReplacement);
            } else if (this.char === CHAR_QUOT) {
              return this.return();
            } else if (this.atEndOfLine()) {
              throw this.error(new TomlError("Unterminated string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        recordEscapeReplacement(replacement) {
          this.state.buf += replacement;
          return this.goto(this.parseBasicString);
        }
        parseMultiStringMaybe() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseMultiString);
          } else {
            return this.returnNow();
          }
        }
        parseMultiString() {
          if (this.char === CTRL_M) {
            return null;
          } else if (this.char === CTRL_J) {
            return this.next(this.parseMultiStringContent);
          } else {
            return this.goto(this.parseMultiStringContent);
          }
        }
        parseMultiStringContent() {
          do {
            if (this.char === CHAR_BSOL) {
              return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
            } else if (this.char === CHAR_QUOT) {
              return this.next(this.parseMultiEnd);
            } else if (this.char === Parser.END) {
              throw this.error(new TomlError("Unterminated multi-line string"));
            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
              throw this.errorControlCharInString();
            } else {
              this.consume();
            }
          } while (this.nextChar());
        }
        errorControlCharInString() {
          let displayCode = "\\u00";
          if (this.char < 16) {
            displayCode += "0";
          }
          displayCode += this.char.toString(16);
          return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
        }
        recordMultiEscapeReplacement(replacement) {
          this.state.buf += replacement;
          return this.goto(this.parseMultiStringContent);
        }
        parseMultiEnd() {
          if (this.char === CHAR_QUOT) {
            return this.next(this.parseMultiEnd2);
          } else {
            this.state.buf += '"';
            return this.goto(this.parseMultiStringContent);
          }
        }
        parseMultiEnd2() {
          if (this.char === CHAR_QUOT) {
            return this.return();
          } else {
            this.state.buf += '""';
            return this.goto(this.parseMultiStringContent);
          }
        }
        parseMultiEscape() {
          if (this.char === CTRL_M || this.char === CTRL_J) {
            return this.next(this.parseMultiTrim);
          } else if (this.char === CHAR_SP || this.char === CTRL_I) {
            return this.next(this.parsePreMultiTrim);
          } else {
            return this.goto(this.parseEscape);
          }
        }
        parsePreMultiTrim() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === CTRL_M || this.char === CTRL_J) {
            return this.next(this.parseMultiTrim);
          } else {
            throw this.error(new TomlError("Can't escape whitespace"));
          }
        }
        parseMultiTrim() {
          if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
            return null;
          } else {
            return this.returnNow();
          }
        }
        parseEscape() {
          if (this.char in escapes) {
            return this.return(escapes[this.char]);
          } else if (this.char === CHAR_u) {
            return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
          } else if (this.char === CHAR_U) {
            return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
          } else {
            throw this.error(new TomlError("Unknown escape character: " + this.char));
          }
        }
        parseUnicodeReturn(char) {
          try {
            const codePoint = parseInt(char, 16);
            if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {
              throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
            }
            return this.returnNow(String.fromCodePoint(codePoint));
          } catch (err) {
            throw this.error(TomlError.wrap(err));
          }
        }
        parseSmallUnicode() {
          if (!isHexit(this.char)) {
            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
          } else {
            this.consume();
            if (this.state.buf.length >= 4)
              return this.return();
          }
        }
        parseLargeUnicode() {
          if (!isHexit(this.char)) {
            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
          } else {
            this.consume();
            if (this.state.buf.length >= 8)
              return this.return();
          }
        }
        parseNumberSign() {
          this.consume();
          return this.next(this.parseMaybeSignedInfOrNan);
        }
        parseMaybeSignedInfOrNan() {
          if (this.char === CHAR_i) {
            return this.next(this.parseInf);
          } else if (this.char === CHAR_n) {
            return this.next(this.parseNan);
          } else {
            return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
          }
        }
        parseNumberIntegerStart() {
          if (this.char === CHAR_0) {
            this.consume();
            return this.next(this.parseNumberIntegerExponentOrDecimal);
          } else {
            return this.goto(this.parseNumberInteger);
          }
        }
        parseNumberIntegerExponentOrDecimal() {
          if (this.char === CHAR_PERIOD) {
            this.consume();
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else {
            return this.returnNow(Integer(this.state.buf));
          }
        }
        parseNumberInteger() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder);
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else if (this.char === CHAR_PERIOD) {
            this.consume();
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseNoUnder() {
          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {
            throw this.error(new TomlError("Unexpected character, expected digit"));
          } else if (this.atEndOfWord()) {
            throw this.error(new TomlError("Incomplete number"));
          }
          return this.returnNow();
        }
        parseNoUnderHexOctBinLiteral() {
          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) {
            throw this.error(new TomlError("Unexpected character, expected digit"));
          } else if (this.atEndOfWord()) {
            throw this.error(new TomlError("Incomplete number"));
          }
          return this.returnNow();
        }
        parseNumberFloat() {
          if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else if (isDigit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else {
            return this.returnNow(Float(this.state.buf));
          }
        }
        parseNumberExponentSign() {
          if (isDigit(this.char)) {
            return this.goto(this.parseNumberExponent);
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            this.consume();
            this.call(this.parseNoUnder, this.parseNumberExponent);
          } else {
            throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
          }
        }
        parseNumberExponent() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder);
          } else {
            return this.returnNow(Float(this.state.buf));
          }
        }
        parseNumberOrDateTime() {
          if (this.char === CHAR_0) {
            this.consume();
            return this.next(this.parseNumberBaseOrDateTime);
          } else {
            return this.goto(this.parseNumberOrDateTimeOnly);
          }
        }
        parseNumberOrDateTimeOnly() {
          if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnder, this.parseNumberInteger);
          } else if (isDigit(this.char)) {
            this.consume();
            if (this.state.buf.length > 4)
              this.next(this.parseNumberInteger);
          } else if (this.char === CHAR_E || this.char === CHAR_e) {
            this.consume();
            return this.next(this.parseNumberExponentSign);
          } else if (this.char === CHAR_PERIOD) {
            this.consume();
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          } else if (this.char === CHAR_HYPHEN) {
            return this.goto(this.parseDateTime);
          } else if (this.char === CHAR_COLON) {
            return this.goto(this.parseOnlyTimeHour);
          } else {
            return this.returnNow(Integer(this.state.buf));
          }
        }
        parseDateTimeOnly() {
          if (this.state.buf.length < 4) {
            if (isDigit(this.char)) {
              return this.consume();
            } else if (this.char === CHAR_COLON) {
              return this.goto(this.parseOnlyTimeHour);
            } else {
              throw this.error(new TomlError("Expected digit while parsing year part of a date"));
            }
          } else {
            if (this.char === CHAR_HYPHEN) {
              return this.goto(this.parseDateTime);
            } else {
              throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
            }
          }
        }
        parseNumberBaseOrDateTime() {
          if (this.char === CHAR_b) {
            this.consume();
            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);
          } else if (this.char === CHAR_o) {
            this.consume();
            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);
          } else if (this.char === CHAR_x) {
            this.consume();
            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);
          } else if (this.char === CHAR_PERIOD) {
            return this.goto(this.parseNumberInteger);
          } else if (isDigit(this.char)) {
            return this.goto(this.parseDateTimeOnly);
          } else {
            return this.returnNow(Integer(this.state.buf));
          }
        }
        parseIntegerHex() {
          if (isHexit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnderHexOctBinLiteral);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseIntegerOct() {
          if (isOctit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnderHexOctBinLiteral);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseIntegerBin() {
          if (isBit(this.char)) {
            this.consume();
          } else if (this.char === CHAR_LOWBAR) {
            return this.call(this.parseNoUnderHexOctBinLiteral);
          } else {
            const result = Integer(this.state.buf);
            if (result.isNaN()) {
              throw this.error(new TomlError("Invalid number"));
            } else {
              return this.returnNow(result);
            }
          }
        }
        parseDateTime() {
          if (this.state.buf.length < 4) {
            throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
          }
          this.state.result = this.state.buf;
          this.state.buf = "";
          return this.next(this.parseDateMonth);
        }
        parseDateMonth() {
          if (this.char === CHAR_HYPHEN) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
            }
            this.state.result += "-" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseDateDay);
          } else if (isDigit(this.char)) {
            this.consume();
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseDateDay() {
          if (this.char === CHAR_T || this.char === CHAR_SP) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
            }
            this.state.result += "-" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseStartTimeHour);
          } else if (this.atEndOfWord()) {
            return this.returnNow(createDate(this.state.result + "-" + this.state.buf));
          } else if (isDigit(this.char)) {
            this.consume();
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseStartTimeHour() {
          if (this.atEndOfWord()) {
            return this.returnNow(createDate(this.state.result));
          } else {
            return this.goto(this.parseTimeHour);
          }
        }
        parseTimeHour() {
          if (this.char === CHAR_COLON) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
            }
            this.state.result += "T" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseTimeMin);
          } else if (isDigit(this.char)) {
            this.consume();
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseTimeMin() {
          if (this.state.buf.length < 2 && isDigit(this.char)) {
            this.consume();
          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
            this.state.result += ":" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseTimeSec);
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseTimeSec() {
          if (isDigit(this.char)) {
            this.consume();
            if (this.state.buf.length === 2) {
              this.state.result += ":" + this.state.buf;
              this.state.buf = "";
              return this.next(this.parseTimeZoneOrFraction);
            }
          } else {
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseOnlyTimeHour() {
          if (this.char === CHAR_COLON) {
            if (this.state.buf.length < 2) {
              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
            }
            this.state.result = this.state.buf;
            this.state.buf = "";
            return this.next(this.parseOnlyTimeMin);
          } else {
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeMin() {
          if (this.state.buf.length < 2 && isDigit(this.char)) {
            this.consume();
          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
            this.state.result += ":" + this.state.buf;
            this.state.buf = "";
            return this.next(this.parseOnlyTimeSec);
          } else {
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeSec() {
          if (isDigit(this.char)) {
            this.consume();
            if (this.state.buf.length === 2) {
              return this.next(this.parseOnlyTimeFractionMaybe);
            }
          } else {
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeFractionMaybe() {
          this.state.result += ":" + this.state.buf;
          if (this.char === CHAR_PERIOD) {
            this.state.buf = "";
            this.next(this.parseOnlyTimeFraction);
          } else {
            return this.return(createTime(this.state.result));
          }
        }
        parseOnlyTimeFraction() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.atEndOfWord()) {
            if (this.state.buf.length === 0)
              throw this.error(new TomlError("Expected digit in milliseconds"));
            return this.returnNow(createTime(this.state.result + "." + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseTimeZoneOrFraction() {
          if (this.char === CHAR_PERIOD) {
            this.consume();
            this.next(this.parseDateTimeFraction);
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            this.consume();
            this.next(this.parseTimeZoneHour);
          } else if (this.char === CHAR_Z) {
            this.consume();
            return this.return(createDateTime(this.state.result + this.state.buf));
          } else if (this.atEndOfWord()) {
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseDateTimeFraction() {
          if (isDigit(this.char)) {
            this.consume();
          } else if (this.state.buf.length === 1) {
            throw this.error(new TomlError("Expected digit in milliseconds"));
          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
            this.consume();
            this.next(this.parseTimeZoneHour);
          } else if (this.char === CHAR_Z) {
            this.consume();
            return this.return(createDateTime(this.state.result + this.state.buf));
          } else if (this.atEndOfWord()) {
            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseTimeZoneHour() {
          if (isDigit(this.char)) {
            this.consume();
            if (/\d\d$/.test(this.state.buf))
              return this.next(this.parseTimeZoneSep);
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
          }
        }
        parseTimeZoneSep() {
          if (this.char === CHAR_COLON) {
            this.consume();
            this.next(this.parseTimeZoneMin);
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
          }
        }
        parseTimeZoneMin() {
          if (isDigit(this.char)) {
            this.consume();
            if (/\d\d$/.test(this.state.buf))
              return this.return(createDateTime(this.state.result + this.state.buf));
          } else {
            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
          }
        }
        parseBoolean() {
          if (this.char === CHAR_t) {
            this.consume();
            return this.next(this.parseTrue_r);
          } else if (this.char === CHAR_f) {
            this.consume();
            return this.next(this.parseFalse_a);
          }
        }
        parseTrue_r() {
          if (this.char === CHAR_r) {
            this.consume();
            return this.next(this.parseTrue_u);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseTrue_u() {
          if (this.char === CHAR_u) {
            this.consume();
            return this.next(this.parseTrue_e);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseTrue_e() {
          if (this.char === CHAR_e) {
            return this.return(true);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_a() {
          if (this.char === CHAR_a) {
            this.consume();
            return this.next(this.parseFalse_l);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_l() {
          if (this.char === CHAR_l) {
            this.consume();
            return this.next(this.parseFalse_s);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_s() {
          if (this.char === CHAR_s) {
            this.consume();
            return this.next(this.parseFalse_e);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseFalse_e() {
          if (this.char === CHAR_e) {
            return this.return(false);
          } else {
            throw this.error(new TomlError("Invalid boolean, expected true or false"));
          }
        }
        parseInlineList() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
            return null;
          } else if (this.char === Parser.END) {
            throw this.error(new TomlError("Unterminated inline array"));
          } else if (this.char === CHAR_NUM) {
            return this.call(this.parseComment);
          } else if (this.char === CHAR_RSQB) {
            return this.return(this.state.resultArr || InlineList());
          } else {
            return this.callNow(this.parseValue, this.recordInlineListValue);
          }
        }
        recordInlineListValue(value) {
          if (this.state.resultArr) {
            const listType = this.state.resultArr[_contentType];
            const valueType = tomlType(value);
            if (listType !== valueType) {
              throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
            }
          } else {
            this.state.resultArr = InlineList(tomlType(value));
          }
          if (isFloat(value) || isInteger(value)) {
            this.state.resultArr.push(value.valueOf());
          } else {
            this.state.resultArr.push(value);
          }
          return this.goto(this.parseInlineListNext);
        }
        parseInlineListNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
            return null;
          } else if (this.char === CHAR_NUM) {
            return this.call(this.parseComment);
          } else if (this.char === CHAR_COMMA) {
            return this.next(this.parseInlineList);
          } else if (this.char === CHAR_RSQB) {
            return this.goto(this.parseInlineList);
          } else {
            throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
          }
        }
        parseInlineTable() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
            throw this.error(new TomlError("Unterminated inline array"));
          } else if (this.char === CHAR_RCUB) {
            return this.return(this.state.resultTable || InlineTable());
          } else {
            if (!this.state.resultTable)
              this.state.resultTable = InlineTable();
            return this.callNow(this.parseAssign, this.recordInlineTableValue);
          }
        }
        recordInlineTableValue(kv) {
          let target = this.state.resultTable;
          let finalKey = kv.key.pop();
          for (let kw of kv.key) {
            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
              throw this.error(new TomlError("Can't redefine existing key"));
            }
            target = target[kw] = target[kw] || Table();
          }
          if (hasKey(target, finalKey)) {
            throw this.error(new TomlError("Can't redefine existing key"));
          }
          if (isInteger(kv.value) || isFloat(kv.value)) {
            target[finalKey] = kv.value.valueOf();
          } else {
            target[finalKey] = kv.value;
          }
          return this.goto(this.parseInlineTableNext);
        }
        parseInlineTableNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I) {
            return null;
          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
            throw this.error(new TomlError("Unterminated inline array"));
          } else if (this.char === CHAR_COMMA) {
            return this.next(this.parseInlineTable);
          } else if (this.char === CHAR_RCUB) {
            return this.goto(this.parseInlineTable);
          } else {
            throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
          }
        }
      }
      return TOMLParser;
    }
  }
});
var require_parse_pretty_error = __commonJS2({
  "node_modules/@iarna/toml/parse-pretty-error.js"(exports2, module2) {
    "use strict";
    module2.exports = prettyError;
    function prettyError(err, buf) {
      if (err.pos == null || err.line == null)
        return err;
      let msg = err.message;
      msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`;
      if (buf && buf.split) {
        const lines = buf.split(/\n/);
        const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
        let linePadding = " ";
        while (linePadding.length < lineNumWidth)
          linePadding += " ";
        for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
          let lineNum = String(ii + 1);
          if (lineNum.length < lineNumWidth)
            lineNum = " " + lineNum;
          if (err.line === ii) {
            msg += lineNum + "> " + lines[ii] + "\n";
            msg += linePadding + "  ";
            for (let hh = 0; hh < err.col; ++hh) {
              msg += " ";
            }
            msg += "^\n";
          } else {
            msg += lineNum + ": " + lines[ii] + "\n";
          }
        }
      }
      err.message = msg + "\n";
      return err;
    }
  }
});
var require_parse_string = __commonJS2({
  "node_modules/@iarna/toml/parse-string.js"(exports2, module2) {
    "use strict";
    module2.exports = parseString;
    var TOMLParser = require_toml_parser();
    var prettyError = require_parse_pretty_error();
    function parseString(str) {
      if (global.Buffer && global.Buffer.isBuffer(str)) {
        str = str.toString("utf8");
      }
      const parser = new TOMLParser();
      try {
        parser.parse(str);
        return parser.finish();
      } catch (err) {
        throw prettyError(err, str);
      }
    }
  }
});
var require_load_toml = __commonJS2({
  "src/utils/load-toml.js"(exports2, module2) {
    "use strict";
    var parse = require_parse_string();
    module2.exports = function(filePath, content) {
      try {
        return parse(content);
      } catch (error) {
        error.message = `TOML Error in ${filePath}:
${error.message}`;
        throw error;
      }
    };
  }
});
var require_unicode = __commonJS2({
  "node_modules/json5/lib/unicode.js"(exports2, module2) {
    module2.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module2.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module2.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});
var require_util2 = __commonJS2({
  "node_modules/json5/lib/util.js"(exports2, module2) {
    var unicode = require_unicode();
    module2.exports = {
      isSpaceSeparator(c) {
        return typeof c === "string" && unicode.Space_Separator.test(c);
      },
      isIdStartChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
      },
      isIdContinueChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
      },
      isDigit(c) {
        return typeof c === "string" && /[0-9]/.test(c);
      },
      isHexDigit(c) {
        return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
      }
    };
  }
});
var require_parse3 = __commonJS2({
  "node_modules/json5/lib/parse.js"(exports2, module2) {
    var util = require_util2();
    var source;
    var parseState;
    var stack;
    var pos;
    var line;
    var column;
    var token;
    var key;
    var root;
    module2.exports = function parse(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({
          "": root
        }, "", reviver);
      }
      return root;
    };
    function internalize(holder, name, reviver) {
      const value = holder[name];
      if (value != null && typeof value === "object") {
        if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            const key2 = String(i);
            const replacement = internalize(value, key2, reviver);
            if (replacement === void 0) {
              delete value[key2];
            } else {
              Object.defineProperty(value, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        } else {
          for (const key2 in value) {
            const replacement = internalize(value, key2, reviver);
            if (replacement === void 0) {
              delete value[key2];
            } else {
              Object.defineProperty(value, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
      }
      return reviver.call(holder, name, value);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var sign;
    var c;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      sign = 1;
      for (; ; ) {
        c = peek();
        const token2 = lexStates[lexState]();
        if (token2) {
          return token2;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read() {
      const c2 = peek();
      if (c2 === "\n") {
        line++;
        column = 0;
      } else if (c2) {
        column += c2.length;
      } else {
        column++;
      }
      if (c2) {
        pos += c2.length;
      }
      return c2;
    }
    var lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal("ull");
            return newToken("null", null);
          case "t":
            read();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column
      };
    }
    function literal(s) {
      for (const c2 of s) {
        const p = peek();
        if (p !== c2) {
          throw invalidChar(read());
        }
        read();
      }
    }
    function escape() {
      const c2 = peek();
      switch (c2) {
        case "b":
          read();
          return "\b";
        case "f":
          read();
          return "\f";
        case "n":
          read();
          return "\n";
        case "r":
          read();
          return "\r";
        case "t":
          read();
          return "	";
        case "v":
          read();
          return "\v";
        case "0":
          read();
          if (util.isDigit(peek())) {
            throw invalidChar(read());
          }
          return "\0";
        case "x":
          read();
          return hexEscape();
        case "u":
          read();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";
        case "\r":
          read();
          if (peek() === "\n") {
            read();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      let buffer2 = "";
      let c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      let buffer2 = "";
      let count = 4;
      while (count-- > 0) {
        const c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    function push() {
      let value;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0) {
        root = value;
      } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          Object.defineProperty(parent, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      if (value !== null && typeof value === "object") {
        stack.push(value);
        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        const current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c2) {
      if (c2 === void 0) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
      }
      return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
    }
    function invalidEOF() {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
    }
    function separatorChar(c2) {
      console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(c2) {
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2]) {
        return replacements[c2];
      }
      if (c2 < " ") {
        const hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      const err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }
  }
});
var require_stringify2 = __commonJS2({
  "node_modules/json5/lib/stringify.js"(exports2, module2) {
    var util = require_util2();
    module2.exports = function stringify(value, replacer, space) {
      const stack = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
          let item;
          if (typeof v === "string") {
            item = v;
          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
            item = String(v);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", {
        "": value
      });
      function serializeProperty(key, holder) {
        let value2 = holder[key];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2, false);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if (typeof value2 === "object") {
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        const quotes = {
          "'": 0.1,
          '"': 0.2
        };
        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        let product = "";
        for (let i = 0; i < value2.length; i++) {
          const c = value2[i];
          switch (c) {
            case "'":
            case '"':
              quotes[c]++;
              product += c;
              continue;
            case "\0":
              if (util.isDigit(value2[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c]) {
            product += replacements[c];
            continue;
          }
          if (c < " ") {
            let hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value2);
        let partial = [];
        for (const key of keys) {
          const propertyString = serializeProperty(key, value2);
          if (propertyString !== void 0) {
            let member = serializeKey(key) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial.push(member);
          }
        }
        let final;
        if (partial.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key) {
        if (key.length === 0) {
          return quoteString(key, true);
        }
        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key, true);
        }
        for (let i = firstChar.length; i < key.length; i++) {
          if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
            return quoteString(key, true);
          }
        }
        return key;
      }
      function serializeArray(value2) {
        if (stack.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for (let i = 0; i < value2.length; i++) {
          const propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
    };
  }
});
var require_lib6 = __commonJS2({
  "node_modules/json5/lib/index.js"(exports2, module2) {
    var parse = require_parse3();
    var stringify = require_stringify2();
    var JSON5 = {
      parse,
      stringify
    };
    module2.exports = JSON5;
  }
});
var require_load_json5 = __commonJS2({
  "src/utils/load-json5.js"(exports2, module2) {
    "use strict";
    var {
      parse
    } = require_lib6();
    module2.exports = function(filePath, content) {
      try {
        return parse(content);
      } catch (error) {
        error.message = `JSON5 Error in ${filePath}:
${error.message}`;
        throw error;
      }
    };
  }
});
var require_partition = __commonJS2({
  "src/utils/partition.js"(exports2, module2) {
    "use strict";
    function partition(array, predicate) {
      const result = [[], []];
      for (const value of array) {
        result[predicate(value) ? 0 : 1].push(value);
      }
      return result;
    }
    module2.exports = partition;
  }
});
var require_homedir = __commonJS2({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});
var require_caller = __commonJS2({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});
var require_path_parse = __commonJS2({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});
var require_node_modules_paths = __commonJS2({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(request, start, function() {
          return getNodeModulesDirs(start, modules);
        }, opts);
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});
var require_normalize_options = __commonJS2({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});
var require_implementation = __commonJS2({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});
var require_function_bind = __commonJS2({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});
var require_src = __commonJS2({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});
var require_core2 = __commonJS2({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});
var require_is_core_module = __commonJS2({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var has = require_src();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core2();
    module2.exports = function isCore(x, nodeVersion) {
      return has(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});
var require_async = __commonJS2({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [path.join(homedir, ".node_modules"), path.join(homedir, ".node_libraries")];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
        if (err2)
          cb(err2);
        else
          init(realStart);
      });
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load([""].concat(extensions.slice()), path.resolve(dir, r), pkg);
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
      }
    };
  }
});
var require_core3 = __commonJS2({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});
var require_core4 = __commonJS2({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data = require_core3();
    var core2 = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core2[mod] = versionIncluded(data[mod]);
      }
    }
    var mod;
    module2.exports = core2;
  }
});
var require_is_core = __commonJS2({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});
var require_sync = __commonJS2({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [path.join(homedir, ".node_modules"), path.join(homedir, ".node_libraries")];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, {
          throwIfNoEntry: false
        });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, {
          throwIfNoEntry: false
        });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return {
          pkg,
          dir
        };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});
var require_resolve = __commonJS2({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async = require_async();
    async.core = require_core4();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});
var require_resolve2 = __commonJS2({
  "src/common/resolve.js"(exports2, module2) {
    "use strict";
    var {
      resolve
    } = require;
    if (resolve.length === 1 || process.env.PRETTIER_FALLBACK_RESOLVE) {
      resolve = (id, options) => {
        let basedir;
        if (options && options.paths && options.paths.length === 1) {
          basedir = options.paths[0];
        }
        return require_resolve().sync(id, {
          basedir
        });
      };
    }
    module2.exports = resolve;
  }
});
function mimicFunction(to, from, {
  ignoreNonConfigurable = false
} = {}) {
  const {
    name
  } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}
var copyProperty;
var canCopyProperty;
var changePrototype;
var wrappedToString;
var toStringDescriptor;
var toStringName;
var changeToString;
var init_mimic_fn = __esm({
  "node_modules/mimic-fn/index.js"() {
    copyProperty = (to, from, property, ignoreNonConfigurable) => {
      if (property === "length" || property === "prototype") {
        return;
      }
      if (property === "arguments" || property === "caller") {
        return;
      }
      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
      }
      Object.defineProperty(to, property, fromDescriptor);
    };
    canCopyProperty = function(toDescriptor, fromDescriptor) {
      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    changePrototype = (to, from) => {
      const fromPrototype = Object.getPrototypeOf(from);
      if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
      }
      Object.setPrototypeOf(to, fromPrototype);
    };
    wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
    toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
    toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
    changeToString = (to, from, name) => {
      const withName = name === "" ? "" : `with ${name.trim()}() `;
      const newToString = wrappedToString.bind(null, withName, from.toString());
      Object.defineProperty(newToString, "name", toStringName);
      Object.defineProperty(to, "toString", Object.assign(Object.assign({}, toStringDescriptor), {}, {
        value: newToString
      }));
    };
  }
});
var require_p_defer = __commonJS2({
  "node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    module2.exports = () => {
      const ret = {};
      ret.promise = new Promise((resolve, reject) => {
        ret.resolve = resolve;
        ret.reject = reject;
      });
      return ret;
    };
  }
});
var require_dist = __commonJS2({
  "node_modules/map-age-cleaner/dist/index.js"(exports2, module2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var p_defer_1 = __importDefault2(require_p_defer());
    function mapAgeCleaner2(map, property = "maxAge") {
      let processingKey;
      let processingTimer;
      let processingDeferred;
      const cleanup = () => __awaiter2(this, void 0, void 0, function* () {
        if (processingKey !== void 0) {
          return;
        }
        const setupTimer = (item) => __awaiter2(this, void 0, void 0, function* () {
          processingDeferred = p_defer_1.default();
          const delay = item[1][property] - Date.now();
          if (delay <= 0) {
            map.delete(item[0]);
            processingDeferred.resolve();
            return;
          }
          processingKey = item[0];
          processingTimer = setTimeout(() => {
            map.delete(item[0]);
            if (processingDeferred) {
              processingDeferred.resolve();
            }
          }, delay);
          if (typeof processingTimer.unref === "function") {
            processingTimer.unref();
          }
          return processingDeferred.promise;
        });
        try {
          for (const entry of map) {
            yield setupTimer(entry);
          }
        } catch (_a) {
        }
        processingKey = void 0;
      });
      const reset = () => {
        processingKey = void 0;
        if (processingTimer !== void 0) {
          clearTimeout(processingTimer);
          processingTimer = void 0;
        }
        if (processingDeferred !== void 0) {
          processingDeferred.reject(void 0);
          processingDeferred = void 0;
        }
      };
      const originalSet = map.set.bind(map);
      map.set = (key, value) => {
        if (map.has(key)) {
          map.delete(key);
        }
        const result = originalSet(key, value);
        if (processingKey && processingKey === key) {
          reset();
        }
        cleanup();
        return result;
      };
      cleanup();
      return map;
    }
    exports2.default = mapAgeCleaner2;
    module2.exports = mapAgeCleaner2;
    module2.exports.default = mapAgeCleaner2;
  }
});
var dist_exports = {};
__export(dist_exports, {
  default: () => mem,
  memClear: () => memClear,
  memDecorator: () => memDecorator
});
function mem(fn, {
  cacheKey,
  cache = /* @__PURE__ */ new Map(),
  maxAge
} = {}) {
  if (typeof maxAge === "number") {
    (0, import_map_age_cleaner.default)(cache);
  }
  const memoized = function(...arguments_) {
    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];
    const cacheItem = cache.get(key);
    if (cacheItem) {
      return cacheItem.data;
    }
    const result = fn.apply(this, arguments_);
    cache.set(key, {
      data: result,
      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY
    });
    return result;
  };
  mimicFunction(memoized, fn, {
    ignoreNonConfigurable: true
  });
  cacheStore.set(memoized, cache);
  return memoized;
}
function memDecorator(options = {}) {
  const instanceMap = /* @__PURE__ */ new WeakMap();
  return (target, propertyKey, descriptor) => {
    const input = target[propertyKey];
    if (typeof input !== "function") {
      throw new TypeError("The decorated value must be a function");
    }
    delete descriptor.value;
    delete descriptor.writable;
    descriptor.get = function() {
      if (!instanceMap.has(this)) {
        const value = mem(input, options);
        instanceMap.set(this, value);
        return value;
      }
      return instanceMap.get(this);
    };
  };
}
function memClear(fn) {
  const cache = cacheStore.get(fn);
  if (!cache) {
    throw new TypeError("Can't clear a function that was not memoized!");
  }
  if (typeof cache.clear !== "function") {
    throw new TypeError("The cache Map can't be cleared!");
  }
  cache.clear();
}
var import_map_age_cleaner;
var cacheStore;
var init_dist = __esm({
  "node_modules/mem/dist/index.js"() {
    init_mimic_fn();
    import_map_age_cleaner = __toESM(require_dist());
    cacheStore = /* @__PURE__ */ new WeakMap();
  }
});
var require_pseudomap = __commonJS2({
  "node_modules/pseudomap/pseudomap.js"(exports2, module2) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      this.clear();
      if (set2) {
        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
      }
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      Object.keys(this._data).forEach(function(k) {
        if (k !== "size")
          fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      if (res) {
        delete this._data[res._index];
        this._data.size--;
      }
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0;
      Object.defineProperty(this, "_data", {
        value: data,
        enumerable: false,
        configurable: true,
        writable: false
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: true,
      configurable: true
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k;
      this.value = v;
      this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k))
          return data[key];
      }
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      }
      data.size++;
      data[key] = new Entry(k, v, key);
    }
  }
});
var require_map = __commonJS2({
  "node_modules/pseudomap/map.js"(exports2, module2) {
    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")
      process.env.TEST_PSEUDOMAP = "true";
    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {
      module2.exports = Map;
    } else {
      module2.exports = require_pseudomap();
    }
  }
});
var require_yallist = __commonJS2({
  "node_modules/editorconfig/node_modules/yallist/yallist.js"(exports2, module2) {
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
  }
});
var require_lru_cache = __commonJS2({
  "node_modules/editorconfig/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    module2.exports = LRUCache;
    var Map2 = require_map();
    var util = require("util");
    var Yallist = require_yallist();
    var hasSymbol = typeof Symbol === "function" && process.env._nodeLRUCacheForceNoSymbol !== "1";
    var makeSymbol;
    if (hasSymbol) {
      makeSymbol = function(key) {
        return Symbol(key);
      };
    } else {
      makeSymbol = function(key) {
        return "_" + key;
      };
    }
    var MAX = makeSymbol("max");
    var LENGTH = makeSymbol("length");
    var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");
    var ALLOW_STALE = makeSymbol("allowStale");
    var MAX_AGE = makeSymbol("maxAge");
    var DISPOSE = makeSymbol("dispose");
    var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");
    var LRU_LIST = makeSymbol("lruList");
    var CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache)) {
        return new LRUCache(options);
      }
      if (typeof options === "number") {
        options = {
          max: options
        };
      }
      if (!options) {
        options = {};
      }
      var max = this[MAX] = options.max;
      if (!max || !(typeof max === "number") || max <= 0) {
        this[MAX] = Infinity;
      }
      var lc = options.length || naiveLength;
      if (typeof lc !== "function") {
        lc = naiveLength;
      }
      this[LENGTH_CALCULATOR] = lc;
      this[ALLOW_STALE] = options.stale || false;
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0) {
          mL = Infinity;
        }
        this[MAX] = mL;
        trim(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        if (!mA || !(typeof mA === "number") || mA < 0) {
          mA = 0;
        }
        this[MAX_AGE] = mA;
        trim(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          lC = naiveLength;
        }
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function(hit) {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          }, this);
        }
        trim(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: true
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };
    function forEachStep(self2, fn, node, thisp) {
      var hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE]) {
          hit = void 0;
        }
      }
      if (hit) {
        fn.call(thisp, hit.value, hit.key, self2);
      }
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function(hit) {
          this[DISPOSE](hit.key, hit.value);
        }, this);
      }
      this[CACHE] = new Map2();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    };
    LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit)) {
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {";
      var extras = false;
      var as = this[ALLOW_STALE];
      if (as) {
        str += "\n  allowStale: true";
        extras = true;
      }
      var max = this[MAX];
      if (max && max !== Infinity) {
        if (extras) {
          str += ",";
        }
        str += "\n  max: " + util.inspect(max, opts);
        extras = true;
      }
      var maxAge = this[MAX_AGE];
      if (maxAge) {
        if (extras) {
          str += ",";
        }
        str += "\n  maxAge: " + util.inspect(maxAge, opts);
        extras = true;
      }
      var lc = this[LENGTH_CALCULATOR];
      if (lc && lc !== naiveLength) {
        if (extras) {
          str += ",";
        }
        str += "\n  length: " + util.inspect(this[LENGTH], opts);
        extras = true;
      }
      var didFirst = false;
      this[LRU_LIST].forEach(function(item) {
        if (didFirst) {
          str += ",\n  ";
        } else {
          if (extras) {
            str += ",\n";
          }
          didFirst = true;
          str += "\n  ";
        }
        var key = util.inspect(item.key).split("\n").join("\n  ");
        var val = {
          value: item.value
        };
        if (item.maxAge !== maxAge) {
          val.maxAge = item.maxAge;
        }
        if (lc !== naiveLength) {
          val.length = item.length;
        }
        if (isStale(this, item)) {
          val.stale = true;
        }
        val = util.inspect(val, opts).split("\n").join("\n  ");
        str += key + " => " + val;
      });
      if (didFirst || extras) {
        str += "\n";
      }
      str += "}";
      return str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        var node = this[CACHE].get(key);
        var item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) {
            this[DISPOSE](key, item.value);
          }
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) {
          this[DISPOSE](key, value);
        }
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      if (!this[CACHE].has(key))
        return false;
      var hit = this[CACHE].get(key).value;
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    };
    LRUCache.prototype.del = function(key) {
      del(this, this[CACHE].get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self2 = this;
      this[CACHE].forEach(function(value, key) {
        get(self2, key, false);
      });
    };
    function get(self2, key, doUse) {
      var node = self2[CACHE].get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        } else {
          if (doUse) {
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self2, hit) {
      if (!hit || !hit.maxAge && !self2[MAX_AGE]) {
        return false;
      }
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = self2[MAX_AGE] && diff > self2[MAX_AGE];
      }
      return stale;
    }
    function trim(self2) {
      if (self2[LENGTH] > self2[MAX]) {
        for (var walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    }
    function del(self2, node) {
      if (node) {
        var hit = node.value;
        if (self2[DISPOSE]) {
          self2[DISPOSE](hit.key, hit.value);
        }
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
});
var require_sigmund = __commonJS2({
  "node_modules/sigmund/sigmund.js"(exports2, module2) {
    module2.exports = sigmund;
    function sigmund(subject, maxSessions) {
      maxSessions = maxSessions || 10;
      var notes = [];
      var analysis = "";
      var RE = RegExp;
      function psychoAnalyze(subject2, session) {
        if (session > maxSessions)
          return;
        if (typeof subject2 === "function" || typeof subject2 === "undefined") {
          return;
        }
        if (typeof subject2 !== "object" || !subject2 || subject2 instanceof RE) {
          analysis += subject2;
          return;
        }
        if (notes.indexOf(subject2) !== -1 || session === maxSessions)
          return;
        notes.push(subject2);
        analysis += "{";
        Object.keys(subject2).forEach(function(issue, _, __) {
          if (issue.charAt(0) === "_")
            return;
          var to = typeof subject2[issue];
          if (to === "function" || to === "undefined")
            return;
          analysis += issue;
          psychoAnalyze(subject2[issue], session + 1);
        });
      }
      psychoAnalyze(subject, 0);
      return analysis;
    }
  }
});
var require_fnmatch = __commonJS2({
  "node_modules/editorconfig/src/lib/fnmatch.js"(exports2, module2) {
    var platform = typeof process === "object" ? process.platform : "win32";
    if (module2)
      module2.exports = minimatch;
    else
      exports2.minimatch = minimatch;
    minimatch.Minimatch = Minimatch;
    var LRU = require_lru_cache();
    var cache = minimatch.cache = new LRU({
      max: 100
    });
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var sigmund = require_sigmund();
    var path = require("path");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.monkeyPatch = monkeyPatch;
    function monkeyPatch() {
      var desc = Object.getOwnPropertyDescriptor(String.prototype, "match");
      var orig = desc.value;
      desc.value = function(p) {
        if (p instanceof Minimatch)
          return p.match(this);
        return orig.call(this, p);
      };
      Object.defineProperty(String.prototype, desc);
    }
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options, cache);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (platform === "win32") {
        pattern = pattern.split("\\").join("/");
      }
      var cacheKey = pattern + "\n" + sigmund(options);
      var cached = minimatch.cache.get(cacheKey);
      if (cached)
        return cached;
      minimatch.cache.set(cacheKey, this);
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        console.error(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      if (options.debug)
        console.error(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      if (options.debug)
        console.error(this.pattern, set);
      set = set.filter(function(s) {
        return -1 === s.indexOf(false);
      });
      if (options.debug)
        console.error(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern, negate = false, options = this.options, negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return new Minimatch(pattern, options).braceExpand();
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      options = options || this.options;
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new Error("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      var escaping = false;
      if (pattern.charAt(0) !== "{") {
        var prefix = null;
        for (var i = 0, l = pattern.length; i < l; i++) {
          var c = pattern.charAt(i);
          if (c === "\\") {
            escaping = !escaping;
          } else if (c === "{" && !escaping) {
            prefix = pattern.substr(0, i);
            break;
          }
        }
        if (prefix === null) {
          return [pattern];
        }
        var tail = braceExpand(pattern.substr(i), options);
        return tail.map(function(t) {
          return prefix + t;
        });
      }
      var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/);
      if (numset) {
        var suf = braceExpand(pattern.substr(numset[0].length), options), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set = [];
        for (var i = start; i != end + inc; i += inc) {
          for (var ii = 0, ll = suf.length; ii < ll; ii++) {
            set.push(i + suf[ii]);
          }
        }
        return set;
      }
      var i = 1, depth = 1, set = [], member = "", sawEnd = false, escaping = false;
      function addMember() {
        set.push(member);
        member = "";
      }
      FOR:
        for (i = 1, l = pattern.length; i < l; i++) {
          var c = pattern.charAt(i);
          if (escaping) {
            escaping = false;
            member += "\\" + c;
          } else {
            switch (c) {
              case "\\":
                escaping = true;
                continue;
              case "{":
                depth++;
                member += "{";
                continue;
              case "}":
                depth--;
                if (depth === 0) {
                  addMember();
                  i++;
                  break FOR;
                } else {
                  member += c;
                  continue;
                }
              case ",":
                if (depth === 1) {
                  addMember();
                } else {
                  member += c;
                }
                continue;
              default:
                member += c;
                continue;
            }
          }
        }
      if (depth !== 0) {
        return braceExpand("\\" + pattern, options);
      }
      var suf = braceExpand(pattern.substr(i), options);
      var addBraces = set.length === 1;
      set = set.map(function(p) {
        return braceExpand(p, options);
      });
      set = set.reduce(function(l2, r) {
        return l2.concat(r);
      });
      if (addBraces) {
        set = set.map(function(s) {
          return "{" + s + "}";
        });
      }
      var ret = [];
      for (var i = 0, l = set.length; i < l; i++) {
        for (var ii = 0, ll = suf.length; ii < ll; ii++) {
          ret.push(set[i] + suf[ii]);
        }
      }
      return ret;
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "", hasMagic = !!options.nocase, escaping = false, patternListStack = [], plType, stateChar, inClass = false, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        if (options.debug) {
          console.error("%s	%s %s %j", pattern, i, re, c);
        }
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        SWITCH:
          switch (c) {
            case "/":
              return false;
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              if (options.debug) {
                console.error("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              }
              if (inClass) {
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              plType = stateChar;
              patternListStack.push({
                type: plType,
                start: i - 1,
                reStart: re.length
              });
              re += stateChar === "!" ? "(?:(?!" : "(?:";
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              hasMagic = true;
              re += ")";
              plType = patternListStack.pop().type;
              switch (plType) {
                case "!":
                  re += "[^/]*?)";
                  break;
                case "?":
                case "+":
                case "*":
                  re += plType;
                case "@":
                  break;
              }
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
      }
      if (inClass) {
        var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      var pl;
      while (pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3);
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      if (re !== "" && hasMagic)
        re = "(?=.)" + re;
      if (addPatternStart)
        re = patternStart + re;
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "", regExp = new RegExp("^" + re + "$", flags);
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length)
        return this.regexp = false;
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        return this.regexp = new RegExp(re, flags);
      } catch (ex) {
        return this.regexp = false;
      }
    }
    minimatch.match = function(list, pattern, options) {
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (platform === "win32") {
        f = f.split("\\").join("/");
      }
      f = f.split(slashSplit);
      if (options.debug) {
        console.error(this.pattern, "split", f);
      }
      var set = this.set;
      for (var i = 0, l = set.length; i < l; i++) {
        var pattern = set[i];
        var hit = this.matchOne(f, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      if (options.debug) {
        console.error("matchOne", {
          "this": this,
          file,
          pattern
        });
      }
      if (options.matchBase && pattern.length === 1) {
        file = path.basename(file.join("/")).split("/");
      }
      if (options.debug) {
        console.error("matchOne", file.length, pattern.length);
      }
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        if (options.debug) {
          console.error("matchOne loop");
        }
        var p = pattern[pi], f = file[fi];
        if (options.debug) {
          console.error(pattern, p, f);
        }
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          if (options.debug)
            console.error("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            if (options.debug)
              console.error("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          WHILE:
            while (fr < fl) {
              var swallowee = file[fr];
              if (options.debug) {
                console.error("\nglobstar while", file, fr, pattern, pr, swallowee);
              }
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                if (options.debug)
                  console.error("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  if (options.debug)
                    console.error("dot detected!", file, fr, pattern, pr);
                  break WHILE;
                }
                if (options.debug)
                  console.error("globstar swallow a segment, and continue");
                fr++;
              }
            }
          if (partial) {
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          if (options.debug) {
            console.error("string match", p, f, hit);
          }
        } else {
          hit = f.match(p);
          if (options.debug) {
            console.error("pattern match", p, f, hit);
          }
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});
var require_ini = __commonJS2({
  "node_modules/editorconfig/src/lib/ini.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var fs = __importStar2(require("fs"));
    var regex = {
      section: /^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$/,
      param: /^\s*([\w\.\-\_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$/,
      comment: /^\s*[#;].*$/
    };
    function parse(file) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          return [2, new Promise(function(resolve, reject) {
            fs.readFile(file, "utf8", function(err, data) {
              if (err) {
                reject(err);
                return;
              }
              resolve(parseString(data));
            });
          })];
        });
      });
    }
    exports2.parse = parse;
    function parseSync(file) {
      return parseString(fs.readFileSync(file, "utf8"));
    }
    exports2.parseSync = parseSync;
    function parseString(data) {
      var sectionBody = {};
      var sectionName = null;
      var value = [[sectionName, sectionBody]];
      var lines = data.split(/\r\n|\r|\n/);
      lines.forEach(function(line) {
        var match;
        if (regex.comment.test(line)) {
          return;
        }
        if (regex.param.test(line)) {
          match = line.match(regex.param);
          sectionBody[match[1]] = match[2];
        } else if (regex.section.test(line)) {
          match = line.match(regex.section);
          sectionName = match[1];
          sectionBody = {};
          value.push([sectionName, sectionBody]);
        }
      });
      return value;
    }
    exports2.parseString = parseString;
  }
});
var require_package = __commonJS2({
  "node_modules/editorconfig/package.json"(exports2, module2) {
    module2.exports = {
      name: "editorconfig",
      version: "0.15.3",
      description: "EditorConfig File Locator and Interpreter for Node.js",
      keywords: ["editorconfig", "core"],
      main: "src/index.js",
      contributors: ["Hong Xu (topbug.net)", "Jed Mao (https://github.com/jedmao/)", "Trey Hunner (http://treyhunner.com)"],
      directories: {
        bin: "./bin",
        lib: "./lib"
      },
      scripts: {
        clean: "rimraf dist",
        prebuild: "npm run clean",
        build: "tsc",
        pretest: "npm run lint && npm run build && npm run copy && cmake .",
        test: "ctest .",
        "pretest:ci": "npm run pretest",
        "test:ci": "ctest -VV --output-on-failure .",
        lint: "npm run eclint && npm run tslint",
        eclint: 'eclint check --indent_size ignore "src/**"',
        tslint: "tslint --project tsconfig.json --exclude package.json",
        copy: "cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib",
        prepub: "npm run lint && npm run build && npm run copy",
        pub: "npm publish ./dist"
      },
      repository: {
        type: "git",
        url: "git://github.com/editorconfig/editorconfig-core-js.git"
      },
      bugs: "https://github.com/editorconfig/editorconfig-core-js/issues",
      author: "EditorConfig Team",
      license: "MIT",
      dependencies: {
        commander: "^2.19.0",
        "lru-cache": "^4.1.5",
        semver: "^5.6.0",
        sigmund: "^1.0.1"
      },
      devDependencies: {
        "@types/mocha": "^5.2.6",
        "@types/node": "^10.12.29",
        "@types/semver": "^5.5.0",
        "cpy-cli": "^2.0.0",
        eclint: "^2.8.1",
        mocha: "^5.2.0",
        rimraf: "^2.6.3",
        should: "^13.2.3",
        tslint: "^5.13.1",
        typescript: "^3.3.3333"
      }
    };
  }
});
var require_src2 = __commonJS2({
  "node_modules/editorconfig/src/index.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var fs = __importStar2(require("fs"));
    var path = __importStar2(require("path"));
    var semver = {
      gte: require_gte()
    };
    var fnmatch_1 = __importDefault2(require_fnmatch());
    var ini_1 = require_ini();
    exports2.parseString = ini_1.parseString;
    var package_json_1 = __importDefault2(require_package());
    var knownProps = {
      end_of_line: true,
      indent_style: true,
      indent_size: true,
      insert_final_newline: true,
      trim_trailing_whitespace: true,
      charset: true
    };
    function fnmatch(filepath, glob) {
      var matchOptions = {
        matchBase: true,
        dot: true,
        noext: true
      };
      glob = glob.replace(/\*\*/g, "{*,**/**/**}");
      return fnmatch_1.default(filepath, glob, matchOptions);
    }
    function getConfigFileNames(filepath, options) {
      var paths = [];
      do {
        filepath = path.dirname(filepath);
        paths.push(path.join(filepath, options.config));
      } while (filepath !== options.root);
      return paths;
    }
    function processMatches(matches, version2) {
      if ("indent_style" in matches && matches.indent_style === "tab" && !("indent_size" in matches) && semver.gte(version2, "0.10.0")) {
        matches.indent_size = "tab";
      }
      if ("indent_size" in matches && !("tab_width" in matches) && matches.indent_size !== "tab") {
        matches.tab_width = matches.indent_size;
      }
      if ("indent_size" in matches && "tab_width" in matches && matches.indent_size === "tab") {
        matches.indent_size = matches.tab_width;
      }
      return matches;
    }
    function processOptions(options, filepath) {
      if (options === void 0) {
        options = {};
      }
      return {
        config: options.config || ".editorconfig",
        version: options.version || package_json_1.default.version,
        root: path.resolve(options.root || path.parse(filepath).root)
      };
    }
    function buildFullGlob(pathPrefix, glob) {
      switch (glob.indexOf("/")) {
        case -1:
          glob = "**/" + glob;
          break;
        case 0:
          glob = glob.substring(1);
          break;
        default:
          break;
      }
      return path.join(pathPrefix, glob);
    }
    function extendProps(props, options) {
      if (props === void 0) {
        props = {};
      }
      if (options === void 0) {
        options = {};
      }
      for (var key in options) {
        if (options.hasOwnProperty(key)) {
          var value = options[key];
          var key2 = key.toLowerCase();
          var value2 = value;
          if (knownProps[key2]) {
            value2 = value.toLowerCase();
          }
          try {
            value2 = JSON.parse(value);
          } catch (e) {
          }
          if (typeof value === "undefined" || value === null) {
            value2 = String(value);
          }
          props[key2] = value2;
        }
      }
      return props;
    }
    function parseFromConfigs(configs, filepath, options) {
      return processMatches(configs.reverse().reduce(function(matches, file) {
        var pathPrefix = path.dirname(file.name);
        file.contents.forEach(function(section) {
          var glob = section[0];
          var options2 = section[1];
          if (!glob) {
            return;
          }
          var fullGlob = buildFullGlob(pathPrefix, glob);
          if (!fnmatch(filepath, fullGlob)) {
            return;
          }
          matches = extendProps(matches, options2);
        });
        return matches;
      }, {}), options.version);
    }
    function getConfigsForFiles(files) {
      var configs = [];
      for (var i in files) {
        if (files.hasOwnProperty(i)) {
          var file = files[i];
          var contents = ini_1.parseString(file.contents);
          configs.push({
            name: file.name,
            contents
          });
          if ((contents[0][1].root || "").toLowerCase() === "true") {
            break;
          }
        }
      }
      return configs;
    }
    function readConfigFiles(filepaths) {
      return __awaiter2(this, void 0, void 0, function() {
        return __generator2(this, function(_a) {
          return [2, Promise.all(filepaths.map(function(name) {
            return new Promise(function(resolve) {
              fs.readFile(name, "utf8", function(err, data) {
                resolve({
                  name,
                  contents: err ? "" : data
                });
              });
            });
          }))];
        });
      });
    }
    function readConfigFilesSync(filepaths) {
      var files = [];
      var file;
      filepaths.forEach(function(filepath) {
        try {
          file = fs.readFileSync(filepath, "utf8");
        } catch (e) {
          file = "";
        }
        files.push({
          name: filepath,
          contents: file
        });
      });
      return files;
    }
    function opts(filepath, options) {
      if (options === void 0) {
        options = {};
      }
      var resolvedFilePath = path.resolve(filepath);
      return [resolvedFilePath, processOptions(options, resolvedFilePath)];
    }
    function parseFromFiles(filepath, files, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, resolvedFilePath, processedOptions;
        return __generator2(this, function(_b) {
          _a = opts(filepath, options), resolvedFilePath = _a[0], processedOptions = _a[1];
          return [2, files.then(getConfigsForFiles).then(function(configs) {
            return parseFromConfigs(configs, resolvedFilePath, processedOptions);
          })];
        });
      });
    }
    exports2.parseFromFiles = parseFromFiles;
    function parseFromFilesSync(filepath, files, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = opts(filepath, options), resolvedFilePath = _a[0], processedOptions = _a[1];
      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
    }
    exports2.parseFromFilesSync = parseFromFilesSync;
    function parse(_filepath, _options) {
      if (_options === void 0) {
        _options = {};
      }
      return __awaiter2(this, void 0, void 0, function() {
        var _a, resolvedFilePath, processedOptions, filepaths;
        return __generator2(this, function(_b) {
          _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];
          filepaths = getConfigFileNames(resolvedFilePath, processedOptions);
          return [2, readConfigFiles(filepaths).then(getConfigsForFiles).then(function(configs) {
            return parseFromConfigs(configs, resolvedFilePath, processedOptions);
          })];
        });
      });
    }
    exports2.parse = parse;
    function parseSync(_filepath, _options) {
      if (_options === void 0) {
        _options = {};
      }
      var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];
      var filepaths = getConfigFileNames(resolvedFilePath, processedOptions);
      var files = readConfigFilesSync(filepaths);
      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
    }
    exports2.parseSync = parseSync;
  }
});
var require_editorconfig_to_prettier = __commonJS2({
  "node_modules/editorconfig-to-prettier/index.js"(exports2, module2) {
    module2.exports = editorConfigToPrettier;
    function removeUnset(editorConfig) {
      const result = {};
      const keys = Object.keys(editorConfig);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (editorConfig[key] === "unset") {
          continue;
        }
        result[key] = editorConfig[key];
      }
      return result;
    }
    function editorConfigToPrettier(editorConfig) {
      if (!editorConfig) {
        return null;
      }
      editorConfig = removeUnset(editorConfig);
      if (Object.keys(editorConfig).length === 0) {
        return null;
      }
      const result = {};
      if (editorConfig.indent_style) {
        result.useTabs = editorConfig.indent_style === "tab";
      }
      if (editorConfig.indent_size === "tab") {
        result.useTabs = true;
      }
      if (result.useTabs && editorConfig.tab_width) {
        result.tabWidth = editorConfig.tab_width;
      } else if (editorConfig.indent_style === "space" && editorConfig.indent_size && editorConfig.indent_size !== "tab") {
        result.tabWidth = editorConfig.indent_size;
      } else if (editorConfig.tab_width !== void 0) {
        result.tabWidth = editorConfig.tab_width;
      }
      if (editorConfig.max_line_length) {
        if (editorConfig.max_line_length === "off") {
          result.printWidth = Number.POSITIVE_INFINITY;
        } else {
          result.printWidth = editorConfig.max_line_length;
        }
      }
      if (editorConfig.quote_type === "single") {
        result.singleQuote = true;
      } else if (editorConfig.quote_type === "double") {
        result.singleQuote = false;
      }
      if (["cr", "crlf", "lf"].indexOf(editorConfig.end_of_line) !== -1) {
        result.endOfLine = editorConfig.end_of_line;
      }
      if (editorConfig.insert_final_newline === false || editorConfig.insert_final_newline === true) {
        result.insertFinalNewline = editorConfig.insert_final_newline;
      }
      return result;
    }
  }
});
var require_find_project_root = __commonJS2({
  "src/config/find-project-root.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var MARKERS = [".git", ".hg"];
    var markerExists = (directory) => MARKERS.some((mark) => fs.existsSync(path.join(directory, mark)));
    function findProjectRoot(directory) {
      while (!markerExists(directory)) {
        const parentDirectory = path.resolve(directory, "..");
        if (parentDirectory === directory) {
          break;
        }
        directory = parentDirectory;
      }
      return directory;
    }
    module2.exports = findProjectRoot;
  }
});
var require_resolve_config_editorconfig = __commonJS2({
  "src/config/resolve-config-editorconfig.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var editorconfig = require_src2();
    var editorConfigToPrettier = require_editorconfig_to_prettier();
    var {
      default: mem2,
      memClear: memClear2
    } = (init_dist(), __toCommonJS(dist_exports));
    var findProjectRoot = require_find_project_root();
    var jsonStringifyMem = (fn) => mem2(fn, {
      cacheKey: JSON.stringify
    });
    var maybeParse = (filePath, parse) => filePath && parse(filePath, {
      root: findProjectRoot(path.dirname(path.resolve(filePath)))
    });
    var editorconfigAsyncNoCache = async (filePath) => editorConfigToPrettier(await maybeParse(filePath, editorconfig.parse));
    var editorconfigAsyncWithCache = jsonStringifyMem(editorconfigAsyncNoCache);
    var editorconfigSyncNoCache = (filePath) => editorConfigToPrettier(maybeParse(filePath, editorconfig.parseSync));
    var editorconfigSyncWithCache = jsonStringifyMem(editorconfigSyncNoCache);
    function getLoadFunction(opts) {
      if (!opts.editorconfig) {
        return () => null;
      }
      if (opts.sync) {
        return opts.cache ? editorconfigSyncWithCache : editorconfigSyncNoCache;
      }
      return opts.cache ? editorconfigAsyncWithCache : editorconfigAsyncNoCache;
    }
    function clearCache() {
      memClear2(editorconfigSyncWithCache);
      memClear2(editorconfigAsyncWithCache);
    }
    module2.exports = {
      getLoadFunction,
      clearCache
    };
  }
});
var require_resolve_config = __commonJS2({
  "src/config/resolve-config.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var micromatch = require_micromatch();
    var thirdParty = require("./third-party.js");
    var loadToml = require_load_toml();
    var loadJson5 = require_load_json5();
    var partition = require_partition();
    var resolve = require_resolve2();
    var {
      default: mem2,
      memClear: memClear2
    } = (init_dist(), __toCommonJS(dist_exports));
    var resolveEditorConfig = require_resolve_config_editorconfig();
    var getExplorerMemoized = mem2((opts) => {
      const cosmiconfig = thirdParty["cosmiconfig" + (opts.sync ? "Sync" : "")];
      const explorer = cosmiconfig("prettier", {
        cache: opts.cache,
        transform: (result) => {
          if (result && result.config) {
            if (typeof result.config === "string") {
              const dir = path.dirname(result.filepath);
              const modulePath = resolve(result.config, {
                paths: [dir]
              });
              result.config = require(modulePath);
            }
            if (typeof result.config !== "object") {
              throw new TypeError(`Config is only allowed to be an object, but received ${typeof result.config} in "${result.filepath}"`);
            }
            delete result.config.$schema;
          }
          return result;
        },
        searchPlaces: ["package.json", ".prettierrc", ".prettierrc.json", ".prettierrc.yaml", ".prettierrc.yml", ".prettierrc.json5", ".prettierrc.js", ".prettierrc.cjs", "prettier.config.js", "prettier.config.cjs", ".prettierrc.toml"],
        loaders: {
          ".toml": loadToml,
          ".json5": loadJson5
        }
      });
      return explorer;
    }, {
      cacheKey: JSON.stringify
    });
    function getExplorer(opts) {
      opts = Object.assign({
        sync: false,
        cache: false
      }, opts);
      return getExplorerMemoized(opts);
    }
    function _resolveConfig(filePath, opts, sync) {
      opts = Object.assign({
        useCache: true
      }, opts);
      const loadOpts = {
        cache: Boolean(opts.useCache),
        sync: Boolean(sync),
        editorconfig: Boolean(opts.editorconfig)
      };
      const {
        load,
        search
      } = getExplorer(loadOpts);
      const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);
      const arr = [opts.config ? load(opts.config) : search(filePath), loadEditorConfig(filePath)];
      const unwrapAndMerge = ([result, editorConfigured]) => {
        const merged = Object.assign(Object.assign({}, editorConfigured), mergeOverrides(result, filePath));
        for (const optionName of ["plugins", "pluginSearchDirs"]) {
          if (Array.isArray(merged[optionName])) {
            merged[optionName] = merged[optionName].map((value) => typeof value === "string" && value.startsWith(".") ? path.resolve(path.dirname(result.filepath), value) : value);
          }
        }
        if (!result && !editorConfigured) {
          return null;
        }
        delete merged.insertFinalNewline;
        return merged;
      };
      if (loadOpts.sync) {
        return unwrapAndMerge(arr);
      }
      return Promise.all(arr).then(unwrapAndMerge);
    }
    var resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);
    resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);
    function clearCache() {
      memClear2(getExplorerMemoized);
      resolveEditorConfig.clearCache();
    }
    async function resolveConfigFile(filePath) {
      const {
        search
      } = getExplorer({
        sync: false
      });
      const result = await search(filePath);
      return result ? result.filepath : null;
    }
    resolveConfigFile.sync = (filePath) => {
      const {
        search
      } = getExplorer({
        sync: true
      });
      const result = search(filePath);
      return result ? result.filepath : null;
    };
    function mergeOverrides(configResult, filePath) {
      const {
        config: config2,
        filepath: configPath
      } = configResult || {};
      const _ref = config2 || {}, {
        overrides
      } = _ref, options = _objectWithoutProperties(_ref, _excluded3);
      if (filePath && overrides) {
        const relativeFilePath = path.relative(path.dirname(configPath), filePath);
        for (const override of overrides) {
          if (pathMatchesGlobs(relativeFilePath, override.files, override.excludeFiles)) {
            Object.assign(options, override.options);
          }
        }
      }
      return options;
    }
    function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
      const patternList = Array.isArray(patterns) ? patterns : [patterns];
      const [withSlashes, withoutSlashes] = partition(patternList, (pattern) => pattern.includes("/"));
      return micromatch.isMatch(filePath, withoutSlashes, {
        ignore: excludedPatterns,
        basename: true,
        dot: true
      }) || micromatch.isMatch(filePath, withSlashes, {
        ignore: excludedPatterns,
        basename: false,
        dot: true
      });
    }
    module2.exports = {
      resolveConfig,
      resolveConfigFile,
      clearCache
    };
  }
});
var require_ignore = __commonJS2({
  "node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, {
      value
    });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
    var cleanRangeBackSlash = (slashes) => {
      const {
        length
      } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [[/\\?\s+$/, (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY], [/\\\s/g, () => SPACE], [/[\\$.|*+(){^]/g, (match) => `\\${match}`], [/(?!\\)\?/g, () => "[^/]"], [/^\//, () => "^"], [/\//g, () => "\\/"], [/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"], [/^(?=[^^])/, function startingReplacer() {
      return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
    }], [/\\\/\\\*\\\*(?=\\\/|$)/g, (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"], [/(^|[^\\]+)\\\*(?=.+)/g, (_, p1) => `${p1}[^\\/]*`], [/\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE], [/\\\\/g, () => ESCAPE], [/(\\)?\[([^\]/]*?)(\\*)($|\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"], [/(?:[^*])$/, (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`], [/(\^|\\\/)?\\\*$/, (_, p1) => {
      const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
      return `${prefix}(?=$|\\/$)`;
    }]];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const {
            negative
          } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});
var require_get_file_content_or_null = __commonJS2({
  "src/utils/get-file-content-or-null.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var fsAsync = fs.promises;
    async function getFileContentOrNull(filename) {
      try {
        return await fsAsync.readFile(filename, "utf8");
      } catch (error) {
        return handleError(filename, error);
      }
    }
    getFileContentOrNull.sync = function(filename) {
      try {
        return fs.readFileSync(filename, "utf8");
      } catch (error) {
        return handleError(filename, error);
      }
    };
    function handleError(filename, error) {
      if (error && error.code === "ENOENT") {
        return null;
      }
      throw new Error(`Unable to read ${filename}: ${error.message}`);
    }
    module2.exports = getFileContentOrNull;
  }
});
var require_create_ignorer = __commonJS2({
  "src/common/create-ignorer.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var ignore = require_ignore().default;
    var getFileContentOrNull = require_get_file_content_or_null();
    async function createIgnorer(ignorePath, withNodeModules) {
      const ignoreContent = ignorePath ? await getFileContentOrNull(path.resolve(ignorePath)) : null;
      return _createIgnorer(ignoreContent, withNodeModules);
    }
    createIgnorer.sync = function(ignorePath, withNodeModules) {
      const ignoreContent = !ignorePath ? null : getFileContentOrNull.sync(path.resolve(ignorePath));
      return _createIgnorer(ignoreContent, withNodeModules);
    };
    function _createIgnorer(ignoreContent, withNodeModules) {
      const ignorer = ignore({
        allowRelativePaths: true
      }).add(ignoreContent || "");
      if (!withNodeModules) {
        ignorer.add("node_modules");
      }
      return ignorer;
    }
    module2.exports = createIgnorer;
  }
});
var require_get_file_info = __commonJS2({
  "src/common/get-file-info.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var options = require_options();
    var config2 = require_resolve_config();
    var createIgnorer = require_create_ignorer();
    async function getFileInfo2(filePath, opts) {
      if (typeof filePath !== "string") {
        throw new TypeError(`expect \`filePath\` to be a string, got \`${typeof filePath}\``);
      }
      const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);
      return _getFileInfo({
        ignorer,
        filePath,
        plugins: opts.plugins,
        resolveConfig: opts.resolveConfig,
        ignorePath: opts.ignorePath,
        sync: false
      });
    }
    getFileInfo2.sync = function(filePath, opts) {
      if (typeof filePath !== "string") {
        throw new TypeError(`expect \`filePath\` to be a string, got \`${typeof filePath}\``);
      }
      const ignorer = createIgnorer.sync(opts.ignorePath, opts.withNodeModules);
      return _getFileInfo({
        ignorer,
        filePath,
        plugins: opts.plugins,
        resolveConfig: opts.resolveConfig,
        ignorePath: opts.ignorePath,
        sync: true
      });
    };
    function getFileParser(resolvedConfig, filePath, plugins2) {
      if (resolvedConfig && resolvedConfig.parser) {
        return resolvedConfig.parser;
      }
      const inferredParser = options.inferParser(filePath, plugins2);
      if (inferredParser) {
        return inferredParser;
      }
      return null;
    }
    function _getFileInfo({
      ignorer,
      filePath,
      plugins: plugins2,
      resolveConfig = false,
      ignorePath,
      sync = false
    }) {
      const normalizedFilePath = normalizeFilePath(filePath, ignorePath);
      const fileInfo = {
        ignored: ignorer.ignores(normalizedFilePath),
        inferredParser: null
      };
      if (fileInfo.ignored) {
        return fileInfo;
      }
      let resolvedConfig;
      if (resolveConfig) {
        if (sync) {
          resolvedConfig = config2.resolveConfig.sync(filePath);
        } else {
          return config2.resolveConfig(filePath).then((resolvedConfig2) => {
            fileInfo.inferredParser = getFileParser(resolvedConfig2, filePath, plugins2);
            return fileInfo;
          });
        }
      }
      fileInfo.inferredParser = getFileParser(resolvedConfig, filePath, plugins2);
      return fileInfo;
    }
    function normalizeFilePath(filePath, ignorePath) {
      return ignorePath ? path.relative(path.dirname(ignorePath), filePath) : filePath;
    }
    module2.exports = getFileInfo2;
  }
});
var require_util_shared = __commonJS2({
  "src/common/util-shared.js"(exports2, module2) {
    "use strict";
    var {
      getMaxContinuousCount,
      getStringWidth,
      getAlignmentSize,
      getIndentSize,
      skip,
      skipWhitespace,
      skipSpaces,
      skipNewline,
      skipToLineEnd,
      skipEverythingButNewLine,
      skipInlineComment,
      skipTrailingComment,
      hasNewline,
      hasNewlineInRange,
      hasSpaces,
      isNextLineEmpty,
      isNextLineEmptyAfterIndex,
      isPreviousLineEmpty,
      getNextNonSpaceNonCommentCharacterIndex,
      makeString,
      addLeadingComment,
      addDanglingComment,
      addTrailingComment
    } = require_util();
    module2.exports = {
      getMaxContinuousCount,
      getStringWidth,
      getAlignmentSize,
      getIndentSize,
      skip,
      skipWhitespace,
      skipSpaces,
      skipNewline,
      skipToLineEnd,
      skipEverythingButNewLine,
      skipInlineComment,
      skipTrailingComment,
      hasNewline,
      hasNewlineInRange,
      hasSpaces,
      isNextLineEmpty,
      isNextLineEmptyAfterIndex,
      isPreviousLineEmpty,
      getNextNonSpaceNonCommentCharacterIndex,
      makeString,
      addLeadingComment,
      addDanglingComment,
      addTrailingComment
    };
  }
});
var require_array3 = __commonJS2({
  "node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});
var require_errno = __commonJS2({
  "node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});
var require_fs = __commonJS2({
  "node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});
var require_path = __commonJS2({
  "node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});
var require_is_extglob = __commonJS2({
  "node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});
var require_is_glob = __commonJS2({
  "node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = {
      "{": "}",
      "(": ")",
      "[": "]"
    };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});
var require_glob_parent = __commonJS2({
  "node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({
        flipBackslashes: true
      }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});
var require_pattern = __commonJS2({
  "node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, {
        flipBackslashes: false
      });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let {
        parts
      } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {
        parts: true
      }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  }
});
var require_merge2 = __commonJS2({
  "node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, {
            end: false
          });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});
var require_stream = __commonJS2({
  "node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});
var require_string2 = __commonJS2({
  "node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});
var require_utils4 = __commonJS2({
  "node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array3();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs = require_fs();
    exports2.fs = fs;
    var path = require_path();
    exports2.path = path;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string2();
    exports2.string = string;
  }
});
var require_tasks = __commonJS2({
  "node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils4();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});
var require_patterns = __commonJS2({
  "node_modules/fast-glob/out/managers/patterns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.removeDuplicateSlashes = exports2.transform = void 0;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function transform(patterns) {
      return patterns.map((pattern) => removeDuplicateSlashes(pattern));
    }
    exports2.transform = transform;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});
var require_async2 = __commonJS2({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.read = void 0;
    function read(path, settings, callback) {
      settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});
var require_sync2 = __commonJS2({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.read = void 0;
    function read(path, settings) {
      const lstat = settings.fs.lstatSync(path);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  }
});
var require_fs2 = __commonJS2({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});
var require_settings = __commonJS2({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var fs = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});
var require_out = __commonJS2({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});
var require_queue_microtask = __commonJS2({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});
var require_run_parallel = __commonJS2({
  "node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});
var require_constants4 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});
var require_fs3 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});
var require_utils5 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fs = void 0;
    var fs = require_fs3();
    exports2.fs = fs;
  }
});
var require_common3 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});
var require_async3 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils5();
    var common = require_common3();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, {
        withFileTypes: true
      }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});
var require_sync3 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils5();
    var common = require_common3();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, {
        withFileTypes: true
      });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});
var require_fs4 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});
var require_settings2 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var path = require("path");
    var fsStat = require_out();
    var fs = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});
var require_out2 = __commonJS2({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async3();
    var sync = require_sync3();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});
var require_reusify = __commonJS2({
  "node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});
var require_queue = __commonJS2({
  "node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});
var require_common4 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});
var require_reader = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var common = require_common4();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});
var require_async4 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common4();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = {
          directory,
          base
        };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});
var require_async5 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var async_1 = require_async4();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});
var require_stream2 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var stream_1 = require("stream");
    var async_1 = require_async4();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});
var require_sync4 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var fsScandir = require_out2();
    var common = require_common4();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({
          directory,
          base
        });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});
var require_sync5 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var sync_1 = require_sync4();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});
var require_settings3 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var path = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});
var require_out3 = __commonJS2({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async5();
    var stream_1 = require_stream2();
    var sync_1 = require_sync5();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});
var require_reader2 = __commonJS2({
  "node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var path = require("path");
    var fsStat = require_out();
    var utils = require_utils4();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});
var require_stream3 = __commonJS2({
  "node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({
          objectMode: true
        });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});
var require_async6 = __commonJS2({
  "node_modules/fast-glob/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve(entries));
        });
      }
    };
    exports2.default = ReaderAsync;
  }
});
var require_matcher = __commonJS2({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var utils = require_utils4();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});
var require_partial = __commonJS2({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});
var require_deep = __commonJS2({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var utils = require_utils4();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});
var require_entry = __commonJS2({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var utils = require_utils4();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe, isDirectory) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports2.default = EntryFilter;
  }
});
var require_error = __commonJS2({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var utils = require_utils4();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});
var require_entry2 = __commonJS2({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var utils = require_utils4();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), {
          path: filepath
        });
      }
    };
    exports2.default = EntryTransformer;
  }
});
var require_provider = __commonJS2({
  "node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var path = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});
var require_async7 = __commonJS2({
  "node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var async_1 = require_async6();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});
var require_stream4 = __commonJS2({
  "node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({
          objectMode: true,
          read: () => {
          }
        });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});
var require_sync6 = __commonJS2({
  "node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});
var require_sync7 = __commonJS2({
  "node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var sync_1 = require_sync6();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});
var require_settings4 = __commonJS2({
  "node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      lstatSync: fs.lstatSync,
      stat: fs.stat,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});
var require_out4 = __commonJS2({
  "node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var patternManager = require_patterns();
    var async_1 = require_async7();
    var stream_1 = require_stream4();
    var sync_1 = require_sync7();
    var settings_1 = require_settings4();
    var utils = require_utils4();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = patternManager.transform([].concat(source));
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});
var require_uniq_by_key = __commonJS2({
  "src/utils/uniq-by-key.js"(exports2, module2) {
    "use strict";
    function uniqByKey(array, key) {
      const result = [];
      const seen = /* @__PURE__ */ new Set();
      for (const element of array) {
        const value = element[key];
        if (!seen.has(value)) {
          seen.add(value);
          result.push(element);
        }
      }
      return result;
    }
    module2.exports = uniqByKey;
  }
});
var require_create_language = __commonJS2({
  "src/utils/create-language.js"(exports2, module2) {
    "use strict";
    module2.exports = function(linguistData, override) {
      const {
        languageId
      } = linguistData, rest = _objectWithoutProperties(linguistData, _excluded4);
      return Object.assign(Object.assign({
        linguistLanguageId: languageId
      }, rest), override(linguistData));
    };
  }
});
var require_ast = __commonJS2({
  "node_modules/esutils/lib/ast.js"(exports2, module2) {
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === "IfStatement") {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module2.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});
var require_code = __commonJS2({
  "node_modules/esutils/lib/code.js"(exports2, module2) {
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57 || 97 <= ch2 && ch2 <= 102 || 65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module2.exports = {
        isDecimalDigit,
        isHexDigit,
        isOctalDigit,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});
var require_keyword2 = __commonJS2({
  "node_modules/esutils/lib/keyword.js"(exports2, module2) {
    (function() {
      "use strict";
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module2.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});
var require_utils6 = __commonJS2({
  "node_modules/esutils/lib/utils.js"(exports2) {
    (function() {
      "use strict";
      exports2.ast = require_ast();
      exports2.code = require_code();
      exports2.keyword = require_keyword2();
    })();
  }
});
var require_is_block_comment = __commonJS2({
  "src/language-js/utils/is-block-comment.js"(exports2, module2) {
    "use strict";
    var BLOCK_COMMENT_TYPES = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]);
    var isBlockComment = (comment) => BLOCK_COMMENT_TYPES.has(comment === null || comment === void 0 ? void 0 : comment.type);
    module2.exports = isBlockComment;
  }
});
var require_is_node_matches = __commonJS2({
  "src/language-js/utils/is-node-matches.js"(exports2, module2) {
    "use strict";
    function isNodeMatchesNameOrPath(node, nameOrPath) {
      const names = nameOrPath.split(".");
      for (let index = names.length - 1; index >= 0; index--) {
        const name = names[index];
        if (index === 0) {
          return node.type === "Identifier" && node.name === name;
        }
        if (node.type !== "MemberExpression" || node.optional || node.computed || node.property.type !== "Identifier" || node.property.name !== name) {
          return false;
        }
        node = node.object;
      }
    }
    function isNodeMatches(node, nameOrPaths) {
      return nameOrPaths.some((nameOrPath) => isNodeMatchesNameOrPath(node, nameOrPath));
    }
    module2.exports = isNodeMatches;
  }
});
var require_utils7 = __commonJS2({
  "src/language-js/utils/index.js"(exports2, module2) {
    "use strict";
    var isIdentifierName = require_utils6().keyword.isIdentifierNameES5;
    var {
      getLast,
      hasNewline,
      skipWhitespace,
      isNonEmptyArray,
      isNextLineEmptyAfterIndex,
      getStringWidth
    } = require_util();
    var {
      locStart,
      locEnd,
      hasSameLocStart
    } = require_loc();
    var isBlockComment = require_is_block_comment();
    var isNodeMatches = require_is_node_matches();
    var NON_LINE_TERMINATING_WHITE_SPACE = "(?:(?=.)\\s)";
    var FLOW_SHORTHAND_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*:`);
    var FLOW_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*::`);
    function hasFlowShorthandAnnotationComment(node) {
      var _node$extra, _node$trailingComment;
      return ((_node$extra = node.extra) === null || _node$extra === void 0 ? void 0 : _node$extra.parenthesized) && isBlockComment((_node$trailingComment = node.trailingComments) === null || _node$trailingComment === void 0 ? void 0 : _node$trailingComment[0]) && FLOW_SHORTHAND_ANNOTATION.test(node.trailingComments[0].value);
    }
    function hasFlowAnnotationComment(comments) {
      const firstComment = comments === null || comments === void 0 ? void 0 : comments[0];
      return isBlockComment(firstComment) && FLOW_ANNOTATION.test(firstComment.value);
    }
    function hasNode(node, fn) {
      if (!node || typeof node !== "object") {
        return false;
      }
      if (Array.isArray(node)) {
        return node.some((value) => hasNode(value, fn));
      }
      const result = fn(node);
      return typeof result === "boolean" ? result : Object.values(node).some((value) => hasNode(value, fn));
    }
    function hasNakedLeftSide(node) {
      return node.type === "AssignmentExpression" || node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression" || node.type === "ConditionalExpression" || isCallExpression(node) || isMemberExpression(node) || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "BindExpression" || node.type === "UpdateExpression" && !node.prefix || isTSTypeExpression(node) || node.type === "TSNonNullExpression";
    }
    function getLeftSide(node) {
      var _ref2, _ref3, _ref4, _ref5, _ref6, _node$left;
      if (node.expressions) {
        return node.expressions[0];
      }
      return (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_ref6 = (_node$left = node.left) !== null && _node$left !== void 0 ? _node$left : node.test) !== null && _ref6 !== void 0 ? _ref6 : node.callee) !== null && _ref5 !== void 0 ? _ref5 : node.object) !== null && _ref4 !== void 0 ? _ref4 : node.tag) !== null && _ref3 !== void 0 ? _ref3 : node.argument) !== null && _ref2 !== void 0 ? _ref2 : node.expression;
    }
    function getLeftSidePathName(path, node) {
      if (node.expressions) {
        return ["expressions", 0];
      }
      if (node.left) {
        return ["left"];
      }
      if (node.test) {
        return ["test"];
      }
      if (node.object) {
        return ["object"];
      }
      if (node.callee) {
        return ["callee"];
      }
      if (node.tag) {
        return ["tag"];
      }
      if (node.argument) {
        return ["argument"];
      }
      if (node.expression) {
        return ["expression"];
      }
      throw new Error("Unexpected node has no left side.");
    }
    function createTypeCheckFunction(types) {
      types = new Set(types);
      return (node) => types.has(node === null || node === void 0 ? void 0 : node.type);
    }
    var isLineComment = createTypeCheckFunction(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]);
    var isExportDeclaration = createTypeCheckFunction(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
    function getParentExportDeclaration(path) {
      const parentNode = path.getParentNode();
      if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {
        return parentNode;
      }
      return null;
    }
    var isLiteral = createTypeCheckFunction(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
    function isNumericLiteral(node) {
      return node.type === "NumericLiteral" || node.type === "Literal" && typeof node.value === "number";
    }
    function isSignedNumericLiteral(node) {
      return node.type === "UnaryExpression" && (node.operator === "+" || node.operator === "-") && isNumericLiteral(node.argument);
    }
    function isStringLiteral(node) {
      return node.type === "StringLiteral" || node.type === "Literal" && typeof node.value === "string";
    }
    var isObjectType = createTypeCheckFunction(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]);
    var isFunctionOrArrowExpression = createTypeCheckFunction(["FunctionExpression", "ArrowFunctionExpression"]);
    function isFunctionOrArrowExpressionWithBody(node) {
      return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement";
    }
    function isAngularTestWrapper(node) {
      return isCallExpression(node) && node.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(node.callee.name);
    }
    var isJsxNode = createTypeCheckFunction(["JSXElement", "JSXFragment"]);
    function isTheOnlyJsxElementInMarkdown(options, path) {
      if (options.parentParser !== "markdown" && options.parentParser !== "mdx") {
        return false;
      }
      const node = path.getNode();
      if (!node.expression || !isJsxNode(node.expression)) {
        return false;
      }
      const parent = path.getParentNode();
      return parent.type === "Program" && parent.body.length === 1;
    }
    function isGetterOrSetter(node) {
      return node.kind === "get" || node.kind === "set";
    }
    function isFunctionNotation(node) {
      return isGetterOrSetter(node) || hasSameLocStart(node, node.value);
    }
    function isObjectTypePropertyAFunction(node) {
      return (node.type === "ObjectTypeProperty" || node.type === "ObjectTypeInternalSlot") && node.value.type === "FunctionTypeAnnotation" && !node.static && !isFunctionNotation(node);
    }
    function isTypeAnnotationAFunction(node) {
      return (node.type === "TypeAnnotation" || node.type === "TSTypeAnnotation") && node.typeAnnotation.type === "FunctionTypeAnnotation" && !node.static && !hasSameLocStart(node, node.typeAnnotation);
    }
    var isBinaryish = createTypeCheckFunction(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
    function isMemberish(node) {
      return isMemberExpression(node) || node.type === "BindExpression" && Boolean(node.object);
    }
    var simpleTypeAnnotations = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
    function isSimpleType(node) {
      if (!node) {
        return false;
      }
      if ((node.type === "GenericTypeAnnotation" || node.type === "TSTypeReference") && !node.typeParameters) {
        return true;
      }
      if (simpleTypeAnnotations.has(node.type)) {
        return true;
      }
      return false;
    }
    function isUnitTestSetUp(node) {
      const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;
      return node.callee.type === "Identifier" && unitTestSetUpRe.test(node.callee.name) && node.arguments.length === 1;
    }
    var testCallCalleePatterns = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
    function isTestCallCallee(node) {
      return isNodeMatches(node, testCallCalleePatterns);
    }
    function isTestCall(node, parent) {
      if (node.type !== "CallExpression") {
        return false;
      }
      if (node.arguments.length === 1) {
        if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {
          return isFunctionOrArrowExpression(node.arguments[0]);
        }
        if (isUnitTestSetUp(node)) {
          return isAngularTestWrapper(node.arguments[0]);
        }
      } else if (node.arguments.length === 2 || node.arguments.length === 3) {
        if ((node.arguments[0].type === "TemplateLiteral" || isStringLiteral(node.arguments[0])) && isTestCallCallee(node.callee)) {
          if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {
            return false;
          }
          return (node.arguments.length === 2 ? isFunctionOrArrowExpression(node.arguments[1]) : isFunctionOrArrowExpressionWithBody(node.arguments[1]) && getFunctionParameters(node.arguments[1]).length <= 1) || isAngularTestWrapper(node.arguments[1]);
        }
      }
      return false;
    }
    var isCallExpression = createTypeCheckFunction(["CallExpression", "OptionalCallExpression"]);
    var isMemberExpression = createTypeCheckFunction(["MemberExpression", "OptionalMemberExpression"]);
    function isSimpleTemplateLiteral(node) {
      let expressionsKey = "expressions";
      if (node.type === "TSTemplateLiteralType") {
        expressionsKey = "types";
      }
      const expressions = node[expressionsKey];
      if (expressions.length === 0) {
        return false;
      }
      return expressions.every((expr) => {
        if (hasComment(expr)) {
          return false;
        }
        if (expr.type === "Identifier" || expr.type === "ThisExpression") {
          return true;
        }
        if (isMemberExpression(expr)) {
          let head = expr;
          while (isMemberExpression(head)) {
            if (head.property.type !== "Identifier" && head.property.type !== "Literal" && head.property.type !== "StringLiteral" && head.property.type !== "NumericLiteral") {
              return false;
            }
            head = head.object;
            if (hasComment(head)) {
              return false;
            }
          }
          if (head.type === "Identifier" || head.type === "ThisExpression") {
            return true;
          }
          return false;
        }
        return false;
      });
    }
    function getTypeScriptMappedTypeModifier(tokenNode, keyword) {
      if (tokenNode === "+" || tokenNode === "-") {
        return tokenNode + keyword;
      }
      return keyword;
    }
    function isFlowAnnotationComment(text, typeAnnotation) {
      const start = locStart(typeAnnotation);
      const end = skipWhitespace(text, locEnd(typeAnnotation));
      return end !== false && text.slice(start, start + 2) === "/*" && text.slice(end, end + 2) === "*/";
    }
    function hasLeadingOwnLineComment(text, node) {
      if (isJsxNode(node)) {
        return hasNodeIgnoreComment(node);
      }
      return hasComment(node, CommentCheckFlags.Leading, (comment) => hasNewline(text, locEnd(comment)));
    }
    function isStringPropSafeToUnquote(node, options) {
      return options.parser !== "json" && isStringLiteral(node.key) && rawText(node.key).slice(1, -1) === node.key.value && (isIdentifierName(node.key.value) && !(options.parser === "babel-ts" && node.type === "ClassProperty" || options.parser === "typescript" && node.type === "PropertyDefinition") || isSimpleNumber(node.key.value) && String(Number(node.key.value)) === node.key.value && (options.parser === "babel" || options.parser === "acorn" || options.parser === "espree" || options.parser === "meriyah" || options.parser === "__babel_estree"));
    }
    function isSimpleNumber(numberString) {
      return /^(?:\d+|\d+\.\d+)$/.test(numberString);
    }
    function isJestEachTemplateLiteral(node, parentNode) {
      const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;
      return parentNode.type === "TaggedTemplateExpression" && parentNode.quasi === node && parentNode.tag.type === "MemberExpression" && parentNode.tag.property.type === "Identifier" && parentNode.tag.property.name === "each" && (parentNode.tag.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === "MemberExpression" && parentNode.tag.object.property.type === "Identifier" && (parentNode.tag.object.property.name === "only" || parentNode.tag.object.property.name === "skip") && parentNode.tag.object.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));
    }
    function templateLiteralHasNewLines(template) {
      return template.quasis.some((quasi) => quasi.value.raw.includes("\n"));
    }
    function isTemplateOnItsOwnLine(node, text) {
      return (node.type === "TemplateLiteral" && templateLiteralHasNewLines(node) || node.type === "TaggedTemplateExpression" && templateLiteralHasNewLines(node.quasi)) && !hasNewline(text, locStart(node), {
        backwards: true
      });
    }
    function needsHardlineAfterDanglingComment(node) {
      if (!hasComment(node)) {
        return false;
      }
      const lastDanglingComment = getLast(getComments(node, CommentCheckFlags.Dangling));
      return lastDanglingComment && !isBlockComment(lastDanglingComment);
    }
    function isFunctionCompositionArgs(args) {
      if (args.length <= 1) {
        return false;
      }
      let count = 0;
      for (const arg of args) {
        if (isFunctionOrArrowExpression(arg)) {
          count += 1;
          if (count > 1) {
            return true;
          }
        } else if (isCallExpression(arg)) {
          for (const childArg of arg.arguments) {
            if (isFunctionOrArrowExpression(childArg)) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function isLongCurriedCallExpression(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      return isCallExpression(node) && isCallExpression(parent) && parent.callee === node && node.arguments.length > parent.arguments.length && parent.arguments.length > 0;
    }
    function isSimpleCallArgument(node, depth) {
      if (depth >= 2) {
        return false;
      }
      const isChildSimple = (child) => isSimpleCallArgument(child, depth + 1);
      const regexpPattern = node.type === "Literal" && "regex" in node && node.regex.pattern || node.type === "RegExpLiteral" && node.pattern;
      if (regexpPattern && getStringWidth(regexpPattern) > 5) {
        return false;
      }
      if (node.type === "Literal" || node.type === "BigIntLiteral" || node.type === "DecimalLiteral" || node.type === "BooleanLiteral" || node.type === "NullLiteral" || node.type === "NumericLiteral" || node.type === "RegExpLiteral" || node.type === "StringLiteral" || node.type === "Identifier" || node.type === "ThisExpression" || node.type === "Super" || node.type === "PrivateName" || node.type === "PrivateIdentifier" || node.type === "ArgumentPlaceholder" || node.type === "Import") {
        return true;
      }
      if (node.type === "TemplateLiteral") {
        return node.quasis.every((element) => !element.value.raw.includes("\n")) && node.expressions.every(isChildSimple);
      }
      if (node.type === "ObjectExpression") {
        return node.properties.every((p) => !p.computed && (p.shorthand || p.value && isChildSimple(p.value)));
      }
      if (node.type === "ArrayExpression") {
        return node.elements.every((x) => x === null || isChildSimple(x));
      }
      if (isCallLikeExpression(node)) {
        return (node.type === "ImportExpression" || isSimpleCallArgument(node.callee, depth)) && getCallArguments(node).every(isChildSimple);
      }
      if (isMemberExpression(node)) {
        return isSimpleCallArgument(node.object, depth) && isSimpleCallArgument(node.property, depth);
      }
      const targetUnaryExpressionOperators = {
        "!": true,
        "-": true,
        "+": true,
        "~": true
      };
      if (node.type === "UnaryExpression" && targetUnaryExpressionOperators[node.operator]) {
        return isSimpleCallArgument(node.argument, depth);
      }
      const targetUpdateExpressionOperators = {
        "++": true,
        "--": true
      };
      if (node.type === "UpdateExpression" && targetUpdateExpressionOperators[node.operator]) {
        return isSimpleCallArgument(node.argument, depth);
      }
      if (node.type === "TSNonNullExpression") {
        return isSimpleCallArgument(node.expression, depth);
      }
      return false;
    }
    function rawText(node) {
      var _node$extra$raw, _node$extra2;
      return (_node$extra$raw = (_node$extra2 = node.extra) === null || _node$extra2 === void 0 ? void 0 : _node$extra2.raw) !== null && _node$extra$raw !== void 0 ? _node$extra$raw : node.raw;
    }
    function identity(x) {
      return x;
    }
    function isTSXFile(options) {
      return options.filepath && /\.tsx$/i.test(options.filepath);
    }
    function shouldPrintComma(options, level = "es5") {
      return options.trailingComma === "es5" && level === "es5" || options.trailingComma === "all" && (level === "all" || level === "es5");
    }
    function startsWithNoLookaheadToken(node, predicate) {
      switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
        case "AssignmentExpression":
        case "NGPipeExpression":
          return startsWithNoLookaheadToken(node.left, predicate);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return startsWithNoLookaheadToken(node.object, predicate);
        case "TaggedTemplateExpression":
          if (node.tag.type === "FunctionExpression") {
            return false;
          }
          return startsWithNoLookaheadToken(node.tag, predicate);
        case "CallExpression":
        case "OptionalCallExpression":
          if (node.callee.type === "FunctionExpression") {
            return false;
          }
          return startsWithNoLookaheadToken(node.callee, predicate);
        case "ConditionalExpression":
          return startsWithNoLookaheadToken(node.test, predicate);
        case "UpdateExpression":
          return !node.prefix && startsWithNoLookaheadToken(node.argument, predicate);
        case "BindExpression":
          return node.object && startsWithNoLookaheadToken(node.object, predicate);
        case "SequenceExpression":
          return startsWithNoLookaheadToken(node.expressions[0], predicate);
        case "TSSatisfiesExpression":
        case "TSAsExpression":
        case "TSNonNullExpression":
          return startsWithNoLookaheadToken(node.expression, predicate);
        default:
          return predicate(node);
      }
    }
    var equalityOperators = {
      "==": true,
      "!=": true,
      "===": true,
      "!==": true
    };
    var multiplicativeOperators = {
      "*": true,
      "/": true,
      "%": true
    };
    var bitshiftOperators = {
      ">>": true,
      ">>>": true,
      "<<": true
    };
    function shouldFlatten(parentOp, nodeOp) {
      if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {
        return false;
      }
      if (parentOp === "**") {
        return false;
      }
      if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {
        return false;
      }
      if (nodeOp === "%" && multiplicativeOperators[parentOp] || parentOp === "%" && multiplicativeOperators[nodeOp]) {
        return false;
      }
      if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {
        return false;
      }
      if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {
        return false;
      }
      return true;
    }
    var PRECEDENCE = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((operators, index) => operators.map((operator) => [operator, index])));
    function getPrecedence(operator) {
      return PRECEDENCE.get(operator);
    }
    function isBitwiseOperator(operator) {
      return Boolean(bitshiftOperators[operator]) || operator === "|" || operator === "^" || operator === "&";
    }
    function hasRestParameter(node) {
      var _getLast;
      if (node.rest) {
        return true;
      }
      const parameters = getFunctionParameters(node);
      return ((_getLast = getLast(parameters)) === null || _getLast === void 0 ? void 0 : _getLast.type) === "RestElement";
    }
    var functionParametersCache = /* @__PURE__ */ new WeakMap();
    function getFunctionParameters(node) {
      if (functionParametersCache.has(node)) {
        return functionParametersCache.get(node);
      }
      const parameters = [];
      if (node.this) {
        parameters.push(node.this);
      }
      if (Array.isArray(node.parameters)) {
        parameters.push(...node.parameters);
      } else if (Array.isArray(node.params)) {
        parameters.push(...node.params);
      }
      if (node.rest) {
        parameters.push(node.rest);
      }
      functionParametersCache.set(node, parameters);
      return parameters;
    }
    function iterateFunctionParametersPath(path, iteratee) {
      const node = path.getValue();
      let index = 0;
      const callback = (childPath) => iteratee(childPath, index++);
      if (node.this) {
        path.call(callback, "this");
      }
      if (Array.isArray(node.parameters)) {
        path.each(callback, "parameters");
      } else if (Array.isArray(node.params)) {
        path.each(callback, "params");
      }
      if (node.rest) {
        path.call(callback, "rest");
      }
    }
    var callArgumentsCache = /* @__PURE__ */ new WeakMap();
    function getCallArguments(node) {
      if (callArgumentsCache.has(node)) {
        return callArgumentsCache.get(node);
      }
      let args = node.arguments;
      if (node.type === "ImportExpression") {
        args = [node.source];
        if (node.attributes) {
          args.push(node.attributes);
        }
      }
      callArgumentsCache.set(node, args);
      return args;
    }
    function iterateCallArgumentsPath(path, iteratee) {
      const node = path.getValue();
      if (node.type === "ImportExpression") {
        path.call((sourcePath) => iteratee(sourcePath, 0), "source");
        if (node.attributes) {
          path.call((sourcePath) => iteratee(sourcePath, 1), "attributes");
        }
      } else {
        path.each(iteratee, "arguments");
      }
    }
    function isPrettierIgnoreComment(comment) {
      return comment.value.trim() === "prettier-ignore" && !comment.unignore;
    }
    function hasNodeIgnoreComment(node) {
      return node && (node.prettierIgnore || hasComment(node, CommentCheckFlags.PrettierIgnore));
    }
    function hasIgnoreComment(path) {
      const node = path.getValue();
      return hasNodeIgnoreComment(node);
    }
    var CommentCheckFlags = {
      Leading: 1 << 1,
      Trailing: 1 << 2,
      Dangling: 1 << 3,
      Block: 1 << 4,
      Line: 1 << 5,
      PrettierIgnore: 1 << 6,
      First: 1 << 7,
      Last: 1 << 8
    };
    var getCommentTestFunction = (flags, fn) => {
      if (typeof flags === "function") {
        fn = flags;
        flags = 0;
      }
      if (flags || fn) {
        return (comment, index, comments) => !(flags & CommentCheckFlags.Leading && !comment.leading || flags & CommentCheckFlags.Trailing && !comment.trailing || flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing) || flags & CommentCheckFlags.Block && !isBlockComment(comment) || flags & CommentCheckFlags.Line && !isLineComment(comment) || flags & CommentCheckFlags.First && index !== 0 || flags & CommentCheckFlags.Last && index !== comments.length - 1 || flags & CommentCheckFlags.PrettierIgnore && !isPrettierIgnoreComment(comment) || fn && !fn(comment));
      }
    };
    function hasComment(node, flags, fn) {
      if (!isNonEmptyArray(node === null || node === void 0 ? void 0 : node.comments)) {
        return false;
      }
      const test = getCommentTestFunction(flags, fn);
      return test ? node.comments.some(test) : true;
    }
    function getComments(node, flags, fn) {
      if (!Array.isArray(node === null || node === void 0 ? void 0 : node.comments)) {
        return [];
      }
      const test = getCommentTestFunction(flags, fn);
      return test ? node.comments.filter(test) : node.comments;
    }
    var isNextLineEmpty = (node, {
      originalText
    }) => isNextLineEmptyAfterIndex(originalText, locEnd(node));
    function isCallLikeExpression(node) {
      return isCallExpression(node) || node.type === "NewExpression" || node.type === "ImportExpression";
    }
    function isObjectProperty(node) {
      return node && (node.type === "ObjectProperty" || node.type === "Property" && !node.method && node.kind === "init");
    }
    function isEnabledHackPipeline(options) {
      return Boolean(options.__isUsingHackPipeline);
    }
    var markerForIfWithoutBlockAndSameLineComment = Symbol("ifWithoutBlockAndSameLineComment");
    function isTSTypeExpression(node) {
      return node.type === "TSAsExpression" || node.type === "TSSatisfiesExpression";
    }
    module2.exports = {
      getFunctionParameters,
      iterateFunctionParametersPath,
      getCallArguments,
      iterateCallArgumentsPath,
      hasRestParameter,
      getLeftSide,
      getLeftSidePathName,
      getParentExportDeclaration,
      getTypeScriptMappedTypeModifier,
      hasFlowAnnotationComment,
      hasFlowShorthandAnnotationComment,
      hasLeadingOwnLineComment,
      hasNakedLeftSide,
      hasNode,
      hasIgnoreComment,
      hasNodeIgnoreComment,
      identity,
      isBinaryish,
      isCallLikeExpression,
      isEnabledHackPipeline,
      isLineComment,
      isPrettierIgnoreComment,
      isCallExpression,
      isMemberExpression,
      isExportDeclaration,
      isFlowAnnotationComment,
      isFunctionCompositionArgs,
      isFunctionNotation,
      isFunctionOrArrowExpression,
      isGetterOrSetter,
      isJestEachTemplateLiteral,
      isJsxNode,
      isLiteral,
      isLongCurriedCallExpression,
      isSimpleCallArgument,
      isMemberish,
      isNumericLiteral,
      isSignedNumericLiteral,
      isObjectProperty,
      isObjectType,
      isObjectTypePropertyAFunction,
      isSimpleType,
      isSimpleNumber,
      isSimpleTemplateLiteral,
      isStringLiteral,
      isStringPropSafeToUnquote,
      isTemplateOnItsOwnLine,
      isTestCall,
      isTheOnlyJsxElementInMarkdown,
      isTSXFile,
      isTypeAnnotationAFunction,
      isNextLineEmpty,
      needsHardlineAfterDanglingComment,
      rawText,
      shouldPrintComma,
      isBitwiseOperator,
      shouldFlatten,
      startsWithNoLookaheadToken,
      getPrecedence,
      hasComment,
      getComments,
      CommentCheckFlags,
      markerForIfWithoutBlockAndSameLineComment,
      isTSTypeExpression
    };
  }
});
var require_template_literal = __commonJS2({
  "src/language-js/print/template-literal.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    var {
      getStringWidth,
      getIndentSize
    } = require_util();
    var {
      builders: {
        join,
        hardline,
        softline,
        group,
        indent,
        align,
        lineSuffixBoundary,
        addAlignmentToDoc
      },
      printer: {
        printDocToString
      },
      utils: {
        mapDoc
      }
    } = require("./doc.js");
    var {
      isBinaryish,
      isJestEachTemplateLiteral,
      isSimpleTemplateLiteral,
      hasComment,
      isMemberExpression,
      isTSTypeExpression
    } = require_utils7();
    function printTemplateLiteral(path, print, options) {
      const node = path.getValue();
      const isTemplateLiteral = node.type === "TemplateLiteral";
      if (isTemplateLiteral && isJestEachTemplateLiteral(node, path.getParentNode())) {
        const printed = printJestEachTemplateLiteral(path, options, print);
        if (printed) {
          return printed;
        }
      }
      let expressionsKey = "expressions";
      if (node.type === "TSTemplateLiteralType") {
        expressionsKey = "types";
      }
      const parts = [];
      let expressions = path.map(print, expressionsKey);
      const isSimple = isSimpleTemplateLiteral(node);
      if (isSimple) {
        expressions = expressions.map((doc2) => printDocToString(doc2, Object.assign(Object.assign({}, options), {}, {
          printWidth: Number.POSITIVE_INFINITY
        })).formatted);
      }
      parts.push(lineSuffixBoundary, "`");
      path.each((childPath) => {
        const i = childPath.getName();
        parts.push(print());
        if (i < expressions.length) {
          const {
            tabWidth
          } = options;
          const quasi = childPath.getValue();
          const indentSize = getIndentSize(quasi.value.raw, tabWidth);
          let printed = expressions[i];
          if (!isSimple) {
            const expression = node[expressionsKey][i];
            if (hasComment(expression) || isMemberExpression(expression) || expression.type === "ConditionalExpression" || expression.type === "SequenceExpression" || isTSTypeExpression(expression) || isBinaryish(expression)) {
              printed = [indent([softline, printed]), softline];
            }
          }
          const aligned = indentSize === 0 && quasi.value.raw.endsWith("\n") ? align(Number.NEGATIVE_INFINITY, printed) : addAlignmentToDoc(printed, indentSize, tabWidth);
          parts.push(group(["${", aligned, lineSuffixBoundary, "}"]));
        }
      }, "quasis");
      parts.push("`");
      return parts;
    }
    function printJestEachTemplateLiteral(path, options, print) {
      const node = path.getNode();
      const headerNames = node.quasis[0].value.raw.trim().split(/\s*\|\s*/);
      if (headerNames.length > 1 || headerNames.some((headerName) => headerName.length > 0)) {
        options.__inJestEach = true;
        const expressions = path.map(print, "expressions");
        options.__inJestEach = false;
        const parts = [];
        const stringifiedExpressions = expressions.map((doc2) => "${" + printDocToString(doc2, Object.assign(Object.assign({}, options), {}, {
          printWidth: Number.POSITIVE_INFINITY,
          endOfLine: "lf"
        })).formatted + "}");
        const tableBody = [{
          hasLineBreak: false,
          cells: []
        }];
        for (let i = 1; i < node.quasis.length; i++) {
          const row = getLast(tableBody);
          const correspondingExpression = stringifiedExpressions[i - 1];
          row.cells.push(correspondingExpression);
          if (correspondingExpression.includes("\n")) {
            row.hasLineBreak = true;
          }
          if (node.quasis[i].value.raw.includes("\n")) {
            tableBody.push({
              hasLineBreak: false,
              cells: []
            });
          }
        }
        const maxColumnCount = Math.max(headerNames.length, ...tableBody.map((row) => row.cells.length));
        const maxColumnWidths = Array.from({
          length: maxColumnCount
        }).fill(0);
        const table = [{
          cells: headerNames
        }, ...tableBody.filter((row) => row.cells.length > 0)];
        for (const {
          cells
        } of table.filter((row) => !row.hasLineBreak)) {
          for (const [index, cell] of cells.entries()) {
            maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));
          }
        }
        parts.push(lineSuffixBoundary, "`", indent([hardline, join(hardline, table.map((row) => join(" | ", row.cells.map((cell, index) => row.hasLineBreak ? cell : cell + " ".repeat(maxColumnWidths[index] - getStringWidth(cell))))))]), hardline, "`");
        return parts;
      }
    }
    function printTemplateExpression(path, print) {
      const node = path.getValue();
      let printed = print();
      if (hasComment(node)) {
        printed = group([indent([softline, printed]), softline]);
      }
      return ["${", printed, lineSuffixBoundary, "}"];
    }
    function printTemplateExpressions(path, print) {
      return path.map((path2) => printTemplateExpression(path2, print), "expressions");
    }
    function escapeTemplateCharacters(doc2, raw) {
      return mapDoc(doc2, (currentDoc) => {
        if (typeof currentDoc === "string") {
          return raw ? currentDoc.replace(/(\\*)`/g, "$1$1\\`") : uncookTemplateElementValue(currentDoc);
        }
        return currentDoc;
      });
    }
    function uncookTemplateElementValue(cookedValue) {
      return cookedValue.replace(/([\\`]|\${)/g, "\\$1");
    }
    module2.exports = {
      printTemplateLiteral,
      printTemplateExpressions,
      escapeTemplateCharacters,
      uncookTemplateElementValue
    };
  }
});
var require_markdown = __commonJS2({
  "src/language-js/embed/markdown.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        indent,
        softline,
        literalline,
        dedentToRoot
      }
    } = require("./doc.js");
    var {
      escapeTemplateCharacters
    } = require_template_literal();
    function format(path, print, textToDoc) {
      const node = path.getValue();
      let text = node.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (_, backslashes) => "\\".repeat(backslashes.length / 2) + "`");
      const indentation = getIndentation(text);
      const hasIndent = indentation !== "";
      if (hasIndent) {
        text = text.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      const doc2 = escapeTemplateCharacters(textToDoc(text, {
        parser: "markdown",
        __inJsTemplate: true
      }, {
        stripTrailingHardline: true
      }), true);
      return ["`", hasIndent ? indent([softline, doc2]) : [literalline, dedentToRoot(doc2)], softline, "`"];
    }
    function getIndentation(str) {
      const firstMatchedIndent = str.match(/^([^\S\n]*)\S/m);
      return firstMatchedIndent === null ? "" : firstMatchedIndent[1];
    }
    module2.exports = format;
  }
});
var require_css = __commonJS2({
  "src/language-js/embed/css.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        indent,
        hardline,
        softline
      },
      utils: {
        mapDoc,
        replaceEndOfLine,
        cleanDoc
      }
    } = require("./doc.js");
    var {
      printTemplateExpressions
    } = require_template_literal();
    function format(path, print, textToDoc) {
      const node = path.getValue();
      const rawQuasis = node.quasis.map((q) => q.value.raw);
      let placeholderID = 0;
      const text = rawQuasis.reduce((prevVal, currVal, idx) => idx === 0 ? currVal : prevVal + "@prettier-placeholder-" + placeholderID++ + "-id" + currVal, "");
      const doc2 = textToDoc(text, {
        parser: "scss"
      }, {
        stripTrailingHardline: true
      });
      const expressionDocs = printTemplateExpressions(path, print);
      return transformCssDoc(doc2, node, expressionDocs);
    }
    function transformCssDoc(quasisDoc, parentNode, expressionDocs) {
      const isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();
      if (isEmpty) {
        return "``";
      }
      const newDoc = replacePlaceholders(quasisDoc, expressionDocs);
      if (!newDoc) {
        throw new Error("Couldn't insert all the expressions");
      }
      return ["`", indent([hardline, newDoc]), softline, "`"];
    }
    function replacePlaceholders(quasisDoc, expressionDocs) {
      if (!isNonEmptyArray(expressionDocs)) {
        return quasisDoc;
      }
      let replaceCounter = 0;
      const newDoc = mapDoc(cleanDoc(quasisDoc), (doc2) => {
        if (typeof doc2 !== "string" || !doc2.includes("@prettier-placeholder")) {
          return doc2;
        }
        return doc2.split(/@prettier-placeholder-(\d+)-id/).map((component, idx) => {
          if (idx % 2 === 0) {
            return replaceEndOfLine(component);
          }
          replaceCounter++;
          return expressionDocs[component];
        });
      });
      return expressionDocs.length === replaceCounter ? newDoc : null;
    }
    module2.exports = format;
  }
});
var require_graphql = __commonJS2({
  "src/language-js/embed/graphql.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        indent,
        join,
        hardline
      }
    } = require("./doc.js");
    var {
      escapeTemplateCharacters,
      printTemplateExpressions
    } = require_template_literal();
    function format(path, print, textToDoc) {
      const node = path.getValue();
      const numQuasis = node.quasis.length;
      if (numQuasis === 1 && node.quasis[0].value.raw.trim() === "") {
        return "``";
      }
      const expressionDocs = printTemplateExpressions(path, print);
      const parts = [];
      for (let i = 0; i < numQuasis; i++) {
        const templateElement = node.quasis[i];
        const isFirst = i === 0;
        const isLast = i === numQuasis - 1;
        const text = templateElement.value.cooked;
        const lines = text.split("\n");
        const numLines = lines.length;
        const expressionDoc = expressionDocs[i];
        const startsWithBlankLine = numLines > 2 && lines[0].trim() === "" && lines[1].trim() === "";
        const endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === "" && lines[numLines - 2].trim() === "";
        const commentsAndWhitespaceOnly = lines.every((line) => /^\s*(?:#[^\n\r]*)?$/.test(line));
        if (!isLast && /#[^\n\r]*$/.test(lines[numLines - 1])) {
          return null;
        }
        let doc2 = null;
        if (commentsAndWhitespaceOnly) {
          doc2 = printGraphqlComments(lines);
        } else {
          doc2 = textToDoc(text, {
            parser: "graphql"
          }, {
            stripTrailingHardline: true
          });
        }
        if (doc2) {
          doc2 = escapeTemplateCharacters(doc2, false);
          if (!isFirst && startsWithBlankLine) {
            parts.push("");
          }
          parts.push(doc2);
          if (!isLast && endsWithBlankLine) {
            parts.push("");
          }
        } else if (!isFirst && !isLast && startsWithBlankLine) {
          parts.push("");
        }
        if (expressionDoc) {
          parts.push(expressionDoc);
        }
      }
      return ["`", indent([hardline, join(hardline, parts)]), hardline, "`"];
    }
    function printGraphqlComments(lines) {
      const parts = [];
      let seenComment = false;
      const array = lines.map((textLine) => textLine.trim());
      for (const [i, textLine] of array.entries()) {
        if (textLine === "") {
          continue;
        }
        if (array[i - 1] === "" && seenComment) {
          parts.push([hardline, textLine]);
        } else {
          parts.push(textLine);
        }
        seenComment = true;
      }
      return parts.length === 0 ? null : join(hardline, parts);
    }
    module2.exports = format;
  }
});
var require_html = __commonJS2({
  "src/language-js/embed/html.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        indent,
        line,
        hardline,
        group
      },
      utils: {
        mapDoc
      }
    } = require("./doc.js");
    var {
      printTemplateExpressions,
      uncookTemplateElementValue
    } = require_template_literal();
    var htmlTemplateLiteralCounter = 0;
    function format(path, print, textToDoc, options, {
      parser
    }) {
      const node = path.getValue();
      const counter = htmlTemplateLiteralCounter;
      htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;
      const composePlaceholder = (index) => `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;
      const text = node.quasis.map((quasi, index, quasis) => index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index)).join("");
      const expressionDocs = printTemplateExpressions(path, print);
      if (expressionDocs.length === 0 && text.trim().length === 0) {
        return "``";
      }
      const placeholderRegex = new RegExp(composePlaceholder("(\\d+)"), "g");
      let topLevelCount = 0;
      const doc2 = textToDoc(text, {
        parser,
        __onHtmlRoot(root) {
          topLevelCount = root.children.length;
        }
      }, {
        stripTrailingHardline: true
      });
      const contentDoc = mapDoc(doc2, (doc3) => {
        if (typeof doc3 !== "string") {
          return doc3;
        }
        const parts = [];
        const components = doc3.split(placeholderRegex);
        for (let i = 0; i < components.length; i++) {
          let component = components[i];
          if (i % 2 === 0) {
            if (component) {
              component = uncookTemplateElementValue(component);
              if (options.__embeddedInHtml) {
                component = component.replace(/<\/(script)\b/gi, "<\\/$1");
              }
              parts.push(component);
            }
            continue;
          }
          const placeholderIndex = Number(component);
          parts.push(expressionDocs[placeholderIndex]);
        }
        return parts;
      });
      const leadingWhitespace = /^\s/.test(text) ? " " : "";
      const trailingWhitespace = /\s$/.test(text) ? " " : "";
      const linebreak = options.htmlWhitespaceSensitivity === "ignore" ? hardline : leadingWhitespace && trailingWhitespace ? line : null;
      if (linebreak) {
        return group(["`", indent([linebreak, group(contentDoc)]), linebreak, "`"]);
      }
      return group(["`", leadingWhitespace, topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc), trailingWhitespace, "`"]);
    }
    module2.exports = format;
  }
});
var require_embed = __commonJS2({
  "src/language-js/embed.js"(exports2, module2) {
    "use strict";
    var {
      hasComment,
      CommentCheckFlags,
      isObjectProperty
    } = require_utils7();
    var formatMarkdown = require_markdown();
    var formatCss = require_css();
    var formatGraphql = require_graphql();
    var formatHtml = require_html();
    function getLanguage(path) {
      if (isStyledJsx(path) || isStyledComponents(path) || isCssProp(path) || isAngularComponentStyles(path)) {
        return "css";
      }
      if (isGraphQL(path)) {
        return "graphql";
      }
      if (isHtml(path)) {
        return "html";
      }
      if (isAngularComponentTemplate(path)) {
        return "angular";
      }
      if (isMarkdown(path)) {
        return "markdown";
      }
    }
    function embed(path, print, textToDoc, options) {
      const node = path.getValue();
      if (node.type !== "TemplateLiteral" || hasInvalidCookedValue(node)) {
        return;
      }
      const language = getLanguage(path);
      if (!language) {
        return;
      }
      if (language === "markdown") {
        return formatMarkdown(path, print, textToDoc);
      }
      if (language === "css") {
        return formatCss(path, print, textToDoc);
      }
      if (language === "graphql") {
        return formatGraphql(path, print, textToDoc);
      }
      if (language === "html" || language === "angular") {
        return formatHtml(path, print, textToDoc, options, {
          parser: language
        });
      }
    }
    function isMarkdown(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      return parent && parent.type === "TaggedTemplateExpression" && node.quasis.length === 1 && parent.tag.type === "Identifier" && (parent.tag.name === "md" || parent.tag.name === "markdown");
    }
    function isStyledJsx(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      const parentParent = path.getParentNode(1);
      return parentParent && node.quasis && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXElement" && parentParent.openingElement.name.name === "style" && parentParent.openingElement.attributes.some((attribute) => attribute.name.name === "jsx") || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "Identifier" && parent.tag.name === "css" || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "MemberExpression" && parent.tag.object.name === "css" && (parent.tag.property.name === "global" || parent.tag.property.name === "resolve");
    }
    function isAngularComponentStyles(path) {
      return path.match((node) => node.type === "TemplateLiteral", (node, name) => node.type === "ArrayExpression" && name === "elements", (node, name) => isObjectProperty(node) && node.key.type === "Identifier" && node.key.name === "styles" && name === "value", ...angularComponentObjectExpressionPredicates);
    }
    function isAngularComponentTemplate(path) {
      return path.match((node) => node.type === "TemplateLiteral", (node, name) => isObjectProperty(node) && node.key.type === "Identifier" && node.key.name === "template" && name === "value", ...angularComponentObjectExpressionPredicates);
    }
    var angularComponentObjectExpressionPredicates = [(node, name) => node.type === "ObjectExpression" && name === "properties", (node, name) => node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "Component" && name === "arguments", (node, name) => node.type === "Decorator" && name === "expression"];
    function isStyledComponents(path) {
      const parent = path.getParentNode();
      if (!parent || parent.type !== "TaggedTemplateExpression") {
        return false;
      }
      const tag = parent.tag.type === "ParenthesizedExpression" ? parent.tag.expression : parent.tag;
      switch (tag.type) {
        case "MemberExpression":
          return isStyledIdentifier(tag.object) || isStyledExtend(tag);
        case "CallExpression":
          return isStyledIdentifier(tag.callee) || tag.callee.type === "MemberExpression" && (tag.callee.object.type === "MemberExpression" && (isStyledIdentifier(tag.callee.object.object) || isStyledExtend(tag.callee.object)) || tag.callee.object.type === "CallExpression" && isStyledIdentifier(tag.callee.object.callee));
        case "Identifier":
          return tag.name === "css";
        default:
          return false;
      }
    }
    function isCssProp(path) {
      const parent = path.getParentNode();
      const parentParent = path.getParentNode(1);
      return parentParent && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" && parentParent.name.type === "JSXIdentifier" && parentParent.name.name === "css";
    }
    function isStyledIdentifier(node) {
      return node.type === "Identifier" && node.name === "styled";
    }
    function isStyledExtend(node) {
      return /^[A-Z]/.test(node.object.name) && node.property.name === "extend";
    }
    function isGraphQL(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      return hasLanguageComment(node, "GraphQL") || parent && (parent.type === "TaggedTemplateExpression" && (parent.tag.type === "MemberExpression" && parent.tag.object.name === "graphql" && parent.tag.property.name === "experimental" || parent.tag.type === "Identifier" && (parent.tag.name === "gql" || parent.tag.name === "graphql")) || parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "graphql");
    }
    function hasLanguageComment(node, languageName) {
      return hasComment(node, CommentCheckFlags.Block | CommentCheckFlags.Leading, ({
        value
      }) => value === ` ${languageName} `);
    }
    function isHtml(path) {
      return hasLanguageComment(path.getValue(), "HTML") || path.match((node) => node.type === "TemplateLiteral", (node, name) => node.type === "TaggedTemplateExpression" && node.tag.type === "Identifier" && node.tag.name === "html" && name === "quasi");
    }
    function hasInvalidCookedValue({
      quasis
    }) {
      return quasis.some(({
        value: {
          cooked
        }
      }) => cooked === null);
    }
    module2.exports = embed;
  }
});
var require_clean = __commonJS2({
  "src/language-js/clean.js"(exports2, module2) {
    "use strict";
    var isBlockComment = require_is_block_comment();
    var ignoredProperties = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]);
    var removeTemplateElementsValue = (node) => {
      for (const templateElement of node.quasis) {
        delete templateElement.value;
      }
    };
    function clean(ast, newObj, parent) {
      if (ast.type === "Program") {
        delete newObj.sourceType;
      }
      if (ast.type === "BigIntLiteral" || ast.type === "BigIntLiteralTypeAnnotation") {
        if (newObj.value) {
          newObj.value = newObj.value.toLowerCase();
        }
      }
      if (ast.type === "BigIntLiteral" || ast.type === "Literal") {
        if (newObj.bigint) {
          newObj.bigint = newObj.bigint.toLowerCase();
        }
      }
      if (ast.type === "DecimalLiteral") {
        newObj.value = Number(newObj.value);
      }
      if (ast.type === "Literal" && newObj.decimal) {
        newObj.decimal = Number(newObj.decimal);
      }
      if (ast.type === "EmptyStatement") {
        return null;
      }
      if (ast.type === "JSXText") {
        return null;
      }
      if (ast.type === "JSXExpressionContainer" && (ast.expression.type === "Literal" || ast.expression.type === "StringLiteral") && ast.expression.value === " ") {
        return null;
      }
      if ((ast.type === "Property" || ast.type === "ObjectProperty" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "ClassMethod" || ast.type === "PropertyDefinition" || ast.type === "TSDeclareMethod" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && typeof ast.key === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "NumericLiteral" || ast.key.type === "StringLiteral" || ast.key.type === "Identifier")) {
        delete newObj.key;
      }
      if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some((attr) => attr.name.name === "jsx")) {
        for (const {
          type,
          expression: expression2
        } of newObj.children) {
          if (type === "JSXExpressionContainer" && expression2.type === "TemplateLiteral") {
            removeTemplateElementsValue(expression2);
          }
        }
      }
      if (ast.type === "JSXAttribute" && ast.name.name === "css" && ast.value.type === "JSXExpressionContainer" && ast.value.expression.type === "TemplateLiteral") {
        removeTemplateElementsValue(newObj.value.expression);
      }
      if (ast.type === "JSXAttribute" && ast.value && ast.value.type === "Literal" && /["']|&quot;|&apos;/.test(ast.value.value)) {
        newObj.value.value = newObj.value.value.replace(/["']|&quot;|&apos;/g, '"');
      }
      const expression = ast.expression || ast.callee;
      if (ast.type === "Decorator" && expression.type === "CallExpression" && expression.callee.name === "Component" && expression.arguments.length === 1) {
        const astProps = ast.expression.arguments[0].properties;
        for (const [index, prop] of newObj.expression.arguments[0].properties.entries()) {
          switch (astProps[index].key.name) {
            case "styles":
              if (prop.value.type === "ArrayExpression") {
                removeTemplateElementsValue(prop.value.elements[0]);
              }
              break;
            case "template":
              if (prop.value.type === "TemplateLiteral") {
                removeTemplateElementsValue(prop.value);
              }
              break;
          }
        }
      }
      if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css" || ast.tag.name === "md" || ast.tag.name === "markdown" || ast.tag.name === "html") || ast.tag.type === "CallExpression")) {
        removeTemplateElementsValue(newObj.quasi);
      }
      if (ast.type === "TemplateLiteral") {
        var _ast$leadingComments;
        const hasLanguageComment = (_ast$leadingComments = ast.leadingComments) === null || _ast$leadingComments === void 0 ? void 0 : _ast$leadingComments.some((comment) => isBlockComment(comment) && ["GraphQL", "HTML"].some((languageName) => comment.value === ` ${languageName} `));
        if (hasLanguageComment || parent.type === "CallExpression" && parent.callee.name === "graphql" || !ast.leadingComments) {
          removeTemplateElementsValue(newObj);
        }
      }
      if (ast.type === "InterpreterDirective") {
        newObj.value = newObj.value.trimEnd();
      }
      if ((ast.type === "TSIntersectionType" || ast.type === "TSUnionType") && ast.types.length === 1) {
        return newObj.types[0];
      }
    }
    clean.ignoredProperties = ignoredProperties;
    module2.exports = clean;
  }
});
var require_detect_newline = __commonJS2({
  "node_modules/detect-newline/index.js"(exports2, module2) {
    "use strict";
    var detectNewline = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      const newlines = string.match(/(?:\r?\n)/g) || [];
      if (newlines.length === 0) {
        return;
      }
      const crlf = newlines.filter((newline) => newline === "\r\n").length;
      const lf = newlines.length - crlf;
      return crlf > lf ? "\r\n" : "\n";
    };
    module2.exports = detectNewline;
    module2.exports.graceful = (string) => typeof string === "string" && detectNewline(string) || "\n";
  }
});
var require_build = __commonJS2({
  "node_modules/jest-docblock/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extract = extract;
    exports2.parse = parse;
    exports2.parseWithComments = parseWithComments;
    exports2.print = print;
    exports2.strip = strip;
    function _os() {
      const data = require("os");
      _os = function() {
        return data;
      };
      return data;
    }
    function _detectNewline() {
      const data = _interopRequireDefault(require_detect_newline());
      _detectNewline = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var commentEndRe = /\*\/$/;
    var commentStartRe = /^\/\*\*?/;
    var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
    var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
    var ltrimNewlineRe = /^(\r?\n)+/;
    var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
    var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
    var stringStartRe = /(\r?\n|^) *\* ?/g;
    var STRING_ARRAY = [];
    function extract(contents) {
      const match = contents.match(docblockRe);
      return match ? match[0].trimLeft() : "";
    }
    function strip(contents) {
      const match = contents.match(docblockRe);
      return match && match[0] ? contents.substring(match[0].length) : contents;
    }
    function parse(docblock) {
      return parseWithComments(docblock).pragmas;
    }
    function parseWithComments(docblock) {
      const line = (0, _detectNewline().default)(docblock) || _os().EOL;
      docblock = docblock.replace(commentStartRe, "").replace(commentEndRe, "").replace(stringStartRe, "$1");
      let prev = "";
      while (prev !== docblock) {
        prev = docblock;
        docblock = docblock.replace(multilineRe, `${line}$1 $2${line}`);
      }
      docblock = docblock.replace(ltrimNewlineRe, "").trimRight();
      const result = /* @__PURE__ */ Object.create(null);
      const comments = docblock.replace(propertyRe, "").replace(ltrimNewlineRe, "").trimRight();
      let match;
      while (match = propertyRe.exec(docblock)) {
        const nextPragma = match[2].replace(lineCommentRe, "");
        if (typeof result[match[1]] === "string" || Array.isArray(result[match[1]])) {
          result[match[1]] = STRING_ARRAY.concat(result[match[1]], nextPragma);
        } else {
          result[match[1]] = nextPragma;
        }
      }
      return {
        comments,
        pragmas: result
      };
    }
    function print({
      comments = "",
      pragmas = {}
    }) {
      const line = (0, _detectNewline().default)(comments) || _os().EOL;
      const head = "/**";
      const start = " *";
      const tail = " */";
      const keys = Object.keys(pragmas);
      const printedObject = keys.map((key) => printKeyValues(key, pragmas[key])).reduce((arr, next) => arr.concat(next), []).map((keyValue) => `${start} ${keyValue}${line}`).join("");
      if (!comments) {
        if (keys.length === 0) {
          return "";
        }
        if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {
          const value = pragmas[keys[0]];
          return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;
        }
      }
      const printedComments = comments.split(line).map((textLine) => `${start} ${textLine}`).join(line) + line;
      return head + line + (comments ? printedComments : "") + (comments && keys.length ? start + line : "") + printedObject + tail;
    }
    function printKeyValues(key, valueOrArray) {
      return STRING_ARRAY.concat(valueOrArray).map((value) => `@${key} ${value}`.trim());
    }
  }
});
var require_get_shebang = __commonJS2({
  "src/language-js/utils/get-shebang.js"(exports2, module2) {
    "use strict";
    function getShebang(text) {
      if (!text.startsWith("#!")) {
        return "";
      }
      const index = text.indexOf("\n");
      if (index === -1) {
        return text;
      }
      return text.slice(0, index);
    }
    module2.exports = getShebang;
  }
});
var require_pragma = __commonJS2({
  "src/language-js/pragma.js"(exports2, module2) {
    "use strict";
    var {
      parseWithComments,
      strip,
      extract,
      print
    } = require_build();
    var {
      normalizeEndOfLine
    } = require_end_of_line();
    var getShebang = require_get_shebang();
    function parseDocBlock(text) {
      const shebang = getShebang(text);
      if (shebang) {
        text = text.slice(shebang.length + 1);
      }
      const docBlock = extract(text);
      const {
        pragmas,
        comments
      } = parseWithComments(docBlock);
      return {
        shebang,
        text,
        pragmas,
        comments
      };
    }
    function hasPragma(text) {
      const pragmas = Object.keys(parseDocBlock(text).pragmas);
      return pragmas.includes("prettier") || pragmas.includes("format");
    }
    function insertPragma(originalText) {
      const {
        shebang,
        text,
        pragmas,
        comments
      } = parseDocBlock(originalText);
      const strippedText = strip(text);
      const docBlock = print({
        pragmas: Object.assign({
          format: ""
        }, pragmas),
        comments: comments.trimStart()
      });
      return (shebang ? `${shebang}
` : "") + normalizeEndOfLine(docBlock) + (strippedText.startsWith("\n") ? "\n" : "\n\n") + strippedText;
    }
    module2.exports = {
      hasPragma,
      insertPragma
    };
  }
});
var require_is_type_cast_comment = __commonJS2({
  "src/language-js/utils/is-type-cast-comment.js"(exports2, module2) {
    "use strict";
    var isBlockComment = require_is_block_comment();
    function isTypeCastComment(comment) {
      return isBlockComment(comment) && comment.value[0] === "*" && /@(?:type|satisfies)\b/.test(comment.value);
    }
    module2.exports = isTypeCastComment;
  }
});
var require_comments2 = __commonJS2({
  "src/language-js/comments.js"(exports2, module2) {
    "use strict";
    var {
      getLast,
      hasNewline,
      getNextNonSpaceNonCommentCharacterIndexWithStartIndex,
      getNextNonSpaceNonCommentCharacter,
      hasNewlineInRange,
      addLeadingComment,
      addTrailingComment,
      addDanglingComment,
      getNextNonSpaceNonCommentCharacterIndex,
      isNonEmptyArray
    } = require_util();
    var {
      getFunctionParameters,
      isPrettierIgnoreComment,
      isJsxNode,
      hasFlowShorthandAnnotationComment,
      hasFlowAnnotationComment,
      hasIgnoreComment,
      isCallLikeExpression,
      getCallArguments,
      isCallExpression,
      isMemberExpression,
      isObjectProperty,
      isLineComment,
      getComments,
      CommentCheckFlags,
      markerForIfWithoutBlockAndSameLineComment
    } = require_utils7();
    var {
      locStart,
      locEnd
    } = require_loc();
    var isBlockComment = require_is_block_comment();
    var isTypeCastComment = require_is_type_cast_comment();
    function handleOwnLineComment(context) {
      return [handleIgnoreComments, handleLastFunctionArgComments, handleMemberExpressionComments, handleIfStatementComments, handleWhileComments, handleTryStatementComments, handleClassComments, handleForComments, handleUnionTypeComments, handleOnlyComments, handleModuleSpecifiersComments, handleAssignmentPatternComments, handleMethodNameComments, handleLabeledStatementComments, handleBreakAndContinueStatementComments].some((fn) => fn(context));
    }
    function handleEndOfLineComment(context) {
      return [handleClosureTypeCastComments, handleLastFunctionArgComments, handleConditionalExpressionComments, handleModuleSpecifiersComments, handleIfStatementComments, handleWhileComments, handleTryStatementComments, handleClassComments, handleLabeledStatementComments, handleCallExpressionComments, handlePropertyComments, handleOnlyComments, handleVariableDeclaratorComments, handleBreakAndContinueStatementComments, handleSwitchDefaultCaseComments].some((fn) => fn(context));
    }
    function handleRemainingComment(context) {
      return [handleIgnoreComments, handleIfStatementComments, handleWhileComments, handleObjectPropertyAssignment, handleCommentInEmptyParens, handleMethodNameComments, handleOnlyComments, handleCommentAfterArrowParams, handleFunctionNameComments, handleTSMappedTypeComments, handleBreakAndContinueStatementComments, handleTSFunctionTrailingComments].some((fn) => fn(context));
    }
    function addBlockStatementFirstComment(node, comment) {
      const firstNonEmptyNode = (node.body || node.properties).find(({
        type
      }) => type !== "EmptyStatement");
      if (firstNonEmptyNode) {
        addLeadingComment(firstNonEmptyNode, comment);
      } else {
        addDanglingComment(node, comment);
      }
    }
    function addBlockOrNotComment(node, comment) {
      if (node.type === "BlockStatement") {
        addBlockStatementFirstComment(node, comment);
      } else {
        addLeadingComment(node, comment);
      }
    }
    function handleClosureTypeCastComments({
      comment,
      followingNode
    }) {
      if (followingNode && isTypeCastComment(comment)) {
        addLeadingComment(followingNode, comment);
        return true;
      }
      return false;
    }
    function handleIfStatementComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "IfStatement" || !followingNode) {
        return false;
      }
      const nextCharacter = getNextNonSpaceNonCommentCharacter(text, comment, locEnd);
      if (nextCharacter === ")") {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {
        if (precedingNode.type === "BlockStatement") {
          addTrailingComment(precedingNode, comment);
        } else {
          const isSingleLineComment = comment.type === "SingleLine" || comment.loc.start.line === comment.loc.end.line;
          const isSameLineComment = comment.loc.start.line === precedingNode.loc.start.line;
          if (isSingleLineComment && isSameLineComment) {
            addDanglingComment(precedingNode, comment, markerForIfWithoutBlockAndSameLineComment);
          } else {
            addDanglingComment(enclosingNode, comment);
          }
        }
        return true;
      }
      if (followingNode.type === "BlockStatement") {
        addBlockStatementFirstComment(followingNode, comment);
        return true;
      }
      if (followingNode.type === "IfStatement") {
        addBlockOrNotComment(followingNode.consequent, comment);
        return true;
      }
      if (enclosingNode.consequent === followingNode) {
        addLeadingComment(followingNode, comment);
        return true;
      }
      return false;
    }
    function handleWhileComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "WhileStatement" || !followingNode) {
        return false;
      }
      const nextCharacter = getNextNonSpaceNonCommentCharacter(text, comment, locEnd);
      if (nextCharacter === ")") {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      if (followingNode.type === "BlockStatement") {
        addBlockStatementFirstComment(followingNode, comment);
        return true;
      }
      if (enclosingNode.body === followingNode) {
        addLeadingComment(followingNode, comment);
        return true;
      }
      return false;
    }
    function handleTryStatementComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "TryStatement" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "CatchClause" || !followingNode) {
        return false;
      }
      if (enclosingNode.type === "CatchClause" && precedingNode) {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      if (followingNode.type === "BlockStatement") {
        addBlockStatementFirstComment(followingNode, comment);
        return true;
      }
      if (followingNode.type === "TryStatement") {
        addBlockOrNotComment(followingNode.finalizer, comment);
        return true;
      }
      if (followingNode.type === "CatchClause") {
        addBlockOrNotComment(followingNode.body, comment);
        return true;
      }
      return false;
    }
    function handleMemberExpressionComments({
      comment,
      enclosingNode,
      followingNode
    }) {
      if (isMemberExpression(enclosingNode) && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "Identifier") {
        addLeadingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleConditionalExpressionComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text
    }) {
      const isSameLineAsPrecedingNode = precedingNode && !hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));
      if ((!precedingNode || !isSameLineAsPrecedingNode) && ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ConditionalExpression" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSConditionalType") && followingNode) {
        addLeadingComment(followingNode, comment);
        return true;
      }
      return false;
    }
    function handleObjectPropertyAssignment({
      comment,
      precedingNode,
      enclosingNode
    }) {
      if (isObjectProperty(enclosingNode) && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === "AssignmentPattern") {
        addTrailingComment(enclosingNode.value.left, comment);
        return true;
      }
      return false;
    }
    var classLikeNodeTypes = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
    function handleClassComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode
    }) {
      if (classLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type)) {
        if (isNonEmptyArray(enclosingNode.decorators) && !(followingNode && followingNode.type === "Decorator")) {
          addTrailingComment(getLast(enclosingNode.decorators), comment);
          return true;
        }
        if (enclosingNode.body && followingNode === enclosingNode.body) {
          addBlockStatementFirstComment(enclosingNode.body, comment);
          return true;
        }
        if (followingNode) {
          if (enclosingNode.superClass && followingNode === enclosingNode.superClass && precedingNode && (precedingNode === enclosingNode.id || precedingNode === enclosingNode.typeParameters)) {
            addTrailingComment(precedingNode, comment);
            return true;
          }
          for (const prop of ["implements", "extends", "mixins"]) {
            if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {
              if (precedingNode && (precedingNode === enclosingNode.id || precedingNode === enclosingNode.typeParameters || precedingNode === enclosingNode.superClass)) {
                addTrailingComment(precedingNode, comment);
              } else {
                addDanglingComment(enclosingNode, comment, prop);
              }
              return true;
            }
          }
        }
      }
      return false;
    }
    var propertyLikeNodeTypes = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
    function handleMethodNameComments({
      comment,
      precedingNode,
      enclosingNode,
      text
    }) {
      if (enclosingNode && precedingNode && getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === "(" && (enclosingNode.type === "Property" || enclosingNode.type === "TSDeclareMethod" || enclosingNode.type === "TSAbstractMethodDefinition") && precedingNode.type === "Identifier" && enclosingNode.key === precedingNode && getNextNonSpaceNonCommentCharacter(text, precedingNode, locEnd) !== ":") {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      if ((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "Decorator" && propertyLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type)) {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      return false;
    }
    var functionLikeNodeTypes = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
    function handleFunctionNameComments({
      comment,
      precedingNode,
      enclosingNode,
      text
    }) {
      if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== "(") {
        return false;
      }
      if (precedingNode && functionLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type)) {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      return false;
    }
    function handleCommentAfterArrowParams({
      comment,
      enclosingNode,
      text
    }) {
      if (!((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ArrowFunctionExpression")) {
        return false;
      }
      const index = getNextNonSpaceNonCommentCharacterIndex(text, comment, locEnd);
      if (index !== false && text.slice(index, index + 2) === "=>") {
        addDanglingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleCommentInEmptyParens({
      comment,
      enclosingNode,
      text
    }) {
      if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== ")") {
        return false;
      }
      if (enclosingNode && (isRealFunctionLikeNode(enclosingNode) && getFunctionParameters(enclosingNode).length === 0 || isCallLikeExpression(enclosingNode) && getCallArguments(enclosingNode).length === 0)) {
        addDanglingComment(enclosingNode, comment);
        return true;
      }
      if (((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "MethodDefinition" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSAbstractMethodDefinition") && getFunctionParameters(enclosingNode.value).length === 0) {
        addDanglingComment(enclosingNode.value, comment);
        return true;
      }
      return false;
    }
    function handleLastFunctionArgComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text
    }) {
      if ((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "FunctionTypeParam" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "FunctionTypeAnnotation" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) !== "FunctionTypeParam") {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      if (((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "Identifier" || (precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "AssignmentPattern") && enclosingNode && isRealFunctionLikeNode(enclosingNode) && getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === ")") {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "FunctionDeclaration" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "BlockStatement") {
        const functionParamRightParenIndex = (() => {
          const parameters = getFunctionParameters(enclosingNode);
          if (parameters.length > 0) {
            return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(getLast(parameters)));
          }
          const functionParamLeftParenIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(enclosingNode.id));
          return functionParamLeftParenIndex !== false && getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);
        })();
        if (locStart(comment) > functionParamRightParenIndex) {
          addBlockStatementFirstComment(followingNode, comment);
          return true;
        }
      }
      return false;
    }
    function handleLabeledStatementComments({
      comment,
      enclosingNode
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "LabeledStatement") {
        addLeadingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleBreakAndContinueStatementComments({
      comment,
      enclosingNode
    }) {
      if (((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ContinueStatement" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "BreakStatement") && !enclosingNode.label) {
        addTrailingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleCallExpressionComments({
      comment,
      precedingNode,
      enclosingNode
    }) {
      if (isCallExpression(enclosingNode) && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {
        addLeadingComment(enclosingNode.arguments[0], comment);
        return true;
      }
      return false;
    }
    function handleUnionTypeComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "UnionTypeAnnotation" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSUnionType") {
        if (isPrettierIgnoreComment(comment)) {
          followingNode.prettierIgnore = true;
          comment.unignore = true;
        }
        if (precedingNode) {
          addTrailingComment(precedingNode, comment);
          return true;
        }
        return false;
      }
      if (((followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "UnionTypeAnnotation" || (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "TSUnionType") && isPrettierIgnoreComment(comment)) {
        followingNode.types[0].prettierIgnore = true;
        comment.unignore = true;
      }
      return false;
    }
    function handlePropertyComments({
      comment,
      enclosingNode
    }) {
      if (isObjectProperty(enclosingNode)) {
        addLeadingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleOnlyComments({
      comment,
      enclosingNode,
      followingNode,
      ast,
      isLastComment
    }) {
      if (ast && ast.body && ast.body.length === 0) {
        if (isLastComment) {
          addDanglingComment(ast, comment);
        } else {
          addLeadingComment(ast, comment);
        }
        return true;
      }
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "Program" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.body.length) === 0 && !isNonEmptyArray(enclosingNode.directives)) {
        if (isLastComment) {
          addDanglingComment(enclosingNode, comment);
        } else {
          addLeadingComment(enclosingNode, comment);
        }
        return true;
      }
      if ((followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "Program" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.body.length) === 0 && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ModuleExpression") {
        addDanglingComment(followingNode, comment);
        return true;
      }
      return false;
    }
    function handleForComments({
      comment,
      enclosingNode
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ForInStatement" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ForOfStatement") {
        addLeadingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleModuleSpecifiersComments({
      comment,
      precedingNode,
      enclosingNode,
      text
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ImportSpecifier" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ExportSpecifier") {
        addLeadingComment(enclosingNode, comment);
        return true;
      }
      const isImportDeclaration = (precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "ImportSpecifier" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ImportDeclaration";
      const isExportDeclaration = (precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "ExportSpecifier" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ExportNamedDeclaration";
      if ((isImportDeclaration || isExportDeclaration) && hasNewline(text, locEnd(comment))) {
        addTrailingComment(precedingNode, comment);
        return true;
      }
      return false;
    }
    function handleAssignmentPatternComments({
      comment,
      enclosingNode
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "AssignmentPattern") {
        addLeadingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    var assignmentLikeNodeTypes = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]);
    var complexExprNodeTypes = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
    function handleVariableDeclaratorComments({
      comment,
      enclosingNode,
      followingNode
    }) {
      if (assignmentLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) && followingNode && (complexExprNodeTypes.has(followingNode.type) || isBlockComment(comment))) {
        addLeadingComment(followingNode, comment);
        return true;
      }
      return false;
    }
    function handleTSFunctionTrailingComments({
      comment,
      enclosingNode,
      followingNode,
      text
    }) {
      if (!followingNode && ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSMethodSignature" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSDeclareFunction" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSAbstractMethodDefinition") && getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === ";") {
        addTrailingComment(enclosingNode, comment);
        return true;
      }
      return false;
    }
    function handleIgnoreComments({
      comment,
      enclosingNode,
      followingNode
    }) {
      if (isPrettierIgnoreComment(comment) && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSMappedType" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "TSTypeParameter" && followingNode.constraint) {
        enclosingNode.prettierIgnore = true;
        comment.unignore = true;
        return true;
      }
    }
    function handleTSMappedTypeComments({
      comment,
      precedingNode,
      enclosingNode,
      followingNode
    }) {
      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "TSMappedType") {
        return false;
      }
      if ((followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "TSTypeParameter" && followingNode.name) {
        addLeadingComment(followingNode.name, comment);
        return true;
      }
      if ((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "TSTypeParameter" && precedingNode.constraint) {
        addTrailingComment(precedingNode.constraint, comment);
        return true;
      }
      return false;
    }
    function handleSwitchDefaultCaseComments({
      comment,
      enclosingNode,
      followingNode
    }) {
      if (!enclosingNode || enclosingNode.type !== "SwitchCase" || enclosingNode.test || !followingNode || followingNode !== enclosingNode.consequent[0]) {
        return false;
      }
      if (followingNode.type === "BlockStatement" && isLineComment(comment)) {
        addBlockStatementFirstComment(followingNode, comment);
      } else {
        addDanglingComment(enclosingNode, comment);
      }
      return true;
    }
    function isRealFunctionLikeNode(node) {
      return node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ObjectMethod" || node.type === "ClassMethod" || node.type === "TSDeclareFunction" || node.type === "TSCallSignatureDeclaration" || node.type === "TSConstructSignatureDeclaration" || node.type === "TSMethodSignature" || node.type === "TSConstructorType" || node.type === "TSFunctionType" || node.type === "TSDeclareMethod";
    }
    function getCommentChildNodes(node, options) {
      if ((options.parser === "typescript" || options.parser === "flow" || options.parser === "acorn" || options.parser === "espree" || options.parser === "meriyah" || options.parser === "__babel_estree") && node.type === "MethodDefinition" && node.value && node.value.type === "FunctionExpression" && getFunctionParameters(node.value).length === 0 && !node.value.returnType && !isNonEmptyArray(node.value.typeParameters) && node.value.body) {
        return [...node.decorators || [], node.key, node.value.body];
      }
    }
    function willPrintOwnComments(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      const hasFlowAnnotations = (node2) => hasFlowAnnotationComment(getComments(node2, CommentCheckFlags.Leading)) || hasFlowAnnotationComment(getComments(node2, CommentCheckFlags.Trailing));
      return (node && (isJsxNode(node) || hasFlowShorthandAnnotationComment(node) || isCallExpression(parent) && hasFlowAnnotations(node)) || parent && (parent.type === "JSXSpreadAttribute" || parent.type === "JSXSpreadChild" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node)) && (!hasIgnoreComment(path) || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType");
    }
    module2.exports = {
      handleOwnLineComment,
      handleEndOfLineComment,
      handleRemainingComment,
      getCommentChildNodes,
      willPrintOwnComments
    };
  }
});
var require_needs_parens = __commonJS2({
  "src/language-js/needs-parens.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    var isNonEmptyArray = require_is_non_empty_array();
    var {
      getFunctionParameters,
      getLeftSidePathName,
      hasFlowShorthandAnnotationComment,
      hasNakedLeftSide,
      hasNode,
      isBitwiseOperator,
      startsWithNoLookaheadToken,
      shouldFlatten,
      getPrecedence,
      isCallExpression,
      isMemberExpression,
      isObjectProperty,
      isTSTypeExpression
    } = require_utils7();
    function needsParens(path, options) {
      const parent = path.getParentNode();
      if (!parent) {
        return false;
      }
      const name = path.getName();
      const node = path.getNode();
      if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {
        return true;
      }
      if (isStatement(node)) {
        return false;
      }
      if (options.parser !== "flow" && hasFlowShorthandAnnotationComment(path.getValue())) {
        return true;
      }
      if (node.type === "Identifier") {
        if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(node.name)) {
          return true;
        }
        if (name === "left" && (node.name === "async" && !parent.await || node.name === "let") && parent.type === "ForOfStatement") {
          return true;
        }
        if (node.name === "let") {
          var _path$findAncestor;
          const expression = (_path$findAncestor = path.findAncestor((node2) => node2.type === "ForOfStatement")) === null || _path$findAncestor === void 0 ? void 0 : _path$findAncestor.left;
          if (expression && startsWithNoLookaheadToken(expression, (leftmostNode) => leftmostNode === node)) {
            return true;
          }
        }
        if (name === "object" && node.name === "let" && parent.type === "MemberExpression" && parent.computed && !parent.optional) {
          const statement = path.findAncestor((node2) => node2.type === "ExpressionStatement" || node2.type === "ForStatement" || node2.type === "ForInStatement");
          const expression = !statement ? void 0 : statement.type === "ExpressionStatement" ? statement.expression : statement.type === "ForStatement" ? statement.init : statement.left;
          if (expression && startsWithNoLookaheadToken(expression, (leftmostNode) => leftmostNode === node)) {
            return true;
          }
        }
        return false;
      }
      if (node.type === "ObjectExpression" || node.type === "FunctionExpression" || node.type === "ClassExpression" || node.type === "DoExpression") {
        var _path$findAncestor2;
        const expression = (_path$findAncestor2 = path.findAncestor((node2) => node2.type === "ExpressionStatement")) === null || _path$findAncestor2 === void 0 ? void 0 : _path$findAncestor2.expression;
        if (expression && startsWithNoLookaheadToken(expression, (leftmostNode) => leftmostNode === node)) {
          return true;
        }
      }
      switch (parent.type) {
        case "ParenthesizedExpression":
          return false;
        case "ClassDeclaration":
        case "ClassExpression": {
          if (name === "superClass" && (node.type === "ArrowFunctionExpression" || node.type === "AssignmentExpression" || node.type === "AwaitExpression" || node.type === "BinaryExpression" || node.type === "ConditionalExpression" || node.type === "LogicalExpression" || node.type === "NewExpression" || node.type === "ObjectExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "UnaryExpression" || node.type === "UpdateExpression" || node.type === "YieldExpression" || node.type === "TSNonNullExpression")) {
            return true;
          }
          break;
        }
        case "ExportDefaultDeclaration": {
          return shouldWrapFunctionForExportDefault(path, options) || node.type === "SequenceExpression";
        }
        case "Decorator": {
          if (name === "expression") {
            if (isMemberExpression(node) && node.computed) {
              return true;
            }
            let hasCallExpression = false;
            let hasMemberExpression = false;
            let current = node;
            while (current) {
              switch (current.type) {
                case "MemberExpression":
                  hasMemberExpression = true;
                  current = current.object;
                  break;
                case "CallExpression":
                  if (hasMemberExpression || hasCallExpression) {
                    return options.parser !== "typescript";
                  }
                  hasCallExpression = true;
                  current = current.callee;
                  break;
                case "Identifier":
                  return false;
                case "TaggedTemplateExpression":
                  return options.parser !== "typescript";
                default:
                  return true;
              }
            }
            return true;
          }
          break;
        }
        case "ArrowFunctionExpression": {
          if (name === "body" && node.type !== "SequenceExpression" && startsWithNoLookaheadToken(node, (node2) => node2.type === "ObjectExpression")) {
            return true;
          }
          break;
        }
      }
      switch (node.type) {
        case "UpdateExpression":
          if (parent.type === "UnaryExpression") {
            return node.prefix && (node.operator === "++" && parent.operator === "+" || node.operator === "--" && parent.operator === "-");
          }
        case "UnaryExpression":
          switch (parent.type) {
            case "UnaryExpression":
              return node.operator === parent.operator && (node.operator === "+" || node.operator === "-");
            case "BindExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return name === "object";
            case "TaggedTemplateExpression":
              return true;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return name === "callee";
            case "BinaryExpression":
              return name === "left" && parent.operator === "**";
            case "TSNonNullExpression":
              return true;
            default:
              return false;
          }
        case "BinaryExpression": {
          if (parent.type === "UpdateExpression") {
            return true;
          }
          if (node.operator === "in" && isPathInForStatementInitializer(path)) {
            return true;
          }
          if (node.operator === "|>" && node.extra && node.extra.parenthesized) {
            const grandParent = path.getParentNode(1);
            if (grandParent.type === "BinaryExpression" && grandParent.operator === "|>") {
              return true;
            }
          }
        }
        case "TSTypeAssertion":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "LogicalExpression":
          switch (parent.type) {
            case "TSSatisfiesExpression":
            case "TSAsExpression":
              return !isTSTypeExpression(node);
            case "ConditionalExpression":
              return isTSTypeExpression(node);
            case "CallExpression":
            case "NewExpression":
            case "OptionalCallExpression":
              return name === "callee";
            case "ClassExpression":
            case "ClassDeclaration":
              return name === "superClass";
            case "TSTypeAssertion":
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "JSXSpreadAttribute":
            case "SpreadElement":
            case "SpreadProperty":
            case "BindExpression":
            case "AwaitExpression":
            case "TSNonNullExpression":
            case "UpdateExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return name === "object";
            case "AssignmentExpression":
            case "AssignmentPattern":
              return name === "left" && (node.type === "TSTypeAssertion" || isTSTypeExpression(node));
            case "LogicalExpression":
              if (node.type === "LogicalExpression") {
                return parent.operator !== node.operator;
              }
            case "BinaryExpression": {
              const {
                operator,
                type
              } = node;
              if (!operator && type !== "TSTypeAssertion") {
                return true;
              }
              const precedence = getPrecedence(operator);
              const parentOperator = parent.operator;
              const parentPrecedence = getPrecedence(parentOperator);
              if (parentPrecedence > precedence) {
                return true;
              }
              if (name === "right" && parentPrecedence === precedence) {
                return true;
              }
              if (parentPrecedence === precedence && !shouldFlatten(parentOperator, operator)) {
                return true;
              }
              if (parentPrecedence < precedence && operator === "%") {
                return parentOperator === "+" || parentOperator === "-";
              }
              if (isBitwiseOperator(parentOperator)) {
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        case "SequenceExpression":
          switch (parent.type) {
            case "ReturnStatement":
              return false;
            case "ForStatement":
              return false;
            case "ExpressionStatement":
              return name !== "expression";
            case "ArrowFunctionExpression":
              return name !== "body";
            default:
              return true;
          }
        case "YieldExpression":
          if (parent.type === "UnaryExpression" || parent.type === "AwaitExpression" || isTSTypeExpression(parent) || parent.type === "TSNonNullExpression") {
            return true;
          }
        case "AwaitExpression":
          switch (parent.type) {
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "LogicalExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "BindExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return name === "object";
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return name === "callee";
            case "ConditionalExpression":
              return name === "test";
            case "BinaryExpression": {
              if (!node.argument && parent.operator === "|>") {
                return false;
              }
              return true;
            }
            default:
              return false;
          }
        case "TSConditionalType":
        case "TSFunctionType":
        case "TSConstructorType":
          if (name === "extendsType" && parent.type === "TSConditionalType") {
            if (node.type === "TSConditionalType") {
              return true;
            }
            let {
              typeAnnotation
            } = node.returnType || node.typeAnnotation;
            if (typeAnnotation.type === "TSTypePredicate" && typeAnnotation.typeAnnotation) {
              typeAnnotation = typeAnnotation.typeAnnotation.typeAnnotation;
            }
            if (typeAnnotation.type === "TSInferType" && typeAnnotation.typeParameter.constraint) {
              return true;
            }
          }
          if (name === "checkType" && parent.type === "TSConditionalType") {
            return true;
          }
        case "TSUnionType":
        case "TSIntersectionType":
          if ((parent.type === "TSUnionType" || parent.type === "TSIntersectionType") && parent.types.length > 1 && (!node.types || node.types.length > 1)) {
            return true;
          }
        case "TSInferType":
          if (node.type === "TSInferType" && parent.type === "TSRestType") {
            return false;
          }
        case "TSTypeOperator":
          return parent.type === "TSArrayType" || parent.type === "TSOptionalType" || parent.type === "TSRestType" || name === "objectType" && parent.type === "TSIndexedAccessType" || parent.type === "TSTypeOperator" || parent.type === "TSTypeAnnotation" && path.getParentNode(1).type.startsWith("TSJSDoc");
        case "TSTypeQuery":
          return name === "objectType" && parent.type === "TSIndexedAccessType" || name === "elementType" && parent.type === "TSArrayType";
        case "TypeofTypeAnnotation":
          return name === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType") || name === "elementType" && parent.type === "ArrayTypeAnnotation";
        case "ArrayTypeAnnotation":
          return parent.type === "NullableTypeAnnotation";
        case "IntersectionTypeAnnotation":
        case "UnionTypeAnnotation":
          return parent.type === "ArrayTypeAnnotation" || parent.type === "NullableTypeAnnotation" || parent.type === "IntersectionTypeAnnotation" || parent.type === "UnionTypeAnnotation" || name === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");
        case "NullableTypeAnnotation":
          return parent.type === "ArrayTypeAnnotation" || name === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");
        case "FunctionTypeAnnotation": {
          const ancestor = parent.type === "NullableTypeAnnotation" ? path.getParentNode(1) : parent;
          return ancestor.type === "UnionTypeAnnotation" || ancestor.type === "IntersectionTypeAnnotation" || ancestor.type === "ArrayTypeAnnotation" || name === "objectType" && (ancestor.type === "IndexedAccessType" || ancestor.type === "OptionalIndexedAccessType") || ancestor.type === "NullableTypeAnnotation" || parent.type === "FunctionTypeParam" && parent.name === null && getFunctionParameters(node).some((param) => param.typeAnnotation && param.typeAnnotation.type === "NullableTypeAnnotation");
        }
        case "OptionalIndexedAccessType":
          return name === "objectType" && parent.type === "IndexedAccessType";
        case "StringLiteral":
        case "NumericLiteral":
        case "Literal":
          if (typeof node.value === "string" && parent.type === "ExpressionStatement" && !parent.directive) {
            const grandParent = path.getParentNode(1);
            return grandParent.type === "Program" || grandParent.type === "BlockStatement";
          }
          return name === "object" && parent.type === "MemberExpression" && typeof node.value === "number";
        case "AssignmentExpression": {
          const grandParent = path.getParentNode(1);
          if (name === "body" && parent.type === "ArrowFunctionExpression") {
            return true;
          }
          if (name === "key" && (parent.type === "ClassProperty" || parent.type === "PropertyDefinition") && parent.computed) {
            return false;
          }
          if ((name === "init" || name === "update") && parent.type === "ForStatement") {
            return false;
          }
          if (parent.type === "ExpressionStatement") {
            return node.left.type === "ObjectPattern";
          }
          if (name === "key" && parent.type === "TSPropertySignature") {
            return false;
          }
          if (parent.type === "AssignmentExpression") {
            return false;
          }
          if (parent.type === "SequenceExpression" && grandParent && grandParent.type === "ForStatement" && (grandParent.init === parent || grandParent.update === parent)) {
            return false;
          }
          if (name === "value" && parent.type === "Property" && grandParent && grandParent.type === "ObjectPattern" && grandParent.properties.includes(parent)) {
            return false;
          }
          if (parent.type === "NGChainedExpression") {
            return false;
          }
          return true;
        }
        case "ConditionalExpression":
          switch (parent.type) {
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
            case "BinaryExpression":
            case "LogicalExpression":
            case "NGPipeExpression":
            case "ExportDefaultDeclaration":
            case "AwaitExpression":
            case "JSXSpreadAttribute":
            case "TSTypeAssertion":
            case "TypeCastExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
              return true;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return name === "callee";
            case "ConditionalExpression":
              return name === "test";
            case "MemberExpression":
            case "OptionalMemberExpression":
              return name === "object";
            default:
              return false;
          }
        case "FunctionExpression":
          switch (parent.type) {
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return name === "callee";
            case "TaggedTemplateExpression":
              return true;
            default:
              return false;
          }
        case "ArrowFunctionExpression":
          switch (parent.type) {
            case "BinaryExpression":
              return parent.operator !== "|>" || node.extra && node.extra.parenthesized;
            case "NewExpression":
            case "CallExpression":
            case "OptionalCallExpression":
              return name === "callee";
            case "MemberExpression":
            case "OptionalMemberExpression":
              return name === "object";
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSNonNullExpression":
            case "BindExpression":
            case "TaggedTemplateExpression":
            case "UnaryExpression":
            case "LogicalExpression":
            case "AwaitExpression":
            case "TSTypeAssertion":
              return true;
            case "ConditionalExpression":
              return name === "test";
            default:
              return false;
          }
        case "ClassExpression":
          if (isNonEmptyArray(node.decorators)) {
            return true;
          }
          switch (parent.type) {
            case "NewExpression":
              return name === "callee";
            default:
              return false;
          }
        case "OptionalMemberExpression":
        case "OptionalCallExpression": {
          const parentParent = path.getParentNode(1);
          if (name === "object" && parent.type === "MemberExpression" || name === "callee" && (parent.type === "CallExpression" || parent.type === "NewExpression") || parent.type === "TSNonNullExpression" && parentParent.type === "MemberExpression" && parentParent.object === parent) {
            return true;
          }
        }
        case "CallExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "TSNonNullExpression":
          if (name === "callee" && (parent.type === "BindExpression" || parent.type === "NewExpression")) {
            let object = node;
            while (object) {
              switch (object.type) {
                case "CallExpression":
                case "OptionalCallExpression":
                  return true;
                case "MemberExpression":
                case "OptionalMemberExpression":
                case "BindExpression":
                  object = object.object;
                  break;
                case "TaggedTemplateExpression":
                  object = object.tag;
                  break;
                case "TSNonNullExpression":
                  object = object.expression;
                  break;
                default:
                  return false;
              }
            }
          }
          return false;
        case "BindExpression":
          return name === "callee" && (parent.type === "BindExpression" || parent.type === "NewExpression") || name === "object" && isMemberExpression(parent);
        case "NGPipeExpression":
          if (parent.type === "NGRoot" || parent.type === "NGMicrosyntaxExpression" || parent.type === "ObjectProperty" && !(node.extra && node.extra.parenthesized) || parent.type === "ArrayExpression" || isCallExpression(parent) && parent.arguments[name] === node || name === "right" && parent.type === "NGPipeExpression" || name === "property" && parent.type === "MemberExpression" || parent.type === "AssignmentExpression") {
            return false;
          }
          return true;
        case "JSXFragment":
        case "JSXElement":
          return name === "callee" || name === "left" && parent.type === "BinaryExpression" && parent.operator === "<" || parent.type !== "ArrayExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "AssignmentExpression" && parent.type !== "AssignmentPattern" && parent.type !== "BinaryExpression" && parent.type !== "NewExpression" && parent.type !== "ConditionalExpression" && parent.type !== "ExpressionStatement" && parent.type !== "JsExpressionRoot" && parent.type !== "JSXAttribute" && parent.type !== "JSXElement" && parent.type !== "JSXExpressionContainer" && parent.type !== "JSXFragment" && parent.type !== "LogicalExpression" && !isCallExpression(parent) && !isObjectProperty(parent) && parent.type !== "ReturnStatement" && parent.type !== "ThrowStatement" && parent.type !== "TypeCastExpression" && parent.type !== "VariableDeclarator" && parent.type !== "YieldExpression";
        case "TypeAnnotation":
          return name === "returnType" && parent.type === "ArrowFunctionExpression" && includesFunctionTypeInObjectType(node);
      }
      return false;
    }
    function isStatement(node) {
      return node.type === "BlockStatement" || node.type === "BreakStatement" || node.type === "ClassBody" || node.type === "ClassDeclaration" || node.type === "ClassMethod" || node.type === "ClassProperty" || node.type === "PropertyDefinition" || node.type === "ClassPrivateProperty" || node.type === "ContinueStatement" || node.type === "DebuggerStatement" || node.type === "DeclareClass" || node.type === "DeclareExportAllDeclaration" || node.type === "DeclareExportDeclaration" || node.type === "DeclareFunction" || node.type === "DeclareInterface" || node.type === "DeclareModule" || node.type === "DeclareModuleExports" || node.type === "DeclareVariable" || node.type === "DoWhileStatement" || node.type === "EnumDeclaration" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration" || node.type === "ExportNamedDeclaration" || node.type === "ExpressionStatement" || node.type === "ForInStatement" || node.type === "ForOfStatement" || node.type === "ForStatement" || node.type === "FunctionDeclaration" || node.type === "IfStatement" || node.type === "ImportDeclaration" || node.type === "InterfaceDeclaration" || node.type === "LabeledStatement" || node.type === "MethodDefinition" || node.type === "ReturnStatement" || node.type === "SwitchStatement" || node.type === "ThrowStatement" || node.type === "TryStatement" || node.type === "TSDeclareFunction" || node.type === "TSEnumDeclaration" || node.type === "TSImportEqualsDeclaration" || node.type === "TSInterfaceDeclaration" || node.type === "TSModuleDeclaration" || node.type === "TSNamespaceExportDeclaration" || node.type === "TypeAlias" || node.type === "VariableDeclaration" || node.type === "WhileStatement" || node.type === "WithStatement";
    }
    function isPathInForStatementInitializer(path) {
      let i = 0;
      let node = path.getValue();
      while (node) {
        const parent = path.getParentNode(i++);
        if (parent && parent.type === "ForStatement" && parent.init === node) {
          return true;
        }
        node = parent;
      }
      return false;
    }
    function includesFunctionTypeInObjectType(node) {
      return hasNode(node, (n1) => n1.type === "ObjectTypeAnnotation" && hasNode(n1, (n2) => n2.type === "FunctionTypeAnnotation" || void 0) || void 0);
    }
    function endsWithRightBracket(node) {
      switch (node.type) {
        case "ObjectExpression":
          return true;
        default:
          return false;
      }
    }
    function isFollowedByRightBracket(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      const name = path.getName();
      switch (parent.type) {
        case "NGPipeExpression":
          if (typeof name === "number" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {
            return path.callParent(isFollowedByRightBracket);
          }
          break;
        case "ObjectProperty":
          if (name === "value") {
            const parentParent = path.getParentNode(1);
            return getLast(parentParent.properties) === parent;
          }
          break;
        case "BinaryExpression":
        case "LogicalExpression":
          if (name === "right") {
            return path.callParent(isFollowedByRightBracket);
          }
          break;
        case "ConditionalExpression":
          if (name === "alternate") {
            return path.callParent(isFollowedByRightBracket);
          }
          break;
        case "UnaryExpression":
          if (parent.prefix) {
            return path.callParent(isFollowedByRightBracket);
          }
          break;
      }
      return false;
    }
    function shouldWrapFunctionForExportDefault(path, options) {
      const node = path.getValue();
      const parent = path.getParentNode();
      if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
        return parent.type === "ExportDefaultDeclaration" || !needsParens(path, options);
      }
      if (!hasNakedLeftSide(node) || parent.type !== "ExportDefaultDeclaration" && needsParens(path, options)) {
        return false;
      }
      return path.call((childPath) => shouldWrapFunctionForExportDefault(childPath, options), ...getLeftSidePathName(path, node));
    }
    module2.exports = needsParens;
  }
});
var require_print_preprocess = __commonJS2({
  "src/language-js/print-preprocess.js"(exports2, module2) {
    "use strict";
    function preprocess(ast, options) {
      switch (options.parser) {
        case "json":
        case "json5":
        case "json-stringify":
        case "__js_expression":
        case "__vue_expression":
        case "__vue_ts_expression":
          return Object.assign(Object.assign({}, ast), {}, {
            type: options.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
            node: ast,
            comments: [],
            rootMarker: options.rootMarker
          });
        default:
          return ast;
      }
    }
    module2.exports = preprocess;
  }
});
var require_html_binding = __commonJS2({
  "src/language-js/print/html-binding.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        join,
        line,
        group,
        softline,
        indent
      }
    } = require("./doc.js");
    function printHtmlBinding(path, options, print) {
      const node = path.getValue();
      if (options.__onHtmlBindingRoot && path.getName() === null) {
        options.__onHtmlBindingRoot(node, options);
      }
      if (node.type !== "File") {
        return;
      }
      if (options.__isVueForBindingLeft) {
        return path.call((functionDeclarationPath) => {
          const printed = join([",", line], functionDeclarationPath.map(print, "params"));
          const {
            params
          } = functionDeclarationPath.getValue();
          if (params.length === 1) {
            return printed;
          }
          return ["(", indent([softline, group(printed)]), softline, ")"];
        }, "program", "body", 0);
      }
      if (options.__isVueBindings) {
        return path.call((functionDeclarationPath) => join([",", line], functionDeclarationPath.map(print, "params")), "program", "body", 0);
      }
    }
    function isVueEventBindingExpression(node) {
      switch (node.type) {
        case "MemberExpression":
          switch (node.property.type) {
            case "Identifier":
            case "NumericLiteral":
            case "StringLiteral":
              return isVueEventBindingExpression(node.object);
          }
          return false;
        case "Identifier":
          return true;
        default:
          return false;
      }
    }
    module2.exports = {
      isVueEventBindingExpression,
      printHtmlBinding
    };
  }
});
var require_binaryish = __commonJS2({
  "src/language-js/print/binaryish.js"(exports2, module2) {
    "use strict";
    var {
      printComments
    } = require_comments();
    var {
      getLast
    } = require_util();
    var {
      builders: {
        join,
        line,
        softline,
        group,
        indent,
        align,
        indentIfBreak
      },
      utils: {
        cleanDoc,
        getDocParts,
        isConcat
      }
    } = require("./doc.js");
    var {
      hasLeadingOwnLineComment,
      isBinaryish,
      isJsxNode,
      shouldFlatten,
      hasComment,
      CommentCheckFlags,
      isCallExpression,
      isMemberExpression,
      isObjectProperty,
      isEnabledHackPipeline
    } = require_utils7();
    var uid = 0;
    function printBinaryishExpression(path, options, print) {
      const node = path.getValue();
      const parent = path.getParentNode();
      const parentParent = path.getParentNode(1);
      const isInsideParenthesis = node !== parent.body && (parent.type === "IfStatement" || parent.type === "WhileStatement" || parent.type === "SwitchStatement" || parent.type === "DoWhileStatement");
      const isHackPipeline = isEnabledHackPipeline(options) && node.operator === "|>";
      const parts = printBinaryishExpressions(path, print, options, false, isInsideParenthesis);
      if (isInsideParenthesis) {
        return parts;
      }
      if (isHackPipeline) {
        return group(parts);
      }
      if (isCallExpression(parent) && parent.callee === node || parent.type === "UnaryExpression" || isMemberExpression(parent) && !parent.computed) {
        return group([indent([softline, ...parts]), softline]);
      }
      const shouldNotIndent = parent.type === "ReturnStatement" || parent.type === "ThrowStatement" || parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" || node.operator !== "|" && parent.type === "JsExpressionRoot" || node.type !== "NGPipeExpression" && (parent.type === "NGRoot" && options.parser === "__ng_binding" || parent.type === "NGMicrosyntaxExpression" && parentParent.type === "NGMicrosyntax" && parentParent.body.length === 1) || node === parent.body && parent.type === "ArrowFunctionExpression" || node !== parent.body && parent.type === "ForStatement" || parent.type === "ConditionalExpression" && parentParent.type !== "ReturnStatement" && parentParent.type !== "ThrowStatement" && !isCallExpression(parentParent) || parent.type === "TemplateLiteral";
      const shouldIndentIfInlining = parent.type === "AssignmentExpression" || parent.type === "VariableDeclarator" || parent.type === "ClassProperty" || parent.type === "PropertyDefinition" || parent.type === "TSAbstractPropertyDefinition" || parent.type === "ClassPrivateProperty" || isObjectProperty(parent);
      const samePrecedenceSubExpression = isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);
      if (shouldNotIndent || shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(node) && shouldIndentIfInlining) {
        return group(parts);
      }
      if (parts.length === 0) {
        return "";
      }
      const hasJsx = isJsxNode(node.right);
      const firstGroupIndex = parts.findIndex((part) => typeof part !== "string" && !Array.isArray(part) && part.type === "group");
      const headParts = parts.slice(0, firstGroupIndex === -1 ? 1 : firstGroupIndex + 1);
      const rest = parts.slice(headParts.length, hasJsx ? -1 : void 0);
      const groupId = Symbol("logicalChain-" + ++uid);
      const chain = group([...headParts, indent(rest)], {
        id: groupId
      });
      if (!hasJsx) {
        return chain;
      }
      const jsxPart = getLast(parts);
      return group([chain, indentIfBreak(jsxPart, {
        groupId
      })]);
    }
    function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {
      const node = path.getValue();
      if (!isBinaryish(node)) {
        return [group(print())];
      }
      let parts = [];
      if (shouldFlatten(node.operator, node.left.operator)) {
        parts = path.call((left) => printBinaryishExpressions(left, print, options, true, isInsideParenthesis), "left");
      } else {
        parts.push(group(print("left")));
      }
      const shouldInline = shouldInlineLogicalExpression(node);
      const lineBeforeOperator = (node.operator === "|>" || node.type === "NGPipeExpression" || node.operator === "|" && options.parser === "__vue_expression") && !hasLeadingOwnLineComment(options.originalText, node.right);
      const operator = node.type === "NGPipeExpression" ? "|" : node.operator;
      const rightSuffix = node.type === "NGPipeExpression" && node.arguments.length > 0 ? group(indent([line, ": ", join([line, ": "], path.map(print, "arguments").map((arg) => align(2, group(arg))))])) : "";
      let right;
      if (shouldInline) {
        right = [operator, " ", print("right"), rightSuffix];
      } else {
        const isHackPipeline = isEnabledHackPipeline(options) && operator === "|>";
        const rightContent = isHackPipeline ? path.call((left) => printBinaryishExpressions(left, print, options, true, isInsideParenthesis), "right") : print("right");
        right = [lineBeforeOperator ? line : "", operator, lineBeforeOperator ? " " : line, rightContent, rightSuffix];
      }
      const parent = path.getParentNode();
      const shouldBreak = hasComment(node.left, CommentCheckFlags.Trailing | CommentCheckFlags.Line);
      const shouldGroup = shouldBreak || !(isInsideParenthesis && node.type === "LogicalExpression") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;
      parts.push(lineBeforeOperator ? "" : " ", shouldGroup ? group(right, {
        shouldBreak
      }) : right);
      if (isNested && hasComment(node)) {
        const printed = cleanDoc(printComments(path, parts, options));
        if (isConcat(printed) || printed.type === "fill") {
          return getDocParts(printed);
        }
        return [printed];
      }
      return parts;
    }
    function shouldInlineLogicalExpression(node) {
      if (node.type !== "LogicalExpression") {
        return false;
      }
      if (node.right.type === "ObjectExpression" && node.right.properties.length > 0) {
        return true;
      }
      if (node.right.type === "ArrayExpression" && node.right.elements.length > 0) {
        return true;
      }
      if (isJsxNode(node.right)) {
        return true;
      }
      return false;
    }
    module2.exports = {
      printBinaryishExpression,
      shouldInlineLogicalExpression
    };
  }
});
var require_angular = __commonJS2({
  "src/language-js/print/angular.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        join,
        line,
        group
      }
    } = require("./doc.js");
    var {
      hasNode,
      hasComment,
      getComments
    } = require_utils7();
    var {
      printBinaryishExpression
    } = require_binaryish();
    function printAngular(path, options, print) {
      const node = path.getValue();
      if (!node.type.startsWith("NG")) {
        return;
      }
      switch (node.type) {
        case "NGRoot":
          return [print("node"), !hasComment(node.node) ? "" : " //" + getComments(node.node)[0].value.trimEnd()];
        case "NGPipeExpression":
          return printBinaryishExpression(path, options, print);
        case "NGChainedExpression":
          return group(join([";", line], path.map((childPath) => hasNgSideEffect(childPath) ? print() : ["(", print(), ")"], "expressions")));
        case "NGEmptyExpression":
          return "";
        case "NGQuotedExpression":
          return [node.prefix, ": ", node.value.trim()];
        case "NGMicrosyntax":
          return path.map((childPath, index) => [index === 0 ? "" : isNgForOf(childPath.getValue(), index, node) ? " " : [";", line], print()], "body");
        case "NGMicrosyntaxKey":
          return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(node.name) ? node.name : JSON.stringify(node.name);
        case "NGMicrosyntaxExpression":
          return [print("expression"), node.alias === null ? "" : [" as ", print("alias")]];
        case "NGMicrosyntaxKeyedExpression": {
          const index = path.getName();
          const parentNode = path.getParentNode();
          const shouldNotPrintColon = isNgForOf(node, index, parentNode) || (index === 1 && (node.key.name === "then" || node.key.name === "else") || index === 2 && node.key.name === "else" && parentNode.body[index - 1].type === "NGMicrosyntaxKeyedExpression" && parentNode.body[index - 1].key.name === "then") && parentNode.body[0].type === "NGMicrosyntaxExpression";
          return [print("key"), shouldNotPrintColon ? " " : ": ", print("expression")];
        }
        case "NGMicrosyntaxLet":
          return ["let ", print("key"), node.value === null ? "" : [" = ", print("value")]];
        case "NGMicrosyntaxAs":
          return [print("key"), " as ", print("alias")];
        default:
          throw new Error(`Unknown Angular node type: ${JSON.stringify(node.type)}.`);
      }
    }
    function isNgForOf(node, index, parentNode) {
      return node.type === "NGMicrosyntaxKeyedExpression" && node.key.name === "of" && index === 1 && parentNode.body[0].type === "NGMicrosyntaxLet" && parentNode.body[0].value === null;
    }
    function hasNgSideEffect(path) {
      return hasNode(path.getValue(), (node) => {
        switch (node.type) {
          case void 0:
            return false;
          case "CallExpression":
          case "OptionalCallExpression":
          case "AssignmentExpression":
            return true;
        }
      });
    }
    module2.exports = {
      printAngular
    };
  }
});
var require_jsx = __commonJS2({
  "src/language-js/print/jsx.js"(exports2, module2) {
    "use strict";
    var {
      printComments,
      printDanglingComments,
      printCommentsSeparately
    } = require_comments();
    var {
      builders: {
        line,
        hardline,
        softline,
        group,
        indent,
        conditionalGroup,
        fill,
        ifBreak,
        lineSuffixBoundary,
        join
      },
      utils: {
        willBreak
      }
    } = require("./doc.js");
    var {
      getLast,
      getPreferredQuote
    } = require_util();
    var {
      isJsxNode,
      rawText,
      isCallExpression,
      isStringLiteral,
      isBinaryish,
      hasComment,
      CommentCheckFlags,
      hasNodeIgnoreComment
    } = require_utils7();
    var pathNeedsParens = require_needs_parens();
    var {
      willPrintOwnComments
    } = require_comments2();
    var isEmptyStringOrAnyLine = (doc2) => doc2 === "" || doc2 === line || doc2 === hardline || doc2 === softline;
    function printJsxElementInternal(path, options, print) {
      const node = path.getValue();
      if (node.type === "JSXElement" && isEmptyJsxElement(node)) {
        return [print("openingElement"), print("closingElement")];
      }
      const openingLines = node.type === "JSXElement" ? print("openingElement") : print("openingFragment");
      const closingLines = node.type === "JSXElement" ? print("closingElement") : print("closingFragment");
      if (node.children.length === 1 && node.children[0].type === "JSXExpressionContainer" && (node.children[0].expression.type === "TemplateLiteral" || node.children[0].expression.type === "TaggedTemplateExpression")) {
        return [openingLines, ...path.map(print, "children"), closingLines];
      }
      node.children = node.children.map((child) => {
        if (isJsxWhitespaceExpression(child)) {
          return {
            type: "JSXText",
            value: " ",
            raw: " "
          };
        }
        return child;
      });
      const containsTag = node.children.some(isJsxNode);
      const containsMultipleExpressions = node.children.filter((child) => child.type === "JSXExpressionContainer").length > 1;
      const containsMultipleAttributes = node.type === "JSXElement" && node.openingElement.attributes.length > 1;
      let forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;
      const isMdxBlock = path.getParentNode().rootMarker === "mdx";
      const rawJsxWhitespace = options.singleQuote ? "{' '}" : '{" "}';
      const jsxWhitespace = isMdxBlock ? " " : ifBreak([rawJsxWhitespace, softline], " ");
      const isFacebookTranslationTag = node.openingElement && node.openingElement.name && node.openingElement.name.name === "fbt";
      const children = printJsxChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);
      const containsText = node.children.some((child) => isMeaningfulJsxText(child));
      for (let i = children.length - 2; i >= 0; i--) {
        const isPairOfEmptyStrings = children[i] === "" && children[i + 1] === "";
        const isPairOfHardlines = children[i] === hardline && children[i + 1] === "" && children[i + 2] === hardline;
        const isLineFollowedByJsxWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
        const isJsxWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === "" && (children[i + 2] === softline || children[i + 2] === hardline);
        const isDoubleJsxWhitespace = children[i] === jsxWhitespace && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
        const isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === "" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === "" && children[i + 2] === softline;
        if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJsxWhitespace || isDoubleJsxWhitespace || isPairOfHardOrSoftLines) {
          children.splice(i, 2);
        } else if (isJsxWhitespaceFollowedByLine) {
          children.splice(i + 1, 2);
        }
      }
      while (children.length > 0 && isEmptyStringOrAnyLine(getLast(children))) {
        children.pop();
      }
      while (children.length > 1 && isEmptyStringOrAnyLine(children[0]) && isEmptyStringOrAnyLine(children[1])) {
        children.shift();
        children.shift();
      }
      const multilineChildren = [];
      for (const [i, child] of children.entries()) {
        if (child === jsxWhitespace) {
          if (i === 1 && children[i - 1] === "") {
            if (children.length === 2) {
              multilineChildren.push(rawJsxWhitespace);
              continue;
            }
            multilineChildren.push([rawJsxWhitespace, hardline]);
            continue;
          } else if (i === children.length - 1) {
            multilineChildren.push(rawJsxWhitespace);
            continue;
          } else if (children[i - 1] === "" && children[i - 2] === hardline) {
            multilineChildren.push(rawJsxWhitespace);
            continue;
          }
        }
        multilineChildren.push(child);
        if (willBreak(child)) {
          forcedBreak = true;
        }
      }
      const content = containsText ? fill(multilineChildren) : group(multilineChildren, {
        shouldBreak: true
      });
      if (isMdxBlock) {
        return content;
      }
      const multiLineElem = group([openingLines, indent([hardline, content]), hardline, closingLines]);
      if (forcedBreak) {
        return multiLineElem;
      }
      return conditionalGroup([group([openingLines, ...children, closingLines]), multiLineElem]);
    }
    function printJsxChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {
      const parts = [];
      path.each((childPath, i, children) => {
        const child = childPath.getValue();
        if (child.type === "JSXText") {
          const text = rawText(child);
          if (isMeaningfulJsxText(child)) {
            const words = text.split(matchJsxWhitespaceRegex);
            if (words[0] === "") {
              parts.push("");
              words.shift();
              if (/\n/.test(words[0])) {
                const next = children[i + 1];
                parts.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));
              } else {
                parts.push(jsxWhitespace);
              }
              words.shift();
            }
            let endWhitespace;
            if (getLast(words) === "") {
              words.pop();
              endWhitespace = words.pop();
            }
            if (words.length === 0) {
              return;
            }
            for (const [i2, word] of words.entries()) {
              if (i2 % 2 === 1) {
                parts.push(line);
              } else {
                parts.push(word);
              }
            }
            if (endWhitespace !== void 0) {
              if (/\n/.test(endWhitespace)) {
                const next = children[i + 1];
                parts.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(parts), child, next));
              } else {
                parts.push(jsxWhitespace);
              }
            } else {
              const next = children[i + 1];
              parts.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(parts), child, next));
            }
          } else if (/\n/.test(text)) {
            if (text.match(/\n/g).length > 1) {
              parts.push("", hardline);
            }
          } else {
            parts.push("", jsxWhitespace);
          }
        } else {
          const printedChild = print();
          parts.push(printedChild);
          const next = children[i + 1];
          const directlyFollowedByMeaningfulText = next && isMeaningfulJsxText(next);
          if (directlyFollowedByMeaningfulText) {
            const firstWord = trimJsxWhitespace(rawText(next)).split(matchJsxWhitespaceRegex)[0];
            parts.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, next));
          } else {
            parts.push(hardline);
          }
        }
      }, "children");
      return parts;
    }
    function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
      if (isFacebookTranslationTag) {
        return "";
      }
      if (childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement) {
        return child.length === 1 ? softline : hardline;
      }
      return softline;
    }
    function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
      if (isFacebookTranslationTag) {
        return hardline;
      }
      if (child.length === 1) {
        return childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement ? hardline : softline;
      }
      return hardline;
    }
    function maybeWrapJsxElementInParens(path, elem, options) {
      const parent = path.getParentNode();
      if (!parent) {
        return elem;
      }
      const NO_WRAP_PARENTS = {
        ArrayExpression: true,
        JSXAttribute: true,
        JSXElement: true,
        JSXExpressionContainer: true,
        JSXFragment: true,
        ExpressionStatement: true,
        CallExpression: true,
        OptionalCallExpression: true,
        ConditionalExpression: true,
        JsExpressionRoot: true
      };
      if (NO_WRAP_PARENTS[parent.type]) {
        return elem;
      }
      const shouldBreak = path.match(void 0, (node) => node.type === "ArrowFunctionExpression", isCallExpression, (node) => node.type === "JSXExpressionContainer");
      const needsParens = pathNeedsParens(path, options);
      return group([needsParens ? "" : ifBreak("("), indent([softline, elem]), softline, needsParens ? "" : ifBreak(")")], {
        shouldBreak
      });
    }
    function printJsxAttribute(path, options, print) {
      const node = path.getValue();
      const parts = [];
      parts.push(print("name"));
      if (node.value) {
        let res;
        if (isStringLiteral(node.value)) {
          const raw = rawText(node.value);
          let final = raw.slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          const {
            escaped,
            quote,
            regex
          } = getPreferredQuote(final, options.jsxSingleQuote ? "'" : '"');
          final = final.replace(regex, escaped);
          const {
            leading,
            trailing
          } = path.call(() => printCommentsSeparately(path, options), "value");
          res = [leading, quote, final, quote, trailing];
        } else {
          res = print("value");
        }
        parts.push("=", res);
      }
      return parts;
    }
    function printJsxExpressionContainer(path, options, print) {
      const node = path.getValue();
      const shouldInline = (node2, parent) => node2.type === "JSXEmptyExpression" || !hasComment(node2) && (node2.type === "ArrayExpression" || node2.type === "ObjectExpression" || node2.type === "ArrowFunctionExpression" || node2.type === "AwaitExpression" && (shouldInline(node2.argument, node2) || node2.argument.type === "JSXElement") || isCallExpression(node2) || node2.type === "FunctionExpression" || node2.type === "TemplateLiteral" || node2.type === "TaggedTemplateExpression" || node2.type === "DoExpression" || isJsxNode(parent) && (node2.type === "ConditionalExpression" || isBinaryish(node2)));
      if (shouldInline(node.expression, path.getParentNode(0))) {
        return group(["{", print("expression"), lineSuffixBoundary, "}"]);
      }
      return group(["{", indent([softline, print("expression")]), softline, lineSuffixBoundary, "}"]);
    }
    function printJsxOpeningElement(path, options, print) {
      const node = path.getValue();
      const nameHasComments = node.name && hasComment(node.name) || node.typeParameters && hasComment(node.typeParameters);
      if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {
        return ["<", print("name"), print("typeParameters"), " />"];
      }
      if (node.attributes && node.attributes.length === 1 && node.attributes[0].value && isStringLiteral(node.attributes[0].value) && !node.attributes[0].value.value.includes("\n") && !nameHasComments && !hasComment(node.attributes[0])) {
        return group(["<", print("name"), print("typeParameters"), " ", ...path.map(print, "attributes"), node.selfClosing ? " />" : ">"]);
      }
      const shouldBreak = node.attributes && node.attributes.some((attr) => attr.value && isStringLiteral(attr.value) && attr.value.value.includes("\n"));
      const attributeLine = options.singleAttributePerLine && node.attributes.length > 1 ? hardline : line;
      return group(["<", print("name"), print("typeParameters"), indent(path.map(() => [attributeLine, print()], "attributes")), ...printEndOfOpeningTag(node, options, nameHasComments)], {
        shouldBreak
      });
    }
    function printEndOfOpeningTag(node, options, nameHasComments) {
      if (node.selfClosing) {
        return [line, "/>"];
      }
      const bracketSameLine = shouldPrintBracketSameLine(node, options, nameHasComments);
      if (bracketSameLine) {
        return [">"];
      }
      return [softline, ">"];
    }
    function shouldPrintBracketSameLine(node, options, nameHasComments) {
      const lastAttrHasTrailingComments = node.attributes.length > 0 && hasComment(getLast(node.attributes), CommentCheckFlags.Trailing);
      return node.attributes.length === 0 && !nameHasComments || (options.bracketSameLine || options.jsxBracketSameLine) && (!nameHasComments || node.attributes.length > 0) && !lastAttrHasTrailingComments;
    }
    function printJsxClosingElement(path, options, print) {
      const node = path.getValue();
      const parts = [];
      parts.push("</");
      const printed = print("name");
      if (hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)) {
        parts.push(indent([hardline, printed]), hardline);
      } else if (hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)) {
        parts.push(" ", printed);
      } else {
        parts.push(printed);
      }
      parts.push(">");
      return parts;
    }
    function printJsxOpeningClosingFragment(path, options) {
      const node = path.getValue();
      const nodeHasComment = hasComment(node);
      const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);
      const isOpeningFragment = node.type === "JSXOpeningFragment";
      return [isOpeningFragment ? "<" : "</", indent([hasOwnLineComment ? hardline : nodeHasComment && !isOpeningFragment ? " " : "", printDanglingComments(path, options, true)]), hasOwnLineComment ? hardline : "", ">"];
    }
    function printJsxElement(path, options, print) {
      const elem = printComments(path, printJsxElementInternal(path, options, print), options);
      return maybeWrapJsxElementInParens(path, elem, options);
    }
    function printJsxEmptyExpression(path, options) {
      const node = path.getValue();
      const requiresHardline = hasComment(node, CommentCheckFlags.Line);
      return [printDanglingComments(path, options, !requiresHardline), requiresHardline ? hardline : ""];
    }
    function printJsxSpreadAttribute(path, options, print) {
      const node = path.getValue();
      return ["{", path.call((p) => {
        const printed = ["...", print()];
        const node2 = p.getValue();
        if (!hasComment(node2) || !willPrintOwnComments(p)) {
          return printed;
        }
        return [indent([softline, printComments(p, printed, options)]), softline];
      }, node.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
    }
    function printJsx(path, options, print) {
      const node = path.getValue();
      if (!node.type.startsWith("JSX")) {
        return;
      }
      switch (node.type) {
        case "JSXAttribute":
          return printJsxAttribute(path, options, print);
        case "JSXIdentifier":
          return String(node.name);
        case "JSXNamespacedName":
          return join(":", [print("namespace"), print("name")]);
        case "JSXMemberExpression":
          return join(".", [print("object"), print("property")]);
        case "JSXSpreadAttribute":
          return printJsxSpreadAttribute(path, options, print);
        case "JSXSpreadChild": {
          const printJsxSpreadChild = printJsxSpreadAttribute;
          return printJsxSpreadChild(path, options, print);
        }
        case "JSXExpressionContainer":
          return printJsxExpressionContainer(path, options, print);
        case "JSXFragment":
        case "JSXElement":
          return printJsxElement(path, options, print);
        case "JSXOpeningElement":
          return printJsxOpeningElement(path, options, print);
        case "JSXClosingElement":
          return printJsxClosingElement(path, options, print);
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          return printJsxOpeningClosingFragment(path, options);
        case "JSXEmptyExpression":
          return printJsxEmptyExpression(path, options);
        case "JSXText":
          throw new Error("JSXText should be handled by JSXElement");
        default:
          throw new Error(`Unknown JSX node type: ${JSON.stringify(node.type)}.`);
      }
    }
    var jsxWhitespaceChars = " \n\r	";
    var matchJsxWhitespaceRegex = new RegExp("([" + jsxWhitespaceChars + "]+)");
    var containsNonJsxWhitespaceRegex = new RegExp("[^" + jsxWhitespaceChars + "]");
    var trimJsxWhitespace = (text) => text.replace(new RegExp("(?:^" + matchJsxWhitespaceRegex.source + "|" + matchJsxWhitespaceRegex.source + "$)"), "");
    function isEmptyJsxElement(node) {
      if (node.children.length === 0) {
        return true;
      }
      if (node.children.length > 1) {
        return false;
      }
      const child = node.children[0];
      return child.type === "JSXText" && !isMeaningfulJsxText(child);
    }
    function isMeaningfulJsxText(node) {
      return node.type === "JSXText" && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\n/.test(rawText(node)));
    }
    function isJsxWhitespaceExpression(node) {
      return node.type === "JSXExpressionContainer" && isStringLiteral(node.expression) && node.expression.value === " " && !hasComment(node.expression);
    }
    function hasJsxIgnoreComment(path) {
      const node = path.getValue();
      const parent = path.getParentNode();
      if (!parent || !node || !isJsxNode(node) || !isJsxNode(parent)) {
        return false;
      }
      const index = parent.children.indexOf(node);
      let prevSibling = null;
      for (let i = index; i > 0; i--) {
        const candidate = parent.children[i - 1];
        if (candidate.type === "JSXText" && !isMeaningfulJsxText(candidate)) {
          continue;
        }
        prevSibling = candidate;
        break;
      }
      return prevSibling && prevSibling.type === "JSXExpressionContainer" && prevSibling.expression.type === "JSXEmptyExpression" && hasNodeIgnoreComment(prevSibling.expression);
    }
    module2.exports = {
      hasJsxIgnoreComment,
      printJsx
    };
  }
});
var require_doc_builders = __commonJS2({
  "src/document/doc-builders.js"(exports2, module2) {
    "use strict";
    function concat(parts) {
      if (false) {
        for (const part of parts) {
          assertDoc(part);
        }
      }
      return {
        type: "concat",
        parts
      };
    }
    function indent(contents) {
      if (false) {
        assertDoc(contents);
      }
      return {
        type: "indent",
        contents
      };
    }
    function align(widthOrString, contents) {
      if (false) {
        assertDoc(contents);
      }
      return {
        type: "align",
        contents,
        n: widthOrString
      };
    }
    function group(contents, opts = {}) {
      if (false) {
        assertDoc(contents);
      }
      return {
        type: "group",
        id: opts.id,
        contents,
        break: Boolean(opts.shouldBreak),
        expandedStates: opts.expandedStates
      };
    }
    function dedentToRoot(contents) {
      return align(Number.NEGATIVE_INFINITY, contents);
    }
    function markAsRoot(contents) {
      return align({
        type: "root"
      }, contents);
    }
    function dedent(contents) {
      return align(-1, contents);
    }
    function conditionalGroup(states, opts) {
      return group(states[0], Object.assign(Object.assign({}, opts), {}, {
        expandedStates: states
      }));
    }
    function fill(parts) {
      if (false) {
        for (const part of parts) {
          assertDoc(part);
        }
      }
      return {
        type: "fill",
        parts
      };
    }
    function ifBreak(breakContents, flatContents, opts = {}) {
      if (false) {
        if (breakContents) {
          assertDoc(breakContents);
        }
        if (flatContents) {
          assertDoc(flatContents);
        }
      }
      return {
        type: "if-break",
        breakContents,
        flatContents,
        groupId: opts.groupId
      };
    }
    function indentIfBreak(contents, opts) {
      return {
        type: "indent-if-break",
        contents,
        groupId: opts.groupId,
        negate: opts.negate
      };
    }
    function lineSuffix(contents) {
      if (false) {
        assertDoc(contents);
      }
      return {
        type: "line-suffix",
        contents
      };
    }
    var lineSuffixBoundary = {
      type: "line-suffix-boundary"
    };
    var breakParent = {
      type: "break-parent"
    };
    var trim = {
      type: "trim"
    };
    var hardlineWithoutBreakParent = {
      type: "line",
      hard: true
    };
    var literallineWithoutBreakParent = {
      type: "line",
      hard: true,
      literal: true
    };
    var line = {
      type: "line"
    };
    var softline = {
      type: "line",
      soft: true
    };
    var hardline = concat([hardlineWithoutBreakParent, breakParent]);
    var literalline = concat([literallineWithoutBreakParent, breakParent]);
    var cursor = {
      type: "cursor",
      placeholder: Symbol("cursor")
    };
    function join(sep, arr) {
      const res = [];
      for (let i = 0; i < arr.length; i++) {
        if (i !== 0) {
          res.push(sep);
        }
        res.push(arr[i]);
      }
      return concat(res);
    }
    function addAlignmentToDoc(doc2, size, tabWidth) {
      let aligned = doc2;
      if (size > 0) {
        for (let i = 0; i < Math.floor(size / tabWidth); ++i) {
          aligned = indent(aligned);
        }
        aligned = align(size % tabWidth, aligned);
        aligned = align(Number.NEGATIVE_INFINITY, aligned);
      }
      return aligned;
    }
    function label(label2, contents) {
      return {
        type: "label",
        label: label2,
        contents
      };
    }
    module2.exports = {
      concat,
      join,
      line,
      softline,
      hardline,
      literalline,
      group,
      conditionalGroup,
      fill,
      lineSuffix,
      lineSuffixBoundary,
      cursor,
      breakParent,
      ifBreak,
      trim,
      indent,
      indentIfBreak,
      align,
      addAlignmentToDoc,
      markAsRoot,
      dedentToRoot,
      dedent,
      hardlineWithoutBreakParent,
      literallineWithoutBreakParent,
      label
    };
  }
});
var require_doc_utils = __commonJS2({
  "src/document/doc-utils.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    var {
      literalline,
      join
    } = require_doc_builders();
    var isConcat = (doc2) => Array.isArray(doc2) || doc2 && doc2.type === "concat";
    var getDocParts = (doc2) => {
      if (Array.isArray(doc2)) {
        return doc2;
      }
      if (doc2.type !== "concat" && doc2.type !== "fill") {
        throw new Error("Expect doc type to be `concat` or `fill`.");
      }
      return doc2.parts;
    };
    var traverseDocOnExitStackMarker = {};
    function traverseDoc(doc2, onEnter, onExit, shouldTraverseConditionalGroups) {
      const docsStack = [doc2];
      while (docsStack.length > 0) {
        const doc3 = docsStack.pop();
        if (doc3 === traverseDocOnExitStackMarker) {
          onExit(docsStack.pop());
          continue;
        }
        if (onExit) {
          docsStack.push(doc3, traverseDocOnExitStackMarker);
        }
        if (!onEnter || onEnter(doc3) !== false) {
          if (isConcat(doc3) || doc3.type === "fill") {
            const parts = getDocParts(doc3);
            for (let ic = parts.length, i = ic - 1; i >= 0; --i) {
              docsStack.push(parts[i]);
            }
          } else if (doc3.type === "if-break") {
            if (doc3.flatContents) {
              docsStack.push(doc3.flatContents);
            }
            if (doc3.breakContents) {
              docsStack.push(doc3.breakContents);
            }
          } else if (doc3.type === "group" && doc3.expandedStates) {
            if (shouldTraverseConditionalGroups) {
              for (let ic = doc3.expandedStates.length, i = ic - 1; i >= 0; --i) {
                docsStack.push(doc3.expandedStates[i]);
              }
            } else {
              docsStack.push(doc3.contents);
            }
          } else if (doc3.contents) {
            docsStack.push(doc3.contents);
          }
        }
      }
    }
    function mapDoc(doc2, cb) {
      const mapped = /* @__PURE__ */ new Map();
      return rec(doc2);
      function rec(doc3) {
        if (mapped.has(doc3)) {
          return mapped.get(doc3);
        }
        const result = process2(doc3);
        mapped.set(doc3, result);
        return result;
      }
      function process2(doc3) {
        if (Array.isArray(doc3)) {
          return cb(doc3.map(rec));
        }
        if (doc3.type === "concat" || doc3.type === "fill") {
          const parts = doc3.parts.map(rec);
          return cb(Object.assign(Object.assign({}, doc3), {}, {
            parts
          }));
        }
        if (doc3.type === "if-break") {
          const breakContents = doc3.breakContents && rec(doc3.breakContents);
          const flatContents = doc3.flatContents && rec(doc3.flatContents);
          return cb(Object.assign(Object.assign({}, doc3), {}, {
            breakContents,
            flatContents
          }));
        }
        if (doc3.type === "group" && doc3.expandedStates) {
          const expandedStates = doc3.expandedStates.map(rec);
          const contents = expandedStates[0];
          return cb(Object.assign(Object.assign({}, doc3), {}, {
            contents,
            expandedStates
          }));
        }
        if (doc3.contents) {
          const contents = rec(doc3.contents);
          return cb(Object.assign(Object.assign({}, doc3), {}, {
            contents
          }));
        }
        return cb(doc3);
      }
    }
    function findInDoc(doc2, fn, defaultValue) {
      let result = defaultValue;
      let hasStopped = false;
      function findInDocOnEnterFn(doc3) {
        const maybeResult = fn(doc3);
        if (maybeResult !== void 0) {
          hasStopped = true;
          result = maybeResult;
        }
        if (hasStopped) {
          return false;
        }
      }
      traverseDoc(doc2, findInDocOnEnterFn);
      return result;
    }
    function willBreakFn(doc2) {
      if (doc2.type === "group" && doc2.break) {
        return true;
      }
      if (doc2.type === "line" && doc2.hard) {
        return true;
      }
      if (doc2.type === "break-parent") {
        return true;
      }
    }
    function willBreak(doc2) {
      return findInDoc(doc2, willBreakFn, false);
    }
    function breakParentGroup(groupStack) {
      if (groupStack.length > 0) {
        const parentGroup = getLast(groupStack);
        if (!parentGroup.expandedStates && !parentGroup.break) {
          parentGroup.break = "propagated";
        }
      }
      return null;
    }
    function propagateBreaks(doc2) {
      const alreadyVisitedSet = /* @__PURE__ */ new Set();
      const groupStack = [];
      function propagateBreaksOnEnterFn(doc3) {
        if (doc3.type === "break-parent") {
          breakParentGroup(groupStack);
        }
        if (doc3.type === "group") {
          groupStack.push(doc3);
          if (alreadyVisitedSet.has(doc3)) {
            return false;
          }
          alreadyVisitedSet.add(doc3);
        }
      }
      function propagateBreaksOnExitFn(doc3) {
        if (doc3.type === "group") {
          const group = groupStack.pop();
          if (group.break) {
            breakParentGroup(groupStack);
          }
        }
      }
      traverseDoc(doc2, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);
    }
    function removeLinesFn(doc2) {
      if (doc2.type === "line" && !doc2.hard) {
        return doc2.soft ? "" : " ";
      }
      if (doc2.type === "if-break") {
        return doc2.flatContents || "";
      }
      return doc2;
    }
    function removeLines(doc2) {
      return mapDoc(doc2, removeLinesFn);
    }
    var isHardline = (doc2, nextDoc) => doc2 && doc2.type === "line" && doc2.hard && nextDoc && nextDoc.type === "break-parent";
    function stripDocTrailingHardlineFromDoc(doc2) {
      if (!doc2) {
        return doc2;
      }
      if (isConcat(doc2) || doc2.type === "fill") {
        const parts = getDocParts(doc2);
        while (parts.length > 1 && isHardline(...parts.slice(-2))) {
          parts.length -= 2;
        }
        if (parts.length > 0) {
          const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));
          parts[parts.length - 1] = lastPart;
        }
        return Array.isArray(doc2) ? parts : Object.assign(Object.assign({}, doc2), {}, {
          parts
        });
      }
      switch (doc2.type) {
        case "align":
        case "indent":
        case "indent-if-break":
        case "group":
        case "line-suffix":
        case "label": {
          const contents = stripDocTrailingHardlineFromDoc(doc2.contents);
          return Object.assign(Object.assign({}, doc2), {}, {
            contents
          });
        }
        case "if-break": {
          const breakContents = stripDocTrailingHardlineFromDoc(doc2.breakContents);
          const flatContents = stripDocTrailingHardlineFromDoc(doc2.flatContents);
          return Object.assign(Object.assign({}, doc2), {}, {
            breakContents,
            flatContents
          });
        }
      }
      return doc2;
    }
    function stripTrailingHardline(doc2) {
      return stripDocTrailingHardlineFromDoc(cleanDoc(doc2));
    }
    function cleanDocFn(doc2) {
      switch (doc2.type) {
        case "fill":
          if (doc2.parts.every((part) => part === "")) {
            return "";
          }
          break;
        case "group":
          if (!doc2.contents && !doc2.id && !doc2.break && !doc2.expandedStates) {
            return "";
          }
          if (doc2.contents.type === "group" && doc2.contents.id === doc2.id && doc2.contents.break === doc2.break && doc2.contents.expandedStates === doc2.expandedStates) {
            return doc2.contents;
          }
          break;
        case "align":
        case "indent":
        case "indent-if-break":
        case "line-suffix":
          if (!doc2.contents) {
            return "";
          }
          break;
        case "if-break":
          if (!doc2.flatContents && !doc2.breakContents) {
            return "";
          }
          break;
      }
      if (!isConcat(doc2)) {
        return doc2;
      }
      const parts = [];
      for (const part of getDocParts(doc2)) {
        if (!part) {
          continue;
        }
        const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];
        if (typeof currentPart === "string" && typeof getLast(parts) === "string") {
          parts[parts.length - 1] += currentPart;
        } else {
          parts.push(currentPart);
        }
        parts.push(...restParts);
      }
      if (parts.length === 0) {
        return "";
      }
      if (parts.length === 1) {
        return parts[0];
      }
      return Array.isArray(doc2) ? parts : Object.assign(Object.assign({}, doc2), {}, {
        parts
      });
    }
    function cleanDoc(doc2) {
      return mapDoc(doc2, (currentDoc) => cleanDocFn(currentDoc));
    }
    function normalizeParts(parts) {
      const newParts = [];
      const restParts = parts.filter(Boolean);
      while (restParts.length > 0) {
        const part = restParts.shift();
        if (!part) {
          continue;
        }
        if (isConcat(part)) {
          restParts.unshift(...getDocParts(part));
          continue;
        }
        if (newParts.length > 0 && typeof getLast(newParts) === "string" && typeof part === "string") {
          newParts[newParts.length - 1] += part;
          continue;
        }
        newParts.push(part);
      }
      return newParts;
    }
    function normalizeDoc(doc2) {
      return mapDoc(doc2, (currentDoc) => {
        if (Array.isArray(currentDoc)) {
          return normalizeParts(currentDoc);
        }
        if (!currentDoc.parts) {
          return currentDoc;
        }
        return Object.assign(Object.assign({}, currentDoc), {}, {
          parts: normalizeParts(currentDoc.parts)
        });
      });
    }
    function replaceEndOfLine(doc2) {
      return mapDoc(doc2, (currentDoc) => typeof currentDoc === "string" && currentDoc.includes("\n") ? replaceTextEndOfLine(currentDoc) : currentDoc);
    }
    function replaceTextEndOfLine(text, replacement = literalline) {
      return join(replacement, text.split("\n")).parts;
    }
    function canBreakFn(doc2) {
      if (doc2.type === "line") {
        return true;
      }
    }
    function canBreak(doc2) {
      return findInDoc(doc2, canBreakFn, false);
    }
    module2.exports = {
      isConcat,
      getDocParts,
      willBreak,
      traverseDoc,
      findInDoc,
      mapDoc,
      propagateBreaks,
      removeLines,
      stripTrailingHardline,
      normalizeParts,
      normalizeDoc,
      cleanDoc,
      replaceTextEndOfLine,
      replaceEndOfLine,
      canBreak
    };
  }
});
var require_misc = __commonJS2({
  "src/language-js/print/misc.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        indent,
        join,
        line
      }
    } = require("./doc.js");
    var {
      isFlowAnnotationComment
    } = require_utils7();
    function printOptionalToken(path) {
      const node = path.getValue();
      if (!node.optional || node.type === "Identifier" && node === path.getParentNode().key) {
        return "";
      }
      if (node.type === "OptionalCallExpression" || node.type === "OptionalMemberExpression" && node.computed) {
        return "?.";
      }
      return "?";
    }
    function printDefiniteToken(path) {
      return path.getValue().definite || path.match(void 0, (node, name) => name === "id" && node.type === "VariableDeclarator" && node.definite) ? "!" : "";
    }
    function printFunctionTypeParameters(path, options, print) {
      const fun = path.getValue();
      if (fun.typeArguments) {
        return print("typeArguments");
      }
      if (fun.typeParameters) {
        return print("typeParameters");
      }
      return "";
    }
    function printTypeAnnotation(path, options, print) {
      const node = path.getValue();
      if (!node.typeAnnotation) {
        return "";
      }
      const parentNode = path.getParentNode();
      const isFunctionDeclarationIdentifier = parentNode.type === "DeclareFunction" && parentNode.id === node;
      if (isFlowAnnotationComment(options.originalText, node.typeAnnotation)) {
        return [" /*: ", print("typeAnnotation"), " */"];
      }
      return [isFunctionDeclarationIdentifier ? "" : ": ", print("typeAnnotation")];
    }
    function printBindExpressionCallee(path, options, print) {
      return ["::", print("callee")];
    }
    function printTypeScriptModifiers(path, options, print) {
      const node = path.getValue();
      if (!isNonEmptyArray(node.modifiers)) {
        return "";
      }
      return [join(" ", path.map(print, "modifiers")), " "];
    }
    function adjustClause(node, clause, forceSpace) {
      if (node.type === "EmptyStatement") {
        return ";";
      }
      if (node.type === "BlockStatement" || forceSpace) {
        return [" ", clause];
      }
      return indent([line, clause]);
    }
    function printRestSpread(path, options, print) {
      return ["...", print("argument"), printTypeAnnotation(path, options, print)];
    }
    function printDirective(rawText, options) {
      const rawContent = rawText.slice(1, -1);
      if (rawContent.includes('"') || rawContent.includes("'")) {
        return rawText;
      }
      const enclosingQuote = options.singleQuote ? "'" : '"';
      return enclosingQuote + rawContent + enclosingQuote;
    }
    module2.exports = {
      printOptionalToken,
      printDefiniteToken,
      printFunctionTypeParameters,
      printBindExpressionCallee,
      printTypeScriptModifiers,
      printTypeAnnotation,
      printRestSpread,
      adjustClause,
      printDirective
    };
  }
});
var require_array4 = __commonJS2({
  "src/language-js/print/array.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      builders: {
        line,
        softline,
        hardline,
        group,
        indent,
        ifBreak,
        fill
      }
    } = require("./doc.js");
    var {
      getLast,
      hasNewline
    } = require_util();
    var {
      shouldPrintComma,
      hasComment,
      CommentCheckFlags,
      isNextLineEmpty,
      isNumericLiteral,
      isSignedNumericLiteral
    } = require_utils7();
    var {
      locStart
    } = require_loc();
    var {
      printOptionalToken,
      printTypeAnnotation
    } = require_misc();
    function printArray(path, options, print) {
      const node = path.getValue();
      const parts = [];
      const openBracket = node.type === "TupleExpression" ? "#[" : "[";
      const closeBracket = "]";
      if (node.elements.length === 0) {
        if (!hasComment(node, CommentCheckFlags.Dangling)) {
          parts.push(openBracket, closeBracket);
        } else {
          parts.push(group([openBracket, printDanglingComments(path, options), softline, closeBracket]));
        }
      } else {
        const lastElem = getLast(node.elements);
        const canHaveTrailingComma = !(lastElem && lastElem.type === "RestElement");
        const needsForcedTrailingComma = lastElem === null;
        const groupId = Symbol("array");
        const shouldBreak = !options.__inJestEach && node.elements.length > 1 && node.elements.every((element, i, elements) => {
          const elementType = element && element.type;
          if (elementType !== "ArrayExpression" && elementType !== "ObjectExpression") {
            return false;
          }
          const nextElement = elements[i + 1];
          if (nextElement && elementType !== nextElement.type) {
            return false;
          }
          const itemsKey = elementType === "ArrayExpression" ? "elements" : "properties";
          return element[itemsKey] && element[itemsKey].length > 1;
        });
        const shouldUseConciseFormatting = isConciselyPrintedArray(node, options);
        const trailingComma = !canHaveTrailingComma ? "" : needsForcedTrailingComma ? "," : !shouldPrintComma(options) ? "" : shouldUseConciseFormatting ? ifBreak(",", "", {
          groupId
        }) : ifBreak(",");
        parts.push(group([openBracket, indent([softline, shouldUseConciseFormatting ? printArrayItemsConcisely(path, options, print, trailingComma) : [printArrayItems(path, options, "elements", print), trailingComma], printDanglingComments(path, options, true)]), softline, closeBracket], {
          shouldBreak,
          id: groupId
        }));
      }
      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));
      return parts;
    }
    function isConciselyPrintedArray(node, options) {
      return node.elements.length > 1 && node.elements.every((element) => element && (isNumericLiteral(element) || isSignedNumericLiteral(element) && !hasComment(element.argument)) && !hasComment(element, CommentCheckFlags.Trailing | CommentCheckFlags.Line, (comment) => !hasNewline(options.originalText, locStart(comment), {
        backwards: true
      })));
    }
    function printArrayItems(path, options, printPath, print) {
      const printedElements = [];
      let separatorParts = [];
      path.each((childPath) => {
        printedElements.push(separatorParts, group(print()));
        separatorParts = [",", line];
        if (childPath.getValue() && isNextLineEmpty(childPath.getValue(), options)) {
          separatorParts.push(softline);
        }
      }, printPath);
      return printedElements;
    }
    function printArrayItemsConcisely(path, options, print, trailingComma) {
      const parts = [];
      path.each((childPath, i, elements) => {
        const isLast = i === elements.length - 1;
        parts.push([print(), isLast ? trailingComma : ","]);
        if (!isLast) {
          parts.push(isNextLineEmpty(childPath.getValue(), options) ? [hardline, hardline] : hasComment(elements[i + 1], CommentCheckFlags.Leading | CommentCheckFlags.Line) ? hardline : line);
        }
      }, "elements");
      return fill(parts);
    }
    module2.exports = {
      printArray,
      printArrayItems,
      isConciselyPrintedArray
    };
  }
});
var require_call_arguments = __commonJS2({
  "src/language-js/print/call-arguments.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      getLast,
      getPenultimate
    } = require_util();
    var {
      getFunctionParameters,
      hasComment,
      CommentCheckFlags,
      isFunctionCompositionArgs,
      isJsxNode,
      isLongCurriedCallExpression,
      shouldPrintComma,
      getCallArguments,
      iterateCallArgumentsPath,
      isNextLineEmpty,
      isCallExpression,
      isStringLiteral,
      isObjectProperty,
      isTSTypeExpression
    } = require_utils7();
    var {
      builders: {
        line,
        hardline,
        softline,
        group,
        indent,
        conditionalGroup,
        ifBreak,
        breakParent
      },
      utils: {
        willBreak
      }
    } = require("./doc.js");
    var {
      ArgExpansionBailout
    } = require_errors();
    var {
      isConciselyPrintedArray
    } = require_array4();
    function printCallArguments(path, options, print) {
      const node = path.getValue();
      const isDynamicImport = node.type === "ImportExpression";
      const args = getCallArguments(node);
      if (args.length === 0) {
        return ["(", printDanglingComments(path, options, true), ")"];
      }
      if (isReactHookCallWithDepsArray(args)) {
        return ["(", print(["arguments", 0]), ", ", print(["arguments", 1]), ")"];
      }
      let anyArgEmptyLine = false;
      let hasEmptyLineFollowingFirstArg = false;
      const lastArgIndex = args.length - 1;
      const printedArguments = [];
      iterateCallArgumentsPath(path, (argPath, index) => {
        const arg = argPath.getNode();
        const parts = [print()];
        if (index === lastArgIndex) {
        } else if (isNextLineEmpty(arg, options)) {
          if (index === 0) {
            hasEmptyLineFollowingFirstArg = true;
          }
          anyArgEmptyLine = true;
          parts.push(",", hardline, hardline);
        } else {
          parts.push(",", line);
        }
        printedArguments.push(parts);
      });
      const maybeTrailingComma = !(isDynamicImport || node.callee && node.callee.type === "Import") && shouldPrintComma(options, "all") ? "," : "";
      function allArgsBrokenOut() {
        return group(["(", indent([line, ...printedArguments]), maybeTrailingComma, line, ")"], {
          shouldBreak: true
        });
      }
      if (anyArgEmptyLine || path.getParentNode().type !== "Decorator" && isFunctionCompositionArgs(args)) {
        return allArgsBrokenOut();
      }
      const shouldGroupFirst = shouldGroupFirstArg(args);
      const shouldGroupLast = shouldGroupLastArg(args, options);
      if (shouldGroupFirst || shouldGroupLast) {
        if (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) {
          return allArgsBrokenOut();
        }
        let printedExpanded = [];
        try {
          path.try(() => {
            iterateCallArgumentsPath(path, (argPath, i) => {
              if (shouldGroupFirst && i === 0) {
                printedExpanded = [[print([], {
                  expandFirstArg: true
                }), printedArguments.length > 1 ? "," : "", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : ""], ...printedArguments.slice(1)];
              }
              if (shouldGroupLast && i === lastArgIndex) {
                printedExpanded = [...printedArguments.slice(0, -1), print([], {
                  expandLastArg: true
                })];
              }
            });
          });
        } catch (caught) {
          if (caught instanceof ArgExpansionBailout) {
            return allArgsBrokenOut();
          }
          throw caught;
        }
        return [printedArguments.some(willBreak) ? breakParent : "", conditionalGroup([["(", ...printedExpanded, ")"], shouldGroupFirst ? ["(", group(printedExpanded[0], {
          shouldBreak: true
        }), ...printedExpanded.slice(1), ")"] : ["(", ...printedArguments.slice(0, -1), group(getLast(printedExpanded), {
          shouldBreak: true
        }), ")"], allArgsBrokenOut()])];
      }
      const contents = ["(", indent([softline, ...printedArguments]), ifBreak(maybeTrailingComma), softline, ")"];
      if (isLongCurriedCallExpression(path)) {
        return contents;
      }
      return group(contents, {
        shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine
      });
    }
    function couldGroupArg(arg, arrowChainRecursion = false) {
      return arg.type === "ObjectExpression" && (arg.properties.length > 0 || hasComment(arg)) || arg.type === "ArrayExpression" && (arg.elements.length > 0 || hasComment(arg)) || arg.type === "TSTypeAssertion" && couldGroupArg(arg.expression) || isTSTypeExpression(arg) && couldGroupArg(arg.expression) || arg.type === "FunctionExpression" || arg.type === "ArrowFunctionExpression" && (!arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== "TSTypeReference" || isNonEmptyBlockStatement(arg.body)) && (arg.body.type === "BlockStatement" || arg.body.type === "ArrowFunctionExpression" && couldGroupArg(arg.body, true) || arg.body.type === "ObjectExpression" || arg.body.type === "ArrayExpression" || !arrowChainRecursion && (isCallExpression(arg.body) || arg.body.type === "ConditionalExpression") || isJsxNode(arg.body)) || arg.type === "DoExpression" || arg.type === "ModuleExpression";
    }
    function shouldGroupLastArg(args, options) {
      const lastArg = getLast(args);
      const penultimateArg = getPenultimate(args);
      return !hasComment(lastArg, CommentCheckFlags.Leading) && !hasComment(lastArg, CommentCheckFlags.Trailing) && couldGroupArg(lastArg) && (!penultimateArg || penultimateArg.type !== lastArg.type) && (args.length !== 2 || penultimateArg.type !== "ArrowFunctionExpression" || lastArg.type !== "ArrayExpression") && !(args.length > 1 && lastArg.type === "ArrayExpression" && isConciselyPrintedArray(lastArg, options));
    }
    function shouldGroupFirstArg(args) {
      if (args.length !== 2) {
        return false;
      }
      const [firstArg, secondArg] = args;
      if (firstArg.type === "ModuleExpression" && isTypeModuleObjectExpression(secondArg)) {
        return true;
      }
      return !hasComment(firstArg) && (firstArg.type === "FunctionExpression" || firstArg.type === "ArrowFunctionExpression" && firstArg.body.type === "BlockStatement") && secondArg.type !== "FunctionExpression" && secondArg.type !== "ArrowFunctionExpression" && secondArg.type !== "ConditionalExpression" && !couldGroupArg(secondArg);
    }
    function isReactHookCallWithDepsArray(args) {
      return args.length === 2 && args[0].type === "ArrowFunctionExpression" && getFunctionParameters(args[0]).length === 0 && args[0].body.type === "BlockStatement" && args[1].type === "ArrayExpression" && !args.some((arg) => hasComment(arg));
    }
    function isNonEmptyBlockStatement(node) {
      return node.type === "BlockStatement" && (node.body.some((node2) => node2.type !== "EmptyStatement") || hasComment(node, CommentCheckFlags.Dangling));
    }
    function isTypeModuleObjectExpression(node) {
      return node.type === "ObjectExpression" && node.properties.length === 1 && isObjectProperty(node.properties[0]) && node.properties[0].key.type === "Identifier" && node.properties[0].key.name === "type" && isStringLiteral(node.properties[0].value) && node.properties[0].value.value === "module";
    }
    module2.exports = printCallArguments;
  }
});
var require_member = __commonJS2({
  "src/language-js/print/member.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        softline,
        group,
        indent,
        label
      }
    } = require("./doc.js");
    var {
      isNumericLiteral,
      isMemberExpression,
      isCallExpression
    } = require_utils7();
    var {
      printOptionalToken
    } = require_misc();
    function printMemberExpression(path, options, print) {
      const node = path.getValue();
      const parent = path.getParentNode();
      let firstNonMemberParent;
      let i = 0;
      do {
        firstNonMemberParent = path.getParentNode(i);
        i++;
      } while (firstNonMemberParent && (isMemberExpression(firstNonMemberParent) || firstNonMemberParent.type === "TSNonNullExpression"));
      const objectDoc = print("object");
      const lookupDoc = printMemberLookup(path, options, print);
      const shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || node.computed || node.object.type === "Identifier" && node.property.type === "Identifier" && !isMemberExpression(parent) || (parent.type === "AssignmentExpression" || parent.type === "VariableDeclarator") && (isCallExpression(node.object) && node.object.arguments.length > 0 || node.object.type === "TSNonNullExpression" && isCallExpression(node.object.expression) && node.object.expression.arguments.length > 0 || objectDoc.label === "member-chain");
      return label(objectDoc.label === "member-chain" ? "member-chain" : "member", [objectDoc, shouldInline ? lookupDoc : group(indent([softline, lookupDoc]))]);
    }
    function printMemberLookup(path, options, print) {
      const property = print("property");
      const node = path.getValue();
      const optional = printOptionalToken(path);
      if (!node.computed) {
        return [optional, ".", property];
      }
      if (!node.property || isNumericLiteral(node.property)) {
        return [optional, "[", property, "]"];
      }
      return group([optional, "[", indent([softline, property]), softline, "]"]);
    }
    module2.exports = {
      printMemberExpression,
      printMemberLookup
    };
  }
});
var require_member_chain = __commonJS2({
  "src/language-js/print/member-chain.js"(exports2, module2) {
    "use strict";
    var {
      printComments
    } = require_comments();
    var {
      getLast,
      isNextLineEmptyAfterIndex,
      getNextNonSpaceNonCommentCharacterIndex
    } = require_util();
    var pathNeedsParens = require_needs_parens();
    var {
      isCallExpression,
      isMemberExpression,
      isFunctionOrArrowExpression,
      isLongCurriedCallExpression,
      isMemberish,
      isNumericLiteral,
      isSimpleCallArgument,
      hasComment,
      CommentCheckFlags,
      isNextLineEmpty
    } = require_utils7();
    var {
      locEnd
    } = require_loc();
    var {
      builders: {
        join,
        hardline,
        group,
        indent,
        conditionalGroup,
        breakParent,
        label
      },
      utils: {
        willBreak
      }
    } = require("./doc.js");
    var printCallArguments = require_call_arguments();
    var {
      printMemberLookup
    } = require_member();
    var {
      printOptionalToken,
      printFunctionTypeParameters,
      printBindExpressionCallee
    } = require_misc();
    function printMemberChain(path, options, print) {
      const parent = path.getParentNode();
      const isExpressionStatement = !parent || parent.type === "ExpressionStatement";
      const printedNodes = [];
      function shouldInsertEmptyLineAfter(node2) {
        const {
          originalText
        } = options;
        const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node2, locEnd);
        const nextChar = originalText.charAt(nextCharIndex);
        if (nextChar === ")") {
          return nextCharIndex !== false && isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1);
        }
        return isNextLineEmpty(node2, options);
      }
      function rec(path2) {
        const node2 = path2.getValue();
        if (isCallExpression(node2) && (isMemberish(node2.callee) || isCallExpression(node2.callee))) {
          printedNodes.unshift({
            node: node2,
            printed: [printComments(path2, [printOptionalToken(path2), printFunctionTypeParameters(path2, options, print), printCallArguments(path2, options, print)], options), shouldInsertEmptyLineAfter(node2) ? hardline : ""]
          });
          path2.call((callee) => rec(callee), "callee");
        } else if (isMemberish(node2)) {
          printedNodes.unshift({
            node: node2,
            needsParens: pathNeedsParens(path2, options),
            printed: printComments(path2, isMemberExpression(node2) ? printMemberLookup(path2, options, print) : printBindExpressionCallee(path2, options, print), options)
          });
          path2.call((object) => rec(object), "object");
        } else if (node2.type === "TSNonNullExpression") {
          printedNodes.unshift({
            node: node2,
            printed: printComments(path2, "!", options)
          });
          path2.call((expression) => rec(expression), "expression");
        } else {
          printedNodes.unshift({
            node: node2,
            printed: print()
          });
        }
      }
      const node = path.getValue();
      printedNodes.unshift({
        node,
        printed: [printOptionalToken(path), printFunctionTypeParameters(path, options, print), printCallArguments(path, options, print)]
      });
      if (node.callee) {
        path.call((callee) => rec(callee), "callee");
      }
      const groups = [];
      let currentGroup = [printedNodes[0]];
      let i = 1;
      for (; i < printedNodes.length; ++i) {
        if (printedNodes[i].node.type === "TSNonNullExpression" || isCallExpression(printedNodes[i].node) || isMemberExpression(printedNodes[i].node) && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {
          currentGroup.push(printedNodes[i]);
        } else {
          break;
        }
      }
      if (!isCallExpression(printedNodes[0].node)) {
        for (; i + 1 < printedNodes.length; ++i) {
          if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {
            currentGroup.push(printedNodes[i]);
          } else {
            break;
          }
        }
      }
      groups.push(currentGroup);
      currentGroup = [];
      let hasSeenCallExpression = false;
      for (; i < printedNodes.length; ++i) {
        if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {
          if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {
            currentGroup.push(printedNodes[i]);
            continue;
          }
          groups.push(currentGroup);
          currentGroup = [];
          hasSeenCallExpression = false;
        }
        if (isCallExpression(printedNodes[i].node) || printedNodes[i].node.type === "ImportExpression") {
          hasSeenCallExpression = true;
        }
        currentGroup.push(printedNodes[i]);
        if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {
          groups.push(currentGroup);
          currentGroup = [];
          hasSeenCallExpression = false;
        }
      }
      if (currentGroup.length > 0) {
        groups.push(currentGroup);
      }
      function isFactory(name) {
        return /^[A-Z]|^[$_]+$/.test(name);
      }
      function isShort(name) {
        return name.length <= options.tabWidth;
      }
      function shouldNotWrap(groups2) {
        const hasComputed = groups2[1].length > 0 && groups2[1][0].node.computed;
        if (groups2[0].length === 1) {
          const firstNode = groups2[0][0].node;
          return firstNode.type === "ThisExpression" || firstNode.type === "Identifier" && (isFactory(firstNode.name) || isExpressionStatement && isShort(firstNode.name) || hasComputed);
        }
        const lastNode = getLast(groups2[0]).node;
        return isMemberExpression(lastNode) && lastNode.property.type === "Identifier" && (isFactory(lastNode.property.name) || hasComputed);
      }
      const shouldMerge = groups.length >= 2 && !hasComment(groups[1][0].node) && shouldNotWrap(groups);
      function printGroup(printedGroup) {
        const printed = printedGroup.map((tuple) => tuple.printed);
        if (printedGroup.length > 0 && getLast(printedGroup).needsParens) {
          return ["(", ...printed, ")"];
        }
        return printed;
      }
      function printIndentedGroup(groups2) {
        if (groups2.length === 0) {
          return "";
        }
        return indent(group([hardline, join(hardline, groups2.map(printGroup))]));
      }
      const printedGroups = groups.map(printGroup);
      const oneLine = printedGroups;
      const cutoff = shouldMerge ? 3 : 2;
      const flatGroups = groups.flat();
      const nodeHasComment = flatGroups.slice(1, -1).some((node2) => hasComment(node2.node, CommentCheckFlags.Leading)) || flatGroups.slice(0, -1).some((node2) => hasComment(node2.node, CommentCheckFlags.Trailing)) || groups[cutoff] && hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading);
      if (groups.length <= cutoff && !nodeHasComment) {
        if (isLongCurriedCallExpression(path)) {
          return oneLine;
        }
        return group(oneLine);
      }
      const lastNodeBeforeIndent = getLast(groups[shouldMerge ? 1 : 0]).node;
      const shouldHaveEmptyLineBeforeIndent = !isCallExpression(lastNodeBeforeIndent) && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
      const expanded = [printGroup(groups[0]), shouldMerge ? groups.slice(1, 2).map(printGroup) : "", shouldHaveEmptyLineBeforeIndent ? hardline : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))];
      const callExpressions = printedNodes.map(({
        node: node2
      }) => node2).filter(isCallExpression);
      function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {
        const lastGroupNode = getLast(getLast(groups)).node;
        const lastGroupDoc = getLast(printedGroups);
        return isCallExpression(lastGroupNode) && willBreak(lastGroupDoc) && callExpressions.slice(0, -1).some((node2) => node2.arguments.some(isFunctionOrArrowExpression));
      }
      let result;
      if (nodeHasComment || callExpressions.length > 2 && callExpressions.some((expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg, 0))) || printedGroups.slice(0, -1).some(willBreak) || lastGroupWillBreakAndOtherCallsHaveFunctionArguments()) {
        result = group(expanded);
      } else {
        result = [willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : "", conditionalGroup([oneLine, expanded])];
      }
      return label("member-chain", result);
    }
    module2.exports = printMemberChain;
  }
});
var require_call_expression = __commonJS2({
  "src/language-js/print/call-expression.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        join,
        group
      }
    } = require("./doc.js");
    var pathNeedsParens = require_needs_parens();
    var {
      getCallArguments,
      hasFlowAnnotationComment,
      isCallExpression,
      isMemberish,
      isStringLiteral,
      isTemplateOnItsOwnLine,
      isTestCall,
      iterateCallArgumentsPath
    } = require_utils7();
    var printMemberChain = require_member_chain();
    var printCallArguments = require_call_arguments();
    var {
      printOptionalToken,
      printFunctionTypeParameters
    } = require_misc();
    function printCallExpression(path, options, print) {
      const node = path.getValue();
      const parentNode = path.getParentNode();
      const isNew = node.type === "NewExpression";
      const isDynamicImport = node.type === "ImportExpression";
      const optional = printOptionalToken(path);
      const args = getCallArguments(node);
      if (args.length > 0 && (!isDynamicImport && !isNew && isCommonsJsOrAmdCall(node, parentNode) || args.length === 1 && isTemplateOnItsOwnLine(args[0], options.originalText) || !isNew && isTestCall(node, parentNode))) {
        const printed = [];
        iterateCallArgumentsPath(path, () => {
          printed.push(print());
        });
        return [isNew ? "new " : "", print("callee"), optional, printFunctionTypeParameters(path, options, print), "(", join(", ", printed), ")"];
      }
      const isIdentifierWithFlowAnnotation = (options.parser === "babel" || options.parser === "babel-flow") && node.callee && node.callee.type === "Identifier" && hasFlowAnnotationComment(node.callee.trailingComments);
      if (isIdentifierWithFlowAnnotation) {
        node.callee.trailingComments[0].printed = true;
      }
      if (!isDynamicImport && !isNew && isMemberish(node.callee) && !path.call((path2) => pathNeedsParens(path2, options), "callee")) {
        return printMemberChain(path, options, print);
      }
      const contents = [isNew ? "new " : "", isDynamicImport ? "import" : print("callee"), optional, isIdentifierWithFlowAnnotation ? `/*:: ${node.callee.trailingComments[0].value.slice(2).trim()} */` : "", printFunctionTypeParameters(path, options, print), printCallArguments(path, options, print)];
      if (isDynamicImport || isCallExpression(node.callee)) {
        return group(contents);
      }
      return contents;
    }
    function isCommonsJsOrAmdCall(node, parentNode) {
      if (node.callee.type !== "Identifier") {
        return false;
      }
      if (node.callee.name === "require") {
        return true;
      }
      if (node.callee.name === "define") {
        const args = getCallArguments(node);
        return parentNode.type === "ExpressionStatement" && (args.length === 1 || args.length === 2 && args[0].type === "ArrayExpression" || args.length === 3 && isStringLiteral(args[0]) && args[1].type === "ArrayExpression");
      }
      return false;
    }
    module2.exports = {
      printCallExpression
    };
  }
});
var require_assignment = __commonJS2({
  "src/language-js/print/assignment.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray,
      getStringWidth
    } = require_util();
    var {
      builders: {
        line,
        group,
        indent,
        indentIfBreak,
        lineSuffixBoundary
      },
      utils: {
        cleanDoc,
        willBreak,
        canBreak
      }
    } = require("./doc.js");
    var {
      hasLeadingOwnLineComment,
      isBinaryish,
      isStringLiteral,
      isLiteral,
      isNumericLiteral,
      isCallExpression,
      isMemberExpression,
      getCallArguments,
      rawText,
      hasComment,
      isSignedNumericLiteral,
      isObjectProperty
    } = require_utils7();
    var {
      shouldInlineLogicalExpression
    } = require_binaryish();
    var {
      printCallExpression
    } = require_call_expression();
    function printAssignment(path, options, print, leftDoc, operator, rightPropertyName) {
      const layout = chooseLayout(path, options, print, leftDoc, rightPropertyName);
      const rightDoc = print(rightPropertyName, {
        assignmentLayout: layout
      });
      switch (layout) {
        case "break-after-operator":
          return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);
        case "never-break-after-operator":
          return group([group(leftDoc), operator, " ", rightDoc]);
        case "fluid": {
          const groupId = Symbol("assignment");
          return group([group(leftDoc), operator, group(indent(line), {
            id: groupId
          }), lineSuffixBoundary, indentIfBreak(rightDoc, {
            groupId
          })]);
        }
        case "break-lhs":
          return group([leftDoc, operator, " ", group(rightDoc)]);
        case "chain":
          return [group(leftDoc), operator, line, rightDoc];
        case "chain-tail":
          return [group(leftDoc), operator, indent([line, rightDoc])];
        case "chain-tail-arrow-chain":
          return [group(leftDoc), operator, rightDoc];
        case "only-left":
          return leftDoc;
      }
    }
    function printAssignmentExpression(path, options, print) {
      const node = path.getValue();
      return printAssignment(path, options, print, print("left"), [" ", node.operator], "right");
    }
    function printVariableDeclarator(path, options, print) {
      return printAssignment(path, options, print, print("id"), " =", "init");
    }
    function chooseLayout(path, options, print, leftDoc, rightPropertyName) {
      const node = path.getValue();
      const rightNode = node[rightPropertyName];
      if (!rightNode) {
        return "only-left";
      }
      const isTail = !isAssignment(rightNode);
      const shouldUseChainFormatting = path.match(isAssignment, isAssignmentOrVariableDeclarator, (node2) => !isTail || node2.type !== "ExpressionStatement" && node2.type !== "VariableDeclaration");
      if (shouldUseChainFormatting) {
        return !isTail ? "chain" : rightNode.type === "ArrowFunctionExpression" && rightNode.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail";
      }
      const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);
      if (isHeadOfLongChain || hasLeadingOwnLineComment(options.originalText, rightNode)) {
        return "break-after-operator";
      }
      if (rightNode.type === "CallExpression" && rightNode.callee.name === "require" || options.parser === "json5" || options.parser === "json") {
        return "never-break-after-operator";
      }
      if (isComplexDestructuring(node) || isComplexTypeAliasParams(node) || hasComplexTypeAnnotation(node) || isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc)) {
        return "break-lhs";
      }
      const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options);
      if (path.call(() => shouldBreakAfterOperator(path, options, print, hasShortKey), rightPropertyName)) {
        return "break-after-operator";
      }
      if (hasShortKey || rightNode.type === "TemplateLiteral" || rightNode.type === "TaggedTemplateExpression" || rightNode.type === "BooleanLiteral" || isNumericLiteral(rightNode) || rightNode.type === "ClassExpression") {
        return "never-break-after-operator";
      }
      return "fluid";
    }
    function shouldBreakAfterOperator(path, options, print, hasShortKey) {
      const rightNode = path.getValue();
      if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {
        return true;
      }
      switch (rightNode.type) {
        case "StringLiteralTypeAnnotation":
        case "SequenceExpression":
          return true;
        case "ConditionalExpression": {
          const {
            test
          } = rightNode;
          return isBinaryish(test) && !shouldInlineLogicalExpression(test);
        }
        case "ClassExpression":
          return isNonEmptyArray(rightNode.decorators);
      }
      if (hasShortKey) {
        return false;
      }
      let node = rightNode;
      const propertiesForPath = [];
      for (; ; ) {
        if (node.type === "UnaryExpression") {
          node = node.argument;
          propertiesForPath.push("argument");
        } else if (node.type === "TSNonNullExpression") {
          node = node.expression;
          propertiesForPath.push("expression");
        } else {
          break;
        }
      }
      if (isStringLiteral(node) || path.call(() => isPoorlyBreakableMemberOrCallChain(path, options, print), ...propertiesForPath)) {
        return true;
      }
      return false;
    }
    function isComplexDestructuring(node) {
      if (isAssignmentOrVariableDeclarator(node)) {
        const leftNode = node.left || node.id;
        return leftNode.type === "ObjectPattern" && leftNode.properties.length > 2 && leftNode.properties.some((property) => isObjectProperty(property) && (!property.shorthand || property.value && property.value.type === "AssignmentPattern"));
      }
      return false;
    }
    function isAssignment(node) {
      return node.type === "AssignmentExpression";
    }
    function isAssignmentOrVariableDeclarator(node) {
      return isAssignment(node) || node.type === "VariableDeclarator";
    }
    function isComplexTypeAliasParams(node) {
      const typeParams = getTypeParametersFromTypeAlias(node);
      if (isNonEmptyArray(typeParams)) {
        const constraintPropertyName = node.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
        if (typeParams.length > 1 && typeParams.some((param) => param[constraintPropertyName] || param.default)) {
          return true;
        }
      }
      return false;
    }
    function getTypeParametersFromTypeAlias(node) {
      if (isTypeAlias(node) && node.typeParameters && node.typeParameters.params) {
        return node.typeParameters.params;
      }
      return null;
    }
    function isTypeAlias(node) {
      return node.type === "TSTypeAliasDeclaration" || node.type === "TypeAlias";
    }
    function hasComplexTypeAnnotation(node) {
      if (node.type !== "VariableDeclarator") {
        return false;
      }
      const {
        typeAnnotation
      } = node.id;
      if (!typeAnnotation || !typeAnnotation.typeAnnotation) {
        return false;
      }
      const typeParams = getTypeParametersFromTypeReference(typeAnnotation.typeAnnotation);
      return isNonEmptyArray(typeParams) && typeParams.length > 1 && typeParams.some((param) => isNonEmptyArray(getTypeParametersFromTypeReference(param)) || param.type === "TSConditionalType");
    }
    function isArrowFunctionVariableDeclarator(node) {
      return node.type === "VariableDeclarator" && node.init && node.init.type === "ArrowFunctionExpression";
    }
    function getTypeParametersFromTypeReference(node) {
      if (isTypeReference(node) && node.typeParameters && node.typeParameters.params) {
        return node.typeParameters.params;
      }
      return null;
    }
    function isTypeReference(node) {
      return node.type === "TSTypeReference" || node.type === "GenericTypeAnnotation";
    }
    function isPoorlyBreakableMemberOrCallChain(path, options, print, deep = false) {
      const node = path.getValue();
      const goDeeper = () => isPoorlyBreakableMemberOrCallChain(path, options, print, true);
      if (node.type === "TSNonNullExpression") {
        return path.call(goDeeper, "expression");
      }
      if (isCallExpression(node)) {
        const doc2 = printCallExpression(path, options, print);
        if (doc2.label === "member-chain") {
          return false;
        }
        const args = getCallArguments(node);
        const isPoorlyBreakableCall = args.length === 0 || args.length === 1 && isLoneShortArgument(args[0], options);
        if (!isPoorlyBreakableCall) {
          return false;
        }
        if (isCallExpressionWithComplexTypeArguments(node, print)) {
          return false;
        }
        return path.call(goDeeper, "callee");
      }
      if (isMemberExpression(node)) {
        return path.call(goDeeper, "object");
      }
      return deep && (node.type === "Identifier" || node.type === "ThisExpression");
    }
    var LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;
    function isLoneShortArgument(node, {
      printWidth
    }) {
      if (hasComment(node)) {
        return false;
      }
      const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;
      if (node.type === "ThisExpression" || node.type === "Identifier" && node.name.length <= threshold || isSignedNumericLiteral(node) && !hasComment(node.argument)) {
        return true;
      }
      const regexpPattern = node.type === "Literal" && "regex" in node && node.regex.pattern || node.type === "RegExpLiteral" && node.pattern;
      if (regexpPattern) {
        return regexpPattern.length <= threshold;
      }
      if (isStringLiteral(node)) {
        return rawText(node).length <= threshold;
      }
      if (node.type === "TemplateLiteral") {
        return node.expressions.length === 0 && node.quasis[0].value.raw.length <= threshold && !node.quasis[0].value.raw.includes("\n");
      }
      return isLiteral(node);
    }
    function isObjectPropertyWithShortKey(node, keyDoc, options) {
      if (!isObjectProperty(node)) {
        return false;
      }
      keyDoc = cleanDoc(keyDoc);
      const MIN_OVERLAP_FOR_BREAK = 3;
      return typeof keyDoc === "string" && getStringWidth(keyDoc) < options.tabWidth + MIN_OVERLAP_FOR_BREAK;
    }
    function isCallExpressionWithComplexTypeArguments(node, print) {
      const typeArgs = getTypeArgumentsFromCallExpression(node);
      if (isNonEmptyArray(typeArgs)) {
        if (typeArgs.length > 1) {
          return true;
        }
        if (typeArgs.length === 1) {
          const firstArg = typeArgs[0];
          if (firstArg.type === "TSUnionType" || firstArg.type === "UnionTypeAnnotation" || firstArg.type === "TSIntersectionType" || firstArg.type === "IntersectionTypeAnnotation" || firstArg.type === "TSTypeLiteral" || firstArg.type === "ObjectTypeAnnotation") {
            return true;
          }
        }
        const typeArgsKeyName = node.typeParameters ? "typeParameters" : "typeArguments";
        if (willBreak(print(typeArgsKeyName))) {
          return true;
        }
      }
      return false;
    }
    function getTypeArgumentsFromCallExpression(node) {
      return node.typeParameters && node.typeParameters.params || node.typeArguments && node.typeArguments.params;
    }
    module2.exports = {
      printVariableDeclarator,
      printAssignmentExpression,
      printAssignment,
      isArrowFunctionVariableDeclarator
    };
  }
});
var require_function_parameters = __commonJS2({
  "src/language-js/print/function-parameters.js"(exports2, module2) {
    "use strict";
    var {
      getNextNonSpaceNonCommentCharacter
    } = require_util();
    var {
      printDanglingComments
    } = require_comments();
    var {
      builders: {
        line,
        hardline,
        softline,
        group,
        indent,
        ifBreak
      },
      utils: {
        removeLines,
        willBreak
      }
    } = require("./doc.js");
    var {
      getFunctionParameters,
      iterateFunctionParametersPath,
      isSimpleType,
      isTestCall,
      isTypeAnnotationAFunction,
      isObjectType,
      isObjectTypePropertyAFunction,
      hasRestParameter,
      shouldPrintComma,
      hasComment,
      isNextLineEmpty
    } = require_utils7();
    var {
      locEnd
    } = require_loc();
    var {
      ArgExpansionBailout
    } = require_errors();
    var {
      printFunctionTypeParameters
    } = require_misc();
    function printFunctionParameters(path, print, options, expandArg, printTypeParams) {
      const functionNode = path.getValue();
      const parameters = getFunctionParameters(functionNode);
      const typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : "";
      if (parameters.length === 0) {
        return [typeParams, "(", printDanglingComments(path, options, true, (comment) => getNextNonSpaceNonCommentCharacter(options.originalText, comment, locEnd) === ")"), ")"];
      }
      const parent = path.getParentNode();
      const isParametersInTestCall = isTestCall(parent);
      const shouldHugParameters = shouldHugFunctionParameters(functionNode);
      const printed = [];
      iterateFunctionParametersPath(path, (parameterPath, index) => {
        const isLastParameter = index === parameters.length - 1;
        if (isLastParameter && functionNode.rest) {
          printed.push("...");
        }
        printed.push(print());
        if (isLastParameter) {
          return;
        }
        printed.push(",");
        if (isParametersInTestCall || shouldHugParameters) {
          printed.push(" ");
        } else if (isNextLineEmpty(parameters[index], options)) {
          printed.push(hardline, hardline);
        } else {
          printed.push(line);
        }
      });
      if (expandArg) {
        if (willBreak(typeParams) || willBreak(printed)) {
          throw new ArgExpansionBailout();
        }
        return group([removeLines(typeParams), "(", removeLines(printed), ")"]);
      }
      const hasNotParameterDecorator = parameters.every((node) => !node.decorators);
      if (shouldHugParameters && hasNotParameterDecorator) {
        return [typeParams, "(", ...printed, ")"];
      }
      if (isParametersInTestCall) {
        return [typeParams, "(", ...printed, ")"];
      }
      const isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent) || isTypeAnnotationAFunction(parent) || parent.type === "TypeAlias" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || parent.type === "IntersectionTypeAnnotation" || parent.type === "FunctionTypeAnnotation" && parent.returnType === functionNode) && parameters.length === 1 && parameters[0].name === null && functionNode.this !== parameters[0] && parameters[0].typeAnnotation && functionNode.typeParameters === null && isSimpleType(parameters[0].typeAnnotation) && !functionNode.rest;
      if (isFlowShorthandWithOneArg) {
        if (options.arrowParens === "always") {
          return ["(", ...printed, ")"];
        }
        return printed;
      }
      return [typeParams, "(", indent([softline, ...printed]), ifBreak(!hasRestParameter(functionNode) && shouldPrintComma(options, "all") ? "," : ""), softline, ")"];
    }
    function shouldHugFunctionParameters(node) {
      if (!node) {
        return false;
      }
      const parameters = getFunctionParameters(node);
      if (parameters.length !== 1) {
        return false;
      }
      const [parameter] = parameters;
      return !hasComment(parameter) && (parameter.type === "ObjectPattern" || parameter.type === "ArrayPattern" || parameter.type === "Identifier" && parameter.typeAnnotation && (parameter.typeAnnotation.type === "TypeAnnotation" || parameter.typeAnnotation.type === "TSTypeAnnotation") && isObjectType(parameter.typeAnnotation.typeAnnotation) || parameter.type === "FunctionTypeParam" && isObjectType(parameter.typeAnnotation) || parameter.type === "AssignmentPattern" && (parameter.left.type === "ObjectPattern" || parameter.left.type === "ArrayPattern") && (parameter.right.type === "Identifier" || parameter.right.type === "ObjectExpression" && parameter.right.properties.length === 0 || parameter.right.type === "ArrayExpression" && parameter.right.elements.length === 0));
    }
    function getReturnTypeNode(functionNode) {
      let returnTypeNode;
      if (functionNode.returnType) {
        returnTypeNode = functionNode.returnType;
        if (returnTypeNode.typeAnnotation) {
          returnTypeNode = returnTypeNode.typeAnnotation;
        }
      } else if (functionNode.typeAnnotation) {
        returnTypeNode = functionNode.typeAnnotation;
      }
      return returnTypeNode;
    }
    function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {
      const returnTypeNode = getReturnTypeNode(functionNode);
      if (!returnTypeNode) {
        return false;
      }
      const typeParameters = functionNode.typeParameters && functionNode.typeParameters.params;
      if (typeParameters) {
        if (typeParameters.length > 1) {
          return false;
        }
        if (typeParameters.length === 1) {
          const typeParameter = typeParameters[0];
          if (typeParameter.constraint || typeParameter.default) {
            return false;
          }
        }
      }
      return getFunctionParameters(functionNode).length === 1 && (isObjectType(returnTypeNode) || willBreak(returnTypeDoc));
    }
    module2.exports = {
      printFunctionParameters,
      shouldHugFunctionParameters,
      shouldGroupFunctionParameters
    };
  }
});
var require_type_annotation = __commonJS2({
  "src/language-js/print/type-annotation.js"(exports2, module2) {
    "use strict";
    var {
      printComments,
      printDanglingComments
    } = require_comments();
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        group,
        join,
        line,
        softline,
        indent,
        align,
        ifBreak
      }
    } = require("./doc.js");
    var pathNeedsParens = require_needs_parens();
    var {
      locStart
    } = require_loc();
    var {
      isSimpleType,
      isObjectType,
      hasLeadingOwnLineComment,
      isObjectTypePropertyAFunction,
      shouldPrintComma
    } = require_utils7();
    var {
      printAssignment
    } = require_assignment();
    var {
      printFunctionParameters,
      shouldGroupFunctionParameters
    } = require_function_parameters();
    var {
      printArrayItems
    } = require_array4();
    function shouldHugType(node) {
      if (isSimpleType(node) || isObjectType(node)) {
        return true;
      }
      if (node.type === "UnionTypeAnnotation" || node.type === "TSUnionType") {
        const voidCount = node.types.filter((node2) => node2.type === "VoidTypeAnnotation" || node2.type === "TSVoidKeyword" || node2.type === "NullLiteralTypeAnnotation" || node2.type === "TSNullKeyword").length;
        const hasObject = node.types.some((node2) => node2.type === "ObjectTypeAnnotation" || node2.type === "TSTypeLiteral" || node2.type === "GenericTypeAnnotation" || node2.type === "TSTypeReference");
        if (node.types.length - 1 === voidCount && hasObject) {
          return true;
        }
      }
      return false;
    }
    function printOpaqueType(path, options, print) {
      const semi = options.semi ? ";" : "";
      const node = path.getValue();
      const parts = [];
      parts.push("opaque type ", print("id"), print("typeParameters"));
      if (node.supertype) {
        parts.push(": ", print("supertype"));
      }
      if (node.impltype) {
        parts.push(" = ", print("impltype"));
      }
      parts.push(semi);
      return parts;
    }
    function printTypeAlias(path, options, print) {
      const semi = options.semi ? ";" : "";
      const node = path.getValue();
      const parts = [];
      if (node.declare) {
        parts.push("declare ");
      }
      parts.push("type ", print("id"), print("typeParameters"));
      const rightPropertyName = node.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
      return [printAssignment(path, options, print, parts, " =", rightPropertyName), semi];
    }
    function printIntersectionType(path, options, print) {
      const node = path.getValue();
      const types = path.map(print, "types");
      const result = [];
      let wasIndented = false;
      for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
          result.push(types[i]);
        } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {
          result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);
        } else if (!isObjectType(node.types[i - 1]) && !isObjectType(node.types[i])) {
          result.push(indent([" &", line, types[i]]));
        } else {
          if (i > 1) {
            wasIndented = true;
          }
          result.push(" & ", i > 1 ? indent(types[i]) : types[i]);
        }
      }
      return group(result);
    }
    function printUnionType(path, options, print) {
      const node = path.getValue();
      const parent = path.getParentNode();
      const shouldIndent = parent.type !== "TypeParameterInstantiation" && parent.type !== "TSTypeParameterInstantiation" && parent.type !== "GenericTypeAnnotation" && parent.type !== "TSTypeReference" && parent.type !== "TSTypeAssertion" && parent.type !== "TupleTypeAnnotation" && parent.type !== "TSTupleType" && !(parent.type === "FunctionTypeParam" && !parent.name && path.getParentNode(1).this !== parent) && !((parent.type === "TypeAlias" || parent.type === "VariableDeclarator" || parent.type === "TSTypeAliasDeclaration") && hasLeadingOwnLineComment(options.originalText, node));
      const shouldHug = shouldHugType(node);
      const printed = path.map((typePath) => {
        let printedType = print();
        if (!shouldHug) {
          printedType = align(2, printedType);
        }
        return printComments(typePath, printedType, options);
      }, "types");
      if (shouldHug) {
        return join(" | ", printed);
      }
      const shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, node);
      const code = [ifBreak([shouldAddStartLine ? line : "", "| "]), join([line, "| "], printed)];
      if (pathNeedsParens(path, options)) {
        return group([indent(code), softline]);
      }
      if (parent.type === "TupleTypeAnnotation" && parent.types.length > 1 || parent.type === "TSTupleType" && parent.elementTypes.length > 1) {
        return group([indent([ifBreak(["(", softline]), code]), softline, ifBreak(")")]);
      }
      return group(shouldIndent ? indent(code) : code);
    }
    function printFunctionType(path, options, print) {
      const node = path.getValue();
      const parts = [];
      const parent = path.getParentNode(0);
      const parentParent = path.getParentNode(1);
      const parentParentParent = path.getParentNode(2);
      let isArrowFunctionTypeAnnotation = node.type === "TSFunctionType" || !((parent.type === "ObjectTypeProperty" || parent.type === "ObjectTypeInternalSlot") && !parent.variance && !parent.optional && locStart(parent) === locStart(node) || parent.type === "ObjectTypeCallProperty" || parentParentParent && parentParentParent.type === "DeclareFunction");
      let needsColon = isArrowFunctionTypeAnnotation && (parent.type === "TypeAnnotation" || parent.type === "TSTypeAnnotation");
      const needsParens = needsColon && isArrowFunctionTypeAnnotation && (parent.type === "TypeAnnotation" || parent.type === "TSTypeAnnotation") && parentParent.type === "ArrowFunctionExpression";
      if (isObjectTypePropertyAFunction(parent)) {
        isArrowFunctionTypeAnnotation = true;
        needsColon = true;
      }
      if (needsParens) {
        parts.push("(");
      }
      const parametersDoc = printFunctionParameters(path, print, options, false, true);
      const returnTypeDoc = node.returnType || node.predicate || node.typeAnnotation ? [isArrowFunctionTypeAnnotation ? " => " : ": ", print("returnType"), print("predicate"), print("typeAnnotation")] : "";
      const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);
      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);
      if (returnTypeDoc) {
        parts.push(returnTypeDoc);
      }
      if (needsParens) {
        parts.push(")");
      }
      return group(parts);
    }
    function printTupleType(path, options, print) {
      const node = path.getValue();
      const typesField = node.type === "TSTupleType" ? "elementTypes" : "types";
      const types = node[typesField];
      const isNonEmptyTuple = isNonEmptyArray(types);
      const bracketsDelimiterLine = isNonEmptyTuple ? softline : "";
      return group(["[", indent([bracketsDelimiterLine, printArrayItems(path, options, typesField, print)]), ifBreak(isNonEmptyTuple && shouldPrintComma(options, "all") ? "," : ""), printDanglingComments(path, options, true), bracketsDelimiterLine, "]"]);
    }
    function printIndexedAccessType(path, options, print) {
      const node = path.getValue();
      const leftDelimiter = node.type === "OptionalIndexedAccessType" && node.optional ? "?.[" : "[";
      return [print("objectType"), leftDelimiter, print("indexType"), "]"];
    }
    function printJSDocType(path, print, token) {
      const node = path.getValue();
      return [node.postfix ? "" : token, print("typeAnnotation"), node.postfix ? token : ""];
    }
    module2.exports = {
      printOpaqueType,
      printTypeAlias,
      printIntersectionType,
      printUnionType,
      printFunctionType,
      printTupleType,
      printIndexedAccessType,
      shouldHugType,
      printJSDocType
    };
  }
});
var require_type_parameters = __commonJS2({
  "src/language-js/print/type-parameters.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      builders: {
        join,
        line,
        hardline,
        softline,
        group,
        indent,
        ifBreak
      }
    } = require("./doc.js");
    var {
      isTestCall,
      hasComment,
      CommentCheckFlags,
      isTSXFile,
      shouldPrintComma,
      getFunctionParameters,
      isObjectType,
      getTypeScriptMappedTypeModifier
    } = require_utils7();
    var {
      createGroupIdMapper
    } = require_util();
    var {
      shouldHugType
    } = require_type_annotation();
    var {
      isArrowFunctionVariableDeclarator
    } = require_assignment();
    var getTypeParametersGroupId = createGroupIdMapper("typeParameters");
    function printTypeParameters(path, options, print, paramsKey) {
      const node = path.getValue();
      if (!node[paramsKey]) {
        return "";
      }
      if (!Array.isArray(node[paramsKey])) {
        return print(paramsKey);
      }
      const grandparent = path.getNode(2);
      const isParameterInTestCall = grandparent && isTestCall(grandparent);
      const isArrowFunctionVariable = path.match((node2) => !(node2[paramsKey].length === 1 && isObjectType(node2[paramsKey][0])), void 0, (node2, name) => name === "typeAnnotation", (node2) => node2.type === "Identifier", isArrowFunctionVariableDeclarator);
      const shouldInline = node[paramsKey].length === 0 || !isArrowFunctionVariable && (isParameterInTestCall || node[paramsKey].length === 1 && (node[paramsKey][0].type === "NullableTypeAnnotation" || shouldHugType(node[paramsKey][0])));
      if (shouldInline) {
        return ["<", join(", ", path.map(print, paramsKey)), printDanglingCommentsForInline(path, options), ">"];
      }
      const trailingComma = node.type === "TSTypeParameterInstantiation" ? "" : getFunctionParameters(node).length === 1 && isTSXFile(options) && !node[paramsKey][0].constraint && path.getParentNode().type === "ArrowFunctionExpression" ? "," : shouldPrintComma(options, "all") ? ifBreak(",") : "";
      return group(["<", indent([softline, join([",", line], path.map(print, paramsKey))]), trailingComma, softline, ">"], {
        id: getTypeParametersGroupId(node)
      });
    }
    function printDanglingCommentsForInline(path, options) {
      const node = path.getValue();
      if (!hasComment(node, CommentCheckFlags.Dangling)) {
        return "";
      }
      const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);
      const printed = printDanglingComments(path, options, hasOnlyBlockComments);
      if (hasOnlyBlockComments) {
        return printed;
      }
      return [printed, hardline];
    }
    function printTypeParameter(path, options, print) {
      const node = path.getValue();
      const parts = [node.type === "TSTypeParameter" && node.const ? "const " : ""];
      const parent = path.getParentNode();
      if (parent.type === "TSMappedType") {
        if (parent.readonly) {
          parts.push(getTypeScriptMappedTypeModifier(parent.readonly, "readonly"), " ");
        }
        parts.push("[", print("name"));
        if (node.constraint) {
          parts.push(" in ", print("constraint"));
        }
        if (parent.nameType) {
          parts.push(" as ", path.callParent(() => print("nameType")));
        }
        parts.push("]");
        return parts;
      }
      if (node.variance) {
        parts.push(print("variance"));
      }
      if (node.in) {
        parts.push("in ");
      }
      if (node.out) {
        parts.push("out ");
      }
      parts.push(print("name"));
      if (node.bound) {
        parts.push(": ", print("bound"));
      }
      if (node.constraint) {
        parts.push(" extends ", print("constraint"));
      }
      if (node.default) {
        parts.push(" = ", print("default"));
      }
      return parts;
    }
    module2.exports = {
      printTypeParameter,
      printTypeParameters,
      getTypeParametersGroupId
    };
  }
});
var require_property = __commonJS2({
  "src/language-js/print/property.js"(exports2, module2) {
    "use strict";
    var {
      printComments
    } = require_comments();
    var {
      printString,
      printNumber
    } = require_util();
    var {
      isNumericLiteral,
      isSimpleNumber,
      isStringLiteral,
      isStringPropSafeToUnquote,
      rawText
    } = require_utils7();
    var {
      printAssignment
    } = require_assignment();
    var needsQuoteProps = /* @__PURE__ */ new WeakMap();
    function printPropertyKey(path, options, print) {
      const node = path.getNode();
      if (node.computed) {
        return ["[", print("key"), "]"];
      }
      const parent = path.getParentNode();
      const {
        key
      } = node;
      if (options.quoteProps === "consistent" && !needsQuoteProps.has(parent)) {
        const objectHasStringProp = (parent.properties || parent.body || parent.members).some((prop) => !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToUnquote(prop, options));
        needsQuoteProps.set(parent, objectHasStringProp);
      }
      if ((key.type === "Identifier" || isNumericLiteral(key) && isSimpleNumber(printNumber(rawText(key))) && String(key.value) === printNumber(rawText(key)) && !(options.parser === "typescript" || options.parser === "babel-ts")) && (options.parser === "json" || options.quoteProps === "consistent" && needsQuoteProps.get(parent))) {
        const prop = printString(JSON.stringify(key.type === "Identifier" ? key.name : key.value.toString()), options);
        return path.call((keyPath) => printComments(keyPath, prop, options), "key");
      }
      if (isStringPropSafeToUnquote(node, options) && (options.quoteProps === "as-needed" || options.quoteProps === "consistent" && !needsQuoteProps.get(parent))) {
        return path.call((keyPath) => printComments(keyPath, /^\d/.test(key.value) ? printNumber(key.value) : key.value, options), "key");
      }
      return print("key");
    }
    function printProperty(path, options, print) {
      const node = path.getValue();
      if (node.shorthand) {
        return print("value");
      }
      return printAssignment(path, options, print, printPropertyKey(path, options, print), ":", "value");
    }
    module2.exports = {
      printProperty,
      printPropertyKey
    };
  }
});
var require_function = __commonJS2({
  "src/language-js/print/function.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var {
      printDanglingComments,
      printCommentsSeparately
    } = require_comments();
    var getLast = require_get_last();
    var {
      getNextNonSpaceNonCommentCharacterIndex
    } = require_util();
    var {
      builders: {
        line,
        softline,
        group,
        indent,
        ifBreak,
        hardline,
        join,
        indentIfBreak
      },
      utils: {
        removeLines,
        willBreak
      }
    } = require("./doc.js");
    var {
      ArgExpansionBailout
    } = require_errors();
    var {
      getFunctionParameters,
      hasLeadingOwnLineComment,
      isFlowAnnotationComment,
      isJsxNode,
      isTemplateOnItsOwnLine,
      shouldPrintComma,
      startsWithNoLookaheadToken,
      isBinaryish,
      isLineComment,
      hasComment,
      getComments,
      CommentCheckFlags,
      isCallLikeExpression,
      isCallExpression,
      getCallArguments,
      hasNakedLeftSide,
      getLeftSide
    } = require_utils7();
    var {
      locEnd
    } = require_loc();
    var {
      printFunctionParameters,
      shouldGroupFunctionParameters
    } = require_function_parameters();
    var {
      printPropertyKey
    } = require_property();
    var {
      printFunctionTypeParameters
    } = require_misc();
    function printFunction(path, print, options, args) {
      const node = path.getValue();
      let expandArg = false;
      if ((node.type === "FunctionDeclaration" || node.type === "FunctionExpression") && args && args.expandLastArg) {
        const parent = path.getParentNode();
        if (isCallExpression(parent) && getCallArguments(parent).length > 1) {
          expandArg = true;
        }
      }
      const parts = [];
      if (node.type === "TSDeclareFunction" && node.declare) {
        parts.push("declare ");
      }
      if (node.async) {
        parts.push("async ");
      }
      if (node.generator) {
        parts.push("function* ");
      } else {
        parts.push("function ");
      }
      if (node.id) {
        parts.push(print("id"));
      }
      const parametersDoc = printFunctionParameters(path, print, options, expandArg);
      const returnTypeDoc = printReturnType(path, print, options);
      const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);
      parts.push(printFunctionTypeParameters(path, options, print), group([shouldGroupParameters ? group(parametersDoc) : parametersDoc, returnTypeDoc]), node.body ? " " : "", print("body"));
      if (options.semi && (node.declare || !node.body)) {
        parts.push(";");
      }
      return parts;
    }
    function printMethod(path, options, print) {
      const node = path.getNode();
      const {
        kind
      } = node;
      const value = node.value || node;
      const parts = [];
      if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
        if (value.async) {
          parts.push("async ");
        }
      } else {
        assert.ok(kind === "get" || kind === "set");
        parts.push(kind, " ");
      }
      if (value.generator) {
        parts.push("*");
      }
      parts.push(printPropertyKey(path, options, print), node.optional || node.key.optional ? "?" : "");
      if (node === value) {
        parts.push(printMethodInternal(path, options, print));
      } else if (value.type === "FunctionExpression") {
        parts.push(path.call((path2) => printMethodInternal(path2, options, print), "value"));
      } else {
        parts.push(print("value"));
      }
      return parts;
    }
    function printMethodInternal(path, options, print) {
      const node = path.getNode();
      const parametersDoc = printFunctionParameters(path, print, options);
      const returnTypeDoc = printReturnType(path, print, options);
      const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);
      const parts = [printFunctionTypeParameters(path, options, print), group([shouldGroupParameters ? group(parametersDoc) : parametersDoc, returnTypeDoc])];
      if (node.body) {
        parts.push(" ", print("body"));
      } else {
        parts.push(options.semi ? ";" : "");
      }
      return parts;
    }
    function printArrowFunctionSignature(path, options, print, args) {
      const node = path.getValue();
      const parts = [];
      if (node.async) {
        parts.push("async ");
      }
      if (shouldPrintParamsWithoutParens(path, options)) {
        parts.push(print(["params", 0]));
      } else {
        const expandArg = args && (args.expandLastArg || args.expandFirstArg);
        let returnTypeDoc = printReturnType(path, print, options);
        if (expandArg) {
          if (willBreak(returnTypeDoc)) {
            throw new ArgExpansionBailout();
          }
          returnTypeDoc = group(removeLines(returnTypeDoc));
        }
        parts.push(group([printFunctionParameters(path, print, options, expandArg, true), returnTypeDoc]));
      }
      const dangling = printDanglingComments(path, options, true, (comment) => {
        const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, locEnd);
        return nextCharacter !== false && options.originalText.slice(nextCharacter, nextCharacter + 2) === "=>";
      });
      if (dangling) {
        parts.push(" ", dangling);
      }
      return parts;
    }
    function printArrowChain(path, args, signatures, shouldBreak, bodyDoc, tailNode) {
      const name = path.getName();
      const parent = path.getParentNode();
      const isCallee = isCallLikeExpression(parent) && name === "callee";
      const isAssignmentRhs = Boolean(args && args.assignmentLayout);
      const shouldPutBodyOnSeparateLine = tailNode.body.type !== "BlockStatement" && tailNode.body.type !== "ObjectExpression" && tailNode.body.type !== "SequenceExpression";
      const shouldBreakBeforeChain = isCallee && shouldPutBodyOnSeparateLine || args && args.assignmentLayout === "chain-tail-arrow-chain";
      const groupId = Symbol("arrow-chain");
      if (tailNode.body.type === "SequenceExpression") {
        bodyDoc = group(["(", indent([softline, bodyDoc]), softline, ")"]);
      }
      return group([group(indent([isCallee || isAssignmentRhs ? softline : "", group(join([" =>", line], signatures), {
        shouldBreak
      })]), {
        id: groupId,
        shouldBreak: shouldBreakBeforeChain
      }), " =>", indentIfBreak(shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [" ", bodyDoc], {
        groupId
      }), isCallee ? ifBreak(softline, "", {
        groupId
      }) : ""]);
    }
    function printArrowFunction(path, options, print, args) {
      let node = path.getValue();
      const signatures = [];
      const body = [];
      let chainShouldBreak = false;
      (function rec() {
        const doc2 = printArrowFunctionSignature(path, options, print, args);
        if (signatures.length === 0) {
          signatures.push(doc2);
        } else {
          const {
            leading,
            trailing
          } = printCommentsSeparately(path, options);
          signatures.push([leading, doc2]);
          body.unshift(trailing);
        }
        chainShouldBreak = chainShouldBreak || node.returnType && getFunctionParameters(node).length > 0 || node.typeParameters || getFunctionParameters(node).some((param) => param.type !== "Identifier");
        if (node.body.type !== "ArrowFunctionExpression" || args && args.expandLastArg) {
          body.unshift(print("body", args));
        } else {
          node = node.body;
          path.call(rec, "body");
        }
      })();
      if (signatures.length > 1) {
        return printArrowChain(path, args, signatures, chainShouldBreak, body, node);
      }
      const parts = signatures;
      parts.push(" =>");
      if (!hasLeadingOwnLineComment(options.originalText, node.body) && (node.body.type === "ArrayExpression" || node.body.type === "ObjectExpression" || node.body.type === "BlockStatement" || isJsxNode(node.body) || isTemplateOnItsOwnLine(node.body, options.originalText) || node.body.type === "ArrowFunctionExpression" || node.body.type === "DoExpression")) {
        return group([...parts, " ", body]);
      }
      if (node.body.type === "SequenceExpression") {
        return group([...parts, group([" (", indent([softline, body]), softline, ")"])]);
      }
      const shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === "JSXExpressionContainer") && !hasComment(node);
      const printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, "all");
      const shouldAddParens = node.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken(node.body, (node2) => node2.type === "ObjectExpression");
      return group([...parts, group([indent([line, shouldAddParens ? ifBreak("", "(") : "", body, shouldAddParens ? ifBreak("", ")") : ""]), shouldAddSoftLine ? [ifBreak(printTrailingComma ? "," : ""), softline] : ""])]);
    }
    function canPrintParamsWithoutParens(node) {
      const parameters = getFunctionParameters(node);
      return parameters.length === 1 && !node.typeParameters && !hasComment(node, CommentCheckFlags.Dangling) && parameters[0].type === "Identifier" && !parameters[0].typeAnnotation && !hasComment(parameters[0]) && !parameters[0].optional && !node.predicate && !node.returnType;
    }
    function shouldPrintParamsWithoutParens(path, options) {
      if (options.arrowParens === "always") {
        return false;
      }
      if (options.arrowParens === "avoid") {
        const node = path.getValue();
        return canPrintParamsWithoutParens(node);
      }
      return false;
    }
    function printReturnType(path, print, options) {
      const node = path.getValue();
      const returnType = print("returnType");
      if (node.returnType && isFlowAnnotationComment(options.originalText, node.returnType)) {
        return [" /*: ", returnType, " */"];
      }
      const parts = [returnType];
      if (node.returnType && node.returnType.typeAnnotation) {
        parts.unshift(": ");
      }
      if (node.predicate) {
        parts.push(node.returnType ? " " : ": ", print("predicate"));
      }
      return parts;
    }
    function printReturnOrThrowArgument(path, options, print) {
      const node = path.getValue();
      const semi = options.semi ? ";" : "";
      const parts = [];
      if (node.argument) {
        if (returnArgumentHasLeadingComment(options, node.argument)) {
          parts.push([" (", indent([hardline, print("argument")]), hardline, ")"]);
        } else if (isBinaryish(node.argument) || node.argument.type === "SequenceExpression") {
          parts.push(group([ifBreak(" (", " "), indent([softline, print("argument")]), softline, ifBreak(")")]));
        } else {
          parts.push(" ", print("argument"));
        }
      }
      const comments = getComments(node);
      const lastComment = getLast(comments);
      const isLastCommentLine = lastComment && isLineComment(lastComment);
      if (isLastCommentLine) {
        parts.push(semi);
      }
      if (hasComment(node, CommentCheckFlags.Dangling)) {
        parts.push(" ", printDanglingComments(path, options, true));
      }
      if (!isLastCommentLine) {
        parts.push(semi);
      }
      return parts;
    }
    function printReturnStatement(path, options, print) {
      return ["return", printReturnOrThrowArgument(path, options, print)];
    }
    function printThrowStatement(path, options, print) {
      return ["throw", printReturnOrThrowArgument(path, options, print)];
    }
    function returnArgumentHasLeadingComment(options, argument) {
      if (hasLeadingOwnLineComment(options.originalText, argument)) {
        return true;
      }
      if (hasNakedLeftSide(argument)) {
        let leftMost = argument;
        let newLeftMost;
        while (newLeftMost = getLeftSide(leftMost)) {
          leftMost = newLeftMost;
          if (hasLeadingOwnLineComment(options.originalText, leftMost)) {
            return true;
          }
        }
      }
      return false;
    }
    module2.exports = {
      printFunction,
      printArrowFunction,
      printMethod,
      printReturnStatement,
      printThrowStatement,
      printMethodInternal,
      shouldPrintParamsWithoutParens
    };
  }
});
var require_decorators = __commonJS2({
  "src/language-js/print/decorators.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray,
      hasNewline
    } = require_util();
    var {
      builders: {
        line,
        hardline,
        join,
        breakParent,
        group
      }
    } = require("./doc.js");
    var {
      locStart,
      locEnd
    } = require_loc();
    var {
      getParentExportDeclaration
    } = require_utils7();
    function printClassMemberDecorators(path, options, print) {
      const node = path.getValue();
      return group([join(line, path.map(print, "decorators")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]);
    }
    function printDecoratorsBeforeExport(path, options, print) {
      return [join(hardline, path.map(print, "declaration", "decorators")), hardline];
    }
    function printDecorators(path, options, print) {
      const node = path.getValue();
      const {
        decorators
      } = node;
      if (!isNonEmptyArray(decorators) || hasDecoratorsBeforeExport(path.getParentNode())) {
        return;
      }
      const shouldBreak = node.type === "ClassExpression" || node.type === "ClassDeclaration" || hasNewlineBetweenOrAfterDecorators(node, options);
      return [getParentExportDeclaration(path) ? hardline : shouldBreak ? breakParent : "", join(line, path.map(print, "decorators")), line];
    }
    function hasNewlineBetweenOrAfterDecorators(node, options) {
      return node.decorators.some((decorator) => hasNewline(options.originalText, locEnd(decorator)));
    }
    function hasDecoratorsBeforeExport(node) {
      if (node.type !== "ExportDefaultDeclaration" && node.type !== "ExportNamedDeclaration" && node.type !== "DeclareExportDeclaration") {
        return false;
      }
      const decorators = node.declaration && node.declaration.decorators;
      return isNonEmptyArray(decorators) && locStart(node) === locStart(decorators[0]);
    }
    module2.exports = {
      printDecorators,
      printClassMemberDecorators,
      printDecoratorsBeforeExport,
      hasDecoratorsBeforeExport
    };
  }
});
var require_class = __commonJS2({
  "src/language-js/print/class.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray,
      createGroupIdMapper
    } = require_util();
    var {
      printComments,
      printDanglingComments
    } = require_comments();
    var {
      builders: {
        join,
        line,
        hardline,
        softline,
        group,
        indent,
        ifBreak
      }
    } = require("./doc.js");
    var {
      hasComment,
      CommentCheckFlags
    } = require_utils7();
    var {
      getTypeParametersGroupId
    } = require_type_parameters();
    var {
      printMethod
    } = require_function();
    var {
      printOptionalToken,
      printTypeAnnotation,
      printDefiniteToken
    } = require_misc();
    var {
      printPropertyKey
    } = require_property();
    var {
      printAssignment
    } = require_assignment();
    var {
      printClassMemberDecorators
    } = require_decorators();
    function printClass(path, options, print) {
      const node = path.getValue();
      const parts = [];
      if (node.declare) {
        parts.push("declare ");
      }
      if (node.abstract) {
        parts.push("abstract ");
      }
      parts.push("class");
      const groupMode = node.id && hasComment(node.id, CommentCheckFlags.Trailing) || node.typeParameters && hasComment(node.typeParameters, CommentCheckFlags.Trailing) || node.superClass && hasComment(node.superClass) || isNonEmptyArray(node.extends) || isNonEmptyArray(node.mixins) || isNonEmptyArray(node.implements);
      const partsGroup = [];
      const extendsParts = [];
      if (node.id) {
        partsGroup.push(" ", print("id"));
      }
      partsGroup.push(print("typeParameters"));
      if (node.superClass) {
        const printed = [printSuperClass(path, options, print), print("superTypeParameters")];
        const printedWithComments = path.call((superClass) => ["extends ", printComments(superClass, printed, options)], "superClass");
        if (groupMode) {
          extendsParts.push(line, group(printedWithComments));
        } else {
          extendsParts.push(" ", printedWithComments);
        }
      } else {
        extendsParts.push(printList(path, options, print, "extends"));
      }
      extendsParts.push(printList(path, options, print, "mixins"), printList(path, options, print, "implements"));
      if (groupMode) {
        let printedPartsGroup;
        if (shouldIndentOnlyHeritageClauses(node)) {
          printedPartsGroup = [...partsGroup, indent(extendsParts)];
        } else {
          printedPartsGroup = indent([...partsGroup, extendsParts]);
        }
        parts.push(group(printedPartsGroup, {
          id: getHeritageGroupId(node)
        }));
      } else {
        parts.push(...partsGroup, ...extendsParts);
      }
      parts.push(" ", print("body"));
      return parts;
    }
    var getHeritageGroupId = createGroupIdMapper("heritageGroup");
    function printHardlineAfterHeritage(node) {
      return ifBreak(hardline, "", {
        groupId: getHeritageGroupId(node)
      });
    }
    function hasMultipleHeritage(node) {
      return ["superClass", "extends", "mixins", "implements"].filter((key) => Boolean(node[key])).length > 1;
    }
    function shouldIndentOnlyHeritageClauses(node) {
      return node.typeParameters && !hasComment(node.typeParameters, CommentCheckFlags.Trailing | CommentCheckFlags.Line) && !hasMultipleHeritage(node);
    }
    function printList(path, options, print, listName) {
      const node = path.getValue();
      if (!isNonEmptyArray(node[listName])) {
        return "";
      }
      const printedLeadingComments = printDanglingComments(path, options, true, ({
        marker
      }) => marker === listName);
      return [shouldIndentOnlyHeritageClauses(node) ? ifBreak(" ", line, {
        groupId: getTypeParametersGroupId(node.typeParameters)
      }) : line, printedLeadingComments, printedLeadingComments && hardline, listName, group(indent([line, join([",", line], path.map(print, listName))]))];
    }
    function printSuperClass(path, options, print) {
      const printed = print("superClass");
      const parent = path.getParentNode();
      if (parent.type === "AssignmentExpression") {
        return group(ifBreak(["(", indent([softline, printed]), softline, ")"], printed));
      }
      return printed;
    }
    function printClassMethod(path, options, print) {
      const node = path.getValue();
      const parts = [];
      if (isNonEmptyArray(node.decorators)) {
        parts.push(printClassMemberDecorators(path, options, print));
      }
      if (node.accessibility) {
        parts.push(node.accessibility + " ");
      }
      if (node.readonly) {
        parts.push("readonly ");
      }
      if (node.declare) {
        parts.push("declare ");
      }
      if (node.static) {
        parts.push("static ");
      }
      if (node.type === "TSAbstractMethodDefinition" || node.abstract) {
        parts.push("abstract ");
      }
      if (node.override) {
        parts.push("override ");
      }
      parts.push(printMethod(path, options, print));
      return parts;
    }
    function printClassProperty(path, options, print) {
      const node = path.getValue();
      const parts = [];
      const semi = options.semi ? ";" : "";
      if (isNonEmptyArray(node.decorators)) {
        parts.push(printClassMemberDecorators(path, options, print));
      }
      if (node.accessibility) {
        parts.push(node.accessibility + " ");
      }
      if (node.declare) {
        parts.push("declare ");
      }
      if (node.static) {
        parts.push("static ");
      }
      if (node.type === "TSAbstractPropertyDefinition" || node.type === "TSAbstractAccessorProperty" || node.abstract) {
        parts.push("abstract ");
      }
      if (node.override) {
        parts.push("override ");
      }
      if (node.readonly) {
        parts.push("readonly ");
      }
      if (node.variance) {
        parts.push(print("variance"));
      }
      if (node.type === "ClassAccessorProperty" || node.type === "AccessorProperty" || node.type === "TSAbstractAccessorProperty") {
        parts.push("accessor ");
      }
      parts.push(printPropertyKey(path, options, print), printOptionalToken(path), printDefiniteToken(path), printTypeAnnotation(path, options, print));
      return [printAssignment(path, options, print, parts, " =", "value"), semi];
    }
    module2.exports = {
      printClass,
      printClassMethod,
      printClassProperty,
      printHardlineAfterHeritage
    };
  }
});
var require_interface = __commonJS2({
  "src/language-js/print/interface.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        join,
        line,
        group,
        indent,
        ifBreak
      }
    } = require("./doc.js");
    var {
      hasComment,
      identity,
      CommentCheckFlags
    } = require_utils7();
    var {
      getTypeParametersGroupId
    } = require_type_parameters();
    var {
      printTypeScriptModifiers
    } = require_misc();
    function printInterface(path, options, print) {
      const node = path.getValue();
      const parts = [];
      if (node.declare) {
        parts.push("declare ");
      }
      if (node.type === "TSInterfaceDeclaration") {
        parts.push(node.abstract ? "abstract " : "", printTypeScriptModifiers(path, options, print));
      }
      parts.push("interface");
      const partsGroup = [];
      const extendsParts = [];
      if (node.type !== "InterfaceTypeAnnotation") {
        partsGroup.push(" ", print("id"), print("typeParameters"));
      }
      const shouldIndentOnlyHeritageClauses = node.typeParameters && !hasComment(node.typeParameters, CommentCheckFlags.Trailing | CommentCheckFlags.Line);
      if (isNonEmptyArray(node.extends)) {
        extendsParts.push(shouldIndentOnlyHeritageClauses ? ifBreak(" ", line, {
          groupId: getTypeParametersGroupId(node.typeParameters)
        }) : line, "extends ", (node.extends.length === 1 ? identity : indent)(join([",", line], path.map(print, "extends"))));
      }
      if (node.id && hasComment(node.id, CommentCheckFlags.Trailing) || isNonEmptyArray(node.extends)) {
        if (shouldIndentOnlyHeritageClauses) {
          parts.push(group([...partsGroup, indent(extendsParts)]));
        } else {
          parts.push(group(indent([...partsGroup, ...extendsParts])));
        }
      } else {
        parts.push(...partsGroup, ...extendsParts);
      }
      parts.push(" ", print("body"));
      return group(parts);
    }
    module2.exports = {
      printInterface
    };
  }
});
var require_module = __commonJS2({
  "src/language-js/print/module.js"(exports2, module2) {
    "use strict";
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        softline,
        group,
        indent,
        join,
        line,
        ifBreak,
        hardline
      }
    } = require("./doc.js");
    var {
      printDanglingComments
    } = require_comments();
    var {
      hasComment,
      CommentCheckFlags,
      shouldPrintComma,
      needsHardlineAfterDanglingComment,
      isStringLiteral,
      rawText
    } = require_utils7();
    var {
      locStart,
      hasSameLoc
    } = require_loc();
    var {
      hasDecoratorsBeforeExport,
      printDecoratorsBeforeExport
    } = require_decorators();
    function printImportDeclaration(path, options, print) {
      const node = path.getValue();
      const semi = options.semi ? ";" : "";
      const parts = [];
      const {
        importKind
      } = node;
      parts.push("import");
      if (importKind && importKind !== "value") {
        parts.push(" ", importKind);
      }
      parts.push(printModuleSpecifiers(path, options, print), printModuleSource(path, options, print), printImportAssertions(path, options, print), semi);
      return parts;
    }
    function printExportDeclaration(path, options, print) {
      const node = path.getValue();
      const parts = [];
      if (hasDecoratorsBeforeExport(node)) {
        parts.push(printDecoratorsBeforeExport(path, options, print));
      }
      const {
        type,
        exportKind,
        declaration
      } = node;
      parts.push("export");
      const isDefaultExport = node.default || type === "ExportDefaultDeclaration";
      if (isDefaultExport) {
        parts.push(" default");
      }
      if (hasComment(node, CommentCheckFlags.Dangling)) {
        parts.push(" ", printDanglingComments(path, options, true));
        if (needsHardlineAfterDanglingComment(node)) {
          parts.push(hardline);
        }
      }
      if (declaration) {
        parts.push(" ", print("declaration"));
      } else {
        parts.push(exportKind === "type" ? " type" : "", printModuleSpecifiers(path, options, print), printModuleSource(path, options, print), printImportAssertions(path, options, print));
      }
      if (shouldExportDeclarationPrintSemi(node, options)) {
        parts.push(";");
      }
      return parts;
    }
    function printExportAllDeclaration(path, options, print) {
      const node = path.getValue();
      const semi = options.semi ? ";" : "";
      const parts = [];
      const {
        exportKind,
        exported
      } = node;
      parts.push("export");
      if (exportKind === "type") {
        parts.push(" type");
      }
      parts.push(" *");
      if (exported) {
        parts.push(" as ", print("exported"));
      }
      parts.push(printModuleSource(path, options, print), printImportAssertions(path, options, print), semi);
      return parts;
    }
    function shouldExportDeclarationPrintSemi(node, options) {
      if (!options.semi) {
        return false;
      }
      const {
        type,
        declaration
      } = node;
      const isDefaultExport = node.default || type === "ExportDefaultDeclaration";
      if (!declaration) {
        return true;
      }
      const {
        type: declarationType
      } = declaration;
      if (isDefaultExport && declarationType !== "ClassDeclaration" && declarationType !== "FunctionDeclaration" && declarationType !== "TSInterfaceDeclaration" && declarationType !== "DeclareClass" && declarationType !== "DeclareFunction" && declarationType !== "TSDeclareFunction" && declarationType !== "EnumDeclaration") {
        return true;
      }
      return false;
    }
    function printModuleSource(path, options, print) {
      const node = path.getValue();
      if (!node.source) {
        return "";
      }
      const parts = [];
      if (!shouldNotPrintSpecifiers(node, options)) {
        parts.push(" from");
      }
      parts.push(" ", print("source"));
      return parts;
    }
    function printModuleSpecifiers(path, options, print) {
      const node = path.getValue();
      if (shouldNotPrintSpecifiers(node, options)) {
        return "";
      }
      const parts = [" "];
      if (isNonEmptyArray(node.specifiers)) {
        const standaloneSpecifiers = [];
        const groupedSpecifiers = [];
        path.each(() => {
          const specifierType = path.getValue().type;
          if (specifierType === "ExportNamespaceSpecifier" || specifierType === "ExportDefaultSpecifier" || specifierType === "ImportNamespaceSpecifier" || specifierType === "ImportDefaultSpecifier") {
            standaloneSpecifiers.push(print());
          } else if (specifierType === "ExportSpecifier" || specifierType === "ImportSpecifier") {
            groupedSpecifiers.push(print());
          } else {
            throw new Error(`Unknown specifier type ${JSON.stringify(specifierType)}`);
          }
        }, "specifiers");
        parts.push(join(", ", standaloneSpecifiers));
        if (groupedSpecifiers.length > 0) {
          if (standaloneSpecifiers.length > 0) {
            parts.push(", ");
          }
          const canBreak = groupedSpecifiers.length > 1 || standaloneSpecifiers.length > 0 || node.specifiers.some((node2) => hasComment(node2));
          if (canBreak) {
            parts.push(group(["{", indent([options.bracketSpacing ? line : softline, join([",", line], groupedSpecifiers)]), ifBreak(shouldPrintComma(options) ? "," : ""), options.bracketSpacing ? line : softline, "}"]));
          } else {
            parts.push(["{", options.bracketSpacing ? " " : "", ...groupedSpecifiers, options.bracketSpacing ? " " : "", "}"]);
          }
        }
      } else {
        parts.push("{}");
      }
      return parts;
    }
    function shouldNotPrintSpecifiers(node, options) {
      const {
        type,
        importKind,
        source,
        specifiers
      } = node;
      if (type !== "ImportDeclaration" || isNonEmptyArray(specifiers) || importKind === "type") {
        return false;
      }
      return !/{\s*}/.test(options.originalText.slice(locStart(node), locStart(source)));
    }
    function printImportAssertions(path, options, print) {
      const node = path.getNode();
      if (isNonEmptyArray(node.assertions)) {
        return [" assert {", options.bracketSpacing ? " " : "", join(", ", path.map(print, "assertions")), options.bracketSpacing ? " " : "", "}"];
      }
      return "";
    }
    function printModuleSpecifier(path, options, print) {
      const node = path.getNode();
      const {
        type
      } = node;
      const parts = [];
      const kind = type === "ImportSpecifier" ? node.importKind : node.exportKind;
      if (kind && kind !== "value") {
        parts.push(kind, " ");
      }
      const isImport = type.startsWith("Import");
      const leftSideProperty = isImport ? "imported" : "local";
      const rightSideProperty = isImport ? "local" : "exported";
      const leftSideNode = node[leftSideProperty];
      const rightSideNode = node[rightSideProperty];
      let left = "";
      let right = "";
      if (type === "ExportNamespaceSpecifier" || type === "ImportNamespaceSpecifier") {
        left = "*";
      } else if (leftSideNode) {
        left = print(leftSideProperty);
      }
      if (rightSideNode && !isShorthandSpecifier(node)) {
        right = print(rightSideProperty);
      }
      parts.push(left, left && right ? " as " : "", right);
      return parts;
    }
    function isShorthandSpecifier(specifier) {
      if (specifier.type !== "ImportSpecifier" && specifier.type !== "ExportSpecifier") {
        return false;
      }
      const {
        local,
        [specifier.type === "ImportSpecifier" ? "imported" : "exported"]: importedOrExported
      } = specifier;
      if (local.type !== importedOrExported.type || !hasSameLoc(local, importedOrExported)) {
        return false;
      }
      if (isStringLiteral(local)) {
        return local.value === importedOrExported.value && rawText(local) === rawText(importedOrExported);
      }
      switch (local.type) {
        case "Identifier":
          return local.name === importedOrExported.name;
        default:
          return false;
      }
    }
    module2.exports = {
      printImportDeclaration,
      printExportDeclaration,
      printExportAllDeclaration,
      printModuleSpecifier
    };
  }
});
var require_object = __commonJS2({
  "src/language-js/print/object.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      builders: {
        line,
        softline,
        group,
        indent,
        ifBreak,
        hardline
      }
    } = require("./doc.js");
    var {
      getLast,
      hasNewlineInRange,
      hasNewline,
      isNonEmptyArray
    } = require_util();
    var {
      shouldPrintComma,
      hasComment,
      getComments,
      CommentCheckFlags,
      isNextLineEmpty
    } = require_utils7();
    var {
      locStart,
      locEnd
    } = require_loc();
    var {
      printOptionalToken,
      printTypeAnnotation
    } = require_misc();
    var {
      shouldHugFunctionParameters
    } = require_function_parameters();
    var {
      shouldHugType
    } = require_type_annotation();
    var {
      printHardlineAfterHeritage
    } = require_class();
    function printObject(path, options, print) {
      const semi = options.semi ? ";" : "";
      const node = path.getValue();
      let propertiesField;
      if (node.type === "TSTypeLiteral") {
        propertiesField = "members";
      } else if (node.type === "TSInterfaceBody") {
        propertiesField = "body";
      } else {
        propertiesField = "properties";
      }
      const isTypeAnnotation = node.type === "ObjectTypeAnnotation";
      const fields = [propertiesField];
      if (isTypeAnnotation) {
        fields.push("indexers", "callProperties", "internalSlots");
      }
      const firstProperty = fields.map((field) => node[field][0]).sort((a, b) => locStart(a) - locStart(b))[0];
      const parent = path.getParentNode(0);
      const isFlowInterfaceLikeBody = isTypeAnnotation && parent && (parent.type === "InterfaceDeclaration" || parent.type === "DeclareInterface" || parent.type === "DeclareClass") && path.getName() === "body";
      const shouldBreak = node.type === "TSInterfaceBody" || isFlowInterfaceLikeBody || node.type === "ObjectPattern" && parent.type !== "FunctionDeclaration" && parent.type !== "FunctionExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "ObjectMethod" && parent.type !== "ClassMethod" && parent.type !== "ClassPrivateMethod" && parent.type !== "AssignmentPattern" && parent.type !== "CatchClause" && node.properties.some((property) => property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern")) || node.type !== "ObjectPattern" && firstProperty && hasNewlineInRange(options.originalText, locStart(node), locStart(firstProperty));
      const separator = isFlowInterfaceLikeBody ? ";" : node.type === "TSInterfaceBody" || node.type === "TSTypeLiteral" ? ifBreak(semi, ";") : ",";
      const leftBrace = node.type === "RecordExpression" ? "#{" : node.exact ? "{|" : "{";
      const rightBrace = node.exact ? "|}" : "}";
      const propsAndLoc = [];
      for (const field of fields) {
        path.each((childPath) => {
          const node2 = childPath.getValue();
          propsAndLoc.push({
            node: node2,
            printed: print(),
            loc: locStart(node2)
          });
        }, field);
      }
      if (fields.length > 1) {
        propsAndLoc.sort((a, b) => a.loc - b.loc);
      }
      let separatorParts = [];
      const props = propsAndLoc.map((prop) => {
        const result = [...separatorParts, group(prop.printed)];
        separatorParts = [separator, line];
        if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasComment(prop.node, CommentCheckFlags.PrettierIgnore)) {
          separatorParts.shift();
        }
        if (isNextLineEmpty(prop.node, options)) {
          separatorParts.push(hardline);
        }
        return result;
      });
      if (node.inexact) {
        let printed;
        if (hasComment(node, CommentCheckFlags.Dangling)) {
          const hasLineComments = hasComment(node, CommentCheckFlags.Line);
          const printedDanglingComments = printDanglingComments(path, options, true);
          printed = [printedDanglingComments, hasLineComments || hasNewline(options.originalText, locEnd(getLast(getComments(node)))) ? hardline : line, "..."];
        } else {
          printed = ["..."];
        }
        props.push([...separatorParts, ...printed]);
      }
      const lastElem = getLast(node[propertiesField]);
      const canHaveTrailingSeparator = !(node.inexact || lastElem && lastElem.type === "RestElement" || lastElem && (lastElem.type === "TSPropertySignature" || lastElem.type === "TSCallSignatureDeclaration" || lastElem.type === "TSMethodSignature" || lastElem.type === "TSConstructSignatureDeclaration") && hasComment(lastElem, CommentCheckFlags.PrettierIgnore));
      let content;
      if (props.length === 0) {
        if (!hasComment(node, CommentCheckFlags.Dangling)) {
          return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];
        }
        content = group([leftBrace, printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]);
      } else {
        content = [isFlowInterfaceLikeBody && isNonEmptyArray(node.properties) ? printHardlineAfterHeritage(parent) : "", leftBrace, indent([options.bracketSpacing ? line : softline, ...props]), ifBreak(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma(options)) ? separator : ""), options.bracketSpacing ? line : softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)];
      }
      if (path.match((node2) => node2.type === "ObjectPattern" && !node2.decorators, (node2, name, number) => shouldHugFunctionParameters(node2) && (name === "params" || name === "parameters" || name === "this" || name === "rest") && number === 0) || path.match(shouldHugType, (node2, name) => name === "typeAnnotation", (node2, name) => name === "typeAnnotation", (node2, name, number) => shouldHugFunctionParameters(node2) && (name === "params" || name === "parameters" || name === "this" || name === "rest") && number === 0) || !shouldBreak && path.match((node2) => node2.type === "ObjectPattern", (node2) => node2.type === "AssignmentExpression" || node2.type === "VariableDeclarator")) {
        return content;
      }
      return group(content, {
        shouldBreak
      });
    }
    module2.exports = {
      printObject
    };
  }
});
var require_flow = __commonJS2({
  "src/language-js/print/flow.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var {
      printDanglingComments
    } = require_comments();
    var {
      printString,
      printNumber
    } = require_util();
    var {
      builders: {
        hardline,
        softline,
        group,
        indent
      }
    } = require("./doc.js");
    var {
      getParentExportDeclaration,
      isFunctionNotation,
      isGetterOrSetter,
      rawText,
      shouldPrintComma
    } = require_utils7();
    var {
      locStart,
      locEnd
    } = require_loc();
    var {
      replaceTextEndOfLine
    } = require_doc_utils();
    var {
      printClass
    } = require_class();
    var {
      printOpaqueType,
      printTypeAlias,
      printIntersectionType,
      printUnionType,
      printFunctionType,
      printTupleType,
      printIndexedAccessType
    } = require_type_annotation();
    var {
      printInterface
    } = require_interface();
    var {
      printTypeParameter,
      printTypeParameters
    } = require_type_parameters();
    var {
      printExportDeclaration,
      printExportAllDeclaration
    } = require_module();
    var {
      printArrayItems
    } = require_array4();
    var {
      printObject
    } = require_object();
    var {
      printPropertyKey
    } = require_property();
    var {
      printOptionalToken,
      printTypeAnnotation,
      printRestSpread
    } = require_misc();
    function printFlow(path, options, print) {
      const node = path.getValue();
      const semi = options.semi ? ";" : "";
      const parts = [];
      switch (node.type) {
        case "DeclareClass":
          return printFlowDeclaration(path, printClass(path, options, print));
        case "DeclareFunction":
          return printFlowDeclaration(path, ["function ", print("id"), node.predicate ? " " : "", print("predicate"), semi]);
        case "DeclareModule":
          return printFlowDeclaration(path, ["module ", print("id"), " ", print("body")]);
        case "DeclareModuleExports":
          return printFlowDeclaration(path, ["module.exports", ": ", print("typeAnnotation"), semi]);
        case "DeclareVariable":
          return printFlowDeclaration(path, ["var ", print("id"), semi]);
        case "DeclareOpaqueType":
          return printFlowDeclaration(path, printOpaqueType(path, options, print));
        case "DeclareInterface":
          return printFlowDeclaration(path, printInterface(path, options, print));
        case "DeclareTypeAlias":
          return printFlowDeclaration(path, printTypeAlias(path, options, print));
        case "DeclareExportDeclaration":
          return printFlowDeclaration(path, printExportDeclaration(path, options, print));
        case "DeclareExportAllDeclaration":
          return printFlowDeclaration(path, printExportAllDeclaration(path, options, print));
        case "OpaqueType":
          return printOpaqueType(path, options, print);
        case "TypeAlias":
          return printTypeAlias(path, options, print);
        case "IntersectionTypeAnnotation":
          return printIntersectionType(path, options, print);
        case "UnionTypeAnnotation":
          return printUnionType(path, options, print);
        case "FunctionTypeAnnotation":
          return printFunctionType(path, options, print);
        case "TupleTypeAnnotation":
          return printTupleType(path, options, print);
        case "GenericTypeAnnotation":
          return [print("id"), printTypeParameters(path, options, print, "typeParameters")];
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          return printIndexedAccessType(path, options, print);
        case "TypeAnnotation":
          return print("typeAnnotation");
        case "TypeParameter":
          return printTypeParameter(path, options, print);
        case "TypeofTypeAnnotation":
          return ["typeof ", print("argument")];
        case "ExistsTypeAnnotation":
          return "*";
        case "EmptyTypeAnnotation":
          return "empty";
        case "MixedTypeAnnotation":
          return "mixed";
        case "ArrayTypeAnnotation":
          return [print("elementType"), "[]"];
        case "BooleanLiteralTypeAnnotation":
          return String(node.value);
        case "EnumDeclaration":
          return ["enum ", print("id"), " ", print("body")];
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody": {
          if (node.type === "EnumSymbolBody" || node.explicitType) {
            let type = null;
            switch (node.type) {
              case "EnumBooleanBody":
                type = "boolean";
                break;
              case "EnumNumberBody":
                type = "number";
                break;
              case "EnumStringBody":
                type = "string";
                break;
              case "EnumSymbolBody":
                type = "symbol";
                break;
            }
            parts.push("of ", type, " ");
          }
          if (node.members.length === 0 && !node.hasUnknownMembers) {
            parts.push(group(["{", printDanglingComments(path, options), softline, "}"]));
          } else {
            const members = node.members.length > 0 ? [hardline, printArrayItems(path, options, "members", print), node.hasUnknownMembers || shouldPrintComma(options) ? "," : ""] : [];
            parts.push(group(["{", indent([...members, ...node.hasUnknownMembers ? [hardline, "..."] : []]), printDanglingComments(path, options, true), hardline, "}"]));
          }
          return parts;
        }
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
          return [print("id"), " = ", typeof node.init === "object" ? print("init") : String(node.init)];
        case "EnumDefaultedMember":
          return print("id");
        case "FunctionTypeParam": {
          const name = node.name ? print("name") : path.getParentNode().this === node ? "this" : "";
          return [name, printOptionalToken(path), name ? ": " : "", print("typeAnnotation")];
        }
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
          return printInterface(path, options, print);
        case "ClassImplements":
        case "InterfaceExtends":
          return [print("id"), print("typeParameters")];
        case "NullableTypeAnnotation":
          return ["?", print("typeAnnotation")];
        case "Variance": {
          const {
            kind
          } = node;
          assert.ok(kind === "plus" || kind === "minus");
          return kind === "plus" ? "+" : "-";
        }
        case "ObjectTypeCallProperty":
          if (node.static) {
            parts.push("static ");
          }
          parts.push(print("value"));
          return parts;
        case "ObjectTypeIndexer": {
          return [node.static ? "static " : "", node.variance ? print("variance") : "", "[", print("id"), node.id ? ": " : "", print("key"), "]: ", print("value")];
        }
        case "ObjectTypeProperty": {
          let modifier = "";
          if (node.proto) {
            modifier = "proto ";
          } else if (node.static) {
            modifier = "static ";
          }
          return [modifier, isGetterOrSetter(node) ? node.kind + " " : "", node.variance ? print("variance") : "", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(node) ? "" : ": ", print("value")];
        }
        case "ObjectTypeAnnotation":
          return printObject(path, options, print);
        case "ObjectTypeInternalSlot":
          return [node.static ? "static " : "", "[[", print("id"), "]]", printOptionalToken(path), node.method ? "" : ": ", print("value")];
        case "ObjectTypeSpreadProperty":
          return printRestSpread(path, options, print);
        case "QualifiedTypeofIdentifier":
        case "QualifiedTypeIdentifier":
          return [print("qualification"), ".", print("id")];
        case "StringLiteralTypeAnnotation":
          return replaceTextEndOfLine(printString(rawText(node), options));
        case "NumberLiteralTypeAnnotation":
          assert.strictEqual(typeof node.value, "number");
        case "BigIntLiteralTypeAnnotation":
          if (node.extra) {
            return printNumber(node.extra.raw);
          }
          return printNumber(node.raw);
        case "TypeCastExpression": {
          return ["(", print("expression"), printTypeAnnotation(path, options, print), ")"];
        }
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation": {
          const printed = printTypeParameters(path, options, print, "params");
          if (options.parser === "flow") {
            const start = locStart(node);
            const end = locEnd(node);
            const commentStartIndex = options.originalText.lastIndexOf("/*", start);
            const commentEndIndex = options.originalText.indexOf("*/", end);
            if (commentStartIndex !== -1 && commentEndIndex !== -1) {
              const comment = options.originalText.slice(commentStartIndex + 2, commentEndIndex).trim();
              if (comment.startsWith("::") && !comment.includes("/*") && !comment.includes("*/")) {
                return ["/*:: ", printed, " */"];
              }
            }
          }
          return printed;
        }
        case "InferredPredicate":
          return "%checks";
        case "DeclaredPredicate":
          return ["%checks(", print("value"), ")"];
        case "AnyTypeAnnotation":
          return "any";
        case "BooleanTypeAnnotation":
          return "boolean";
        case "BigIntTypeAnnotation":
          return "bigint";
        case "NullLiteralTypeAnnotation":
          return "null";
        case "NumberTypeAnnotation":
          return "number";
        case "SymbolTypeAnnotation":
          return "symbol";
        case "StringTypeAnnotation":
          return "string";
        case "VoidTypeAnnotation":
          return "void";
        case "ThisTypeAnnotation":
          return "this";
        case "Node":
        case "Printable":
        case "SourceLocation":
        case "Position":
        case "Statement":
        case "Function":
        case "Pattern":
        case "Expression":
        case "Declaration":
        case "Specifier":
        case "NamedSpecifier":
        case "Comment":
        case "MemberTypeAnnotation":
        case "Type":
          throw new Error("unprintable type: " + JSON.stringify(node.type));
      }
    }
    function printFlowDeclaration(path, printed) {
      const parentExportDecl = getParentExportDeclaration(path);
      if (parentExportDecl) {
        assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
        return printed;
      }
      return ["declare ", printed];
    }
    module2.exports = {
      printFlow
    };
  }
});
var require_is_ts_keyword_type = __commonJS2({
  "src/language-js/utils/is-ts-keyword-type.js"(exports2, module2) {
    "use strict";
    function isTsKeywordType({
      type
    }) {
      return type.startsWith("TS") && type.endsWith("Keyword");
    }
    module2.exports = isTsKeywordType;
  }
});
var require_ternary = __commonJS2({
  "src/language-js/print/ternary.js"(exports2, module2) {
    "use strict";
    var {
      hasNewlineInRange
    } = require_util();
    var {
      isJsxNode,
      getComments,
      isCallExpression,
      isMemberExpression,
      isTSTypeExpression
    } = require_utils7();
    var {
      locStart,
      locEnd
    } = require_loc();
    var isBlockComment = require_is_block_comment();
    var {
      builders: {
        line,
        softline,
        group,
        indent,
        align,
        ifBreak,
        dedent,
        breakParent
      }
    } = require("./doc.js");
    function conditionalExpressionChainContainsJsx(node) {
      const conditionalExpressions = [node];
      for (let index = 0; index < conditionalExpressions.length; index++) {
        const conditionalExpression = conditionalExpressions[index];
        for (const property of ["test", "consequent", "alternate"]) {
          const node2 = conditionalExpression[property];
          if (isJsxNode(node2)) {
            return true;
          }
          if (node2.type === "ConditionalExpression") {
            conditionalExpressions.push(node2);
          }
        }
      }
      return false;
    }
    function printTernaryTest(path, options, print) {
      const node = path.getValue();
      const isConditionalExpression = node.type === "ConditionalExpression";
      const alternateNodePropertyName = isConditionalExpression ? "alternate" : "falseType";
      const parent = path.getParentNode();
      const printed = isConditionalExpression ? print("test") : [print("checkType"), " ", "extends", " ", print("extendsType")];
      if (parent.type === node.type && parent[alternateNodePropertyName] === node) {
        return align(2, printed);
      }
      return printed;
    }
    var ancestorNameMap = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
    function shouldExtraIndentForConditionalExpression(path) {
      const node = path.getValue();
      if (node.type !== "ConditionalExpression") {
        return false;
      }
      let parent;
      let child = node;
      for (let ancestorCount = 0; !parent; ancestorCount++) {
        const node2 = path.getParentNode(ancestorCount);
        if (isCallExpression(node2) && node2.callee === child || isMemberExpression(node2) && node2.object === child || node2.type === "TSNonNullExpression" && node2.expression === child) {
          child = node2;
          continue;
        }
        if (node2.type === "NewExpression" && node2.callee === child || isTSTypeExpression(node2) && node2.expression === child) {
          parent = path.getParentNode(ancestorCount + 1);
          child = node2;
        } else {
          parent = node2;
        }
      }
      if (child === node) {
        return false;
      }
      return parent[ancestorNameMap.get(parent.type)] === child;
    }
    function printTernary(path, options, print) {
      const node = path.getValue();
      const isConditionalExpression = node.type === "ConditionalExpression";
      const consequentNodePropertyName = isConditionalExpression ? "consequent" : "trueType";
      const alternateNodePropertyName = isConditionalExpression ? "alternate" : "falseType";
      const testNodePropertyNames = isConditionalExpression ? ["test"] : ["checkType", "extendsType"];
      const consequentNode = node[consequentNodePropertyName];
      const alternateNode = node[alternateNodePropertyName];
      const parts = [];
      let jsxMode = false;
      const parent = path.getParentNode();
      const isParentTest = parent.type === node.type && testNodePropertyNames.some((prop) => parent[prop] === node);
      let forceNoIndent = parent.type === node.type && !isParentTest;
      let currentParent;
      let previousParent;
      let i = 0;
      do {
        previousParent = currentParent || node;
        currentParent = path.getParentNode(i);
        i++;
      } while (currentParent && currentParent.type === node.type && testNodePropertyNames.every((prop) => currentParent[prop] !== previousParent));
      const firstNonConditionalParent = currentParent || parent;
      const lastConditionalParent = previousParent;
      if (isConditionalExpression && (isJsxNode(node[testNodePropertyNames[0]]) || isJsxNode(consequentNode) || isJsxNode(alternateNode) || conditionalExpressionChainContainsJsx(lastConditionalParent))) {
        jsxMode = true;
        forceNoIndent = true;
        const wrap = (doc2) => [ifBreak("("), indent([softline, doc2]), softline, ifBreak(")")];
        const isNil = (node2) => node2.type === "NullLiteral" || node2.type === "Literal" && node2.value === null || node2.type === "Identifier" && node2.name === "undefined";
        parts.push(" ? ", isNil(consequentNode) ? print(consequentNodePropertyName) : wrap(print(consequentNodePropertyName)), " : ", alternateNode.type === node.type || isNil(alternateNode) ? print(alternateNodePropertyName) : wrap(print(alternateNodePropertyName)));
      } else {
        const part = [line, "? ", consequentNode.type === node.type ? ifBreak("", "(") : "", align(2, print(consequentNodePropertyName)), consequentNode.type === node.type ? ifBreak("", ")") : "", line, ": ", alternateNode.type === node.type ? print(alternateNodePropertyName) : align(2, print(alternateNodePropertyName))];
        parts.push(parent.type !== node.type || parent[alternateNodePropertyName] === node || isParentTest ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));
      }
      const comments = [...testNodePropertyNames.map((propertyName) => getComments(node[propertyName])), getComments(consequentNode), getComments(alternateNode)].flat();
      const shouldBreak = comments.some((comment) => isBlockComment(comment) && hasNewlineInRange(options.originalText, locStart(comment), locEnd(comment)));
      const maybeGroup = (doc2) => parent === firstNonConditionalParent ? group(doc2, {
        shouldBreak
      }) : shouldBreak ? [doc2, breakParent] : doc2;
      const breakClosingParen = !jsxMode && (isMemberExpression(parent) || parent.type === "NGPipeExpression" && parent.left === node) && !parent.computed;
      const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path);
      const result = maybeGroup([printTernaryTest(path, options, print), forceNoIndent ? parts : indent(parts), isConditionalExpression && breakClosingParen && !shouldExtraIndent ? softline : ""]);
      return isParentTest || shouldExtraIndent ? group([indent([softline, result]), softline]) : result;
    }
    module2.exports = {
      printTernary
    };
  }
});
var require_statement = __commonJS2({
  "src/language-js/print/statement.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        hardline
      }
    } = require("./doc.js");
    var pathNeedsParens = require_needs_parens();
    var {
      getLeftSidePathName,
      hasNakedLeftSide,
      isJsxNode,
      isTheOnlyJsxElementInMarkdown,
      hasComment,
      CommentCheckFlags,
      isNextLineEmpty
    } = require_utils7();
    var {
      shouldPrintParamsWithoutParens
    } = require_function();
    function printStatementSequence(path, options, print, property) {
      const node = path.getValue();
      const parts = [];
      const isClassBody = node.type === "ClassBody";
      const lastStatement = getLastStatement(node[property]);
      path.each((path2, index, statements) => {
        const node2 = path2.getValue();
        if (node2.type === "EmptyStatement") {
          return;
        }
        const printed = print();
        if (!options.semi && !isClassBody && !isTheOnlyJsxElementInMarkdown(options, path2) && statementNeedsASIProtection(path2, options)) {
          if (hasComment(node2, CommentCheckFlags.Leading)) {
            parts.push(print([], {
              needsSemi: true
            }));
          } else {
            parts.push(";", printed);
          }
        } else {
          parts.push(printed);
        }
        if (!options.semi && isClassBody && isClassProperty(node2) && shouldPrintSemicolonAfterClassProperty(node2, statements[index + 1])) {
          parts.push(";");
        }
        if (node2 !== lastStatement) {
          parts.push(hardline);
          if (isNextLineEmpty(node2, options)) {
            parts.push(hardline);
          }
        }
      }, property);
      return parts;
    }
    function getLastStatement(statements) {
      for (let i = statements.length - 1; i >= 0; i--) {
        const statement = statements[i];
        if (statement.type !== "EmptyStatement") {
          return statement;
        }
      }
    }
    function statementNeedsASIProtection(path, options) {
      const node = path.getNode();
      if (node.type !== "ExpressionStatement") {
        return false;
      }
      return path.call((childPath) => expressionNeedsASIProtection(childPath, options), "expression");
    }
    function expressionNeedsASIProtection(path, options) {
      const node = path.getValue();
      switch (node.type) {
        case "ParenthesizedExpression":
        case "TypeCastExpression":
        case "ArrayExpression":
        case "ArrayPattern":
        case "TemplateLiteral":
        case "TemplateElement":
        case "RegExpLiteral":
          return true;
        case "ArrowFunctionExpression": {
          if (!shouldPrintParamsWithoutParens(path, options)) {
            return true;
          }
          break;
        }
        case "UnaryExpression": {
          const {
            prefix,
            operator
          } = node;
          if (prefix && (operator === "+" || operator === "-")) {
            return true;
          }
          break;
        }
        case "BindExpression": {
          if (!node.object) {
            return true;
          }
          break;
        }
        case "Literal": {
          if (node.regex) {
            return true;
          }
          break;
        }
        default: {
          if (isJsxNode(node)) {
            return true;
          }
        }
      }
      if (pathNeedsParens(path, options)) {
        return true;
      }
      if (!hasNakedLeftSide(node)) {
        return false;
      }
      return path.call((childPath) => expressionNeedsASIProtection(childPath, options), ...getLeftSidePathName(path, node));
    }
    function printBody(path, options, print) {
      return printStatementSequence(path, options, print, "body");
    }
    function printSwitchCaseConsequent(path, options, print) {
      return printStatementSequence(path, options, print, "consequent");
    }
    var isClassProperty = ({
      type
    }) => type === "ClassProperty" || type === "PropertyDefinition" || type === "ClassPrivateProperty" || type === "ClassAccessorProperty" || type === "AccessorProperty" || type === "TSAbstractPropertyDefinition" || type === "TSAbstractAccessorProperty";
    function shouldPrintSemicolonAfterClassProperty(node, nextNode) {
      const {
        type,
        name
      } = node.key;
      if (!node.computed && type === "Identifier" && (name === "static" || name === "get" || name === "set" || name === "accessor") && !node.value && !node.typeAnnotation) {
        return true;
      }
      if (!nextNode) {
        return false;
      }
      if (nextNode.static || nextNode.accessibility) {
        return false;
      }
      if (!nextNode.computed) {
        const name2 = nextNode.key && nextNode.key.name;
        if (name2 === "in" || name2 === "instanceof") {
          return true;
        }
      }
      if (isClassProperty(nextNode) && nextNode.variance && !nextNode.static && !nextNode.declare) {
        return true;
      }
      switch (nextNode.type) {
        case "ClassProperty":
        case "PropertyDefinition":
        case "TSAbstractPropertyDefinition":
          return nextNode.computed;
        case "MethodDefinition":
        case "TSAbstractMethodDefinition":
        case "ClassMethod":
        case "ClassPrivateMethod": {
          const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;
          if (isAsync || nextNode.kind === "get" || nextNode.kind === "set") {
            return false;
          }
          const isGenerator = nextNode.value ? nextNode.value.generator : nextNode.generator;
          if (nextNode.computed || isGenerator) {
            return true;
          }
          return false;
        }
        case "TSIndexSignature":
          return true;
      }
      return false;
    }
    module2.exports = {
      printBody,
      printSwitchCaseConsequent
    };
  }
});
var require_block = __commonJS2({
  "src/language-js/print/block.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        hardline,
        indent
      }
    } = require("./doc.js");
    var {
      hasComment,
      CommentCheckFlags,
      isNextLineEmpty
    } = require_utils7();
    var {
      printHardlineAfterHeritage
    } = require_class();
    var {
      printBody
    } = require_statement();
    function printBlock(path, options, print) {
      const node = path.getValue();
      const parts = [];
      if (node.type === "StaticBlock") {
        parts.push("static ");
      }
      if (node.type === "ClassBody" && isNonEmptyArray(node.body)) {
        const parent = path.getParentNode();
        parts.push(printHardlineAfterHeritage(parent));
      }
      parts.push("{");
      const printed = printBlockBody(path, options, print);
      if (printed) {
        parts.push(indent([hardline, printed]), hardline);
      } else {
        const parent = path.getParentNode();
        const parentParent = path.getParentNode(1);
        if (!(parent.type === "ArrowFunctionExpression" || parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration" || parent.type === "ObjectMethod" || parent.type === "ClassMethod" || parent.type === "ClassPrivateMethod" || parent.type === "ForStatement" || parent.type === "WhileStatement" || parent.type === "DoWhileStatement" || parent.type === "DoExpression" || parent.type === "CatchClause" && !parentParent.finalizer || parent.type === "TSModuleDeclaration" || parent.type === "TSDeclareFunction" || node.type === "StaticBlock" || node.type === "ClassBody")) {
          parts.push(hardline);
        }
      }
      parts.push("}");
      return parts;
    }
    function printBlockBody(path, options, print) {
      const node = path.getValue();
      const nodeHasDirectives = isNonEmptyArray(node.directives);
      const nodeHasBody = node.body.some((node2) => node2.type !== "EmptyStatement");
      const nodeHasComment = hasComment(node, CommentCheckFlags.Dangling);
      if (!nodeHasDirectives && !nodeHasBody && !nodeHasComment) {
        return "";
      }
      const parts = [];
      if (nodeHasDirectives) {
        path.each((childPath, index, directives) => {
          parts.push(print());
          if (index < directives.length - 1 || nodeHasBody || nodeHasComment) {
            parts.push(hardline);
            if (isNextLineEmpty(childPath.getValue(), options)) {
              parts.push(hardline);
            }
          }
        }, "directives");
      }
      if (nodeHasBody) {
        parts.push(printBody(path, options, print));
      }
      if (nodeHasComment) {
        parts.push(printDanglingComments(path, options, true));
      }
      if (node.type === "Program") {
        const parent = path.getParentNode();
        if (!parent || parent.type !== "ModuleExpression") {
          parts.push(hardline);
        }
      }
      return parts;
    }
    module2.exports = {
      printBlock,
      printBlockBody
    };
  }
});
var require_typescript = __commonJS2({
  "src/language-js/print/typescript.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      hasNewlineInRange
    } = require_util();
    var {
      builders: {
        join,
        line,
        hardline,
        softline,
        group,
        indent,
        conditionalGroup,
        ifBreak
      }
    } = require("./doc.js");
    var {
      isStringLiteral,
      getTypeScriptMappedTypeModifier,
      shouldPrintComma,
      isCallExpression,
      isMemberExpression
    } = require_utils7();
    var isTsKeywordType = require_is_ts_keyword_type();
    var {
      locStart,
      locEnd
    } = require_loc();
    var {
      printOptionalToken,
      printTypeScriptModifiers
    } = require_misc();
    var {
      printTernary
    } = require_ternary();
    var {
      printFunctionParameters,
      shouldGroupFunctionParameters
    } = require_function_parameters();
    var {
      printTemplateLiteral
    } = require_template_literal();
    var {
      printArrayItems
    } = require_array4();
    var {
      printObject
    } = require_object();
    var {
      printClassProperty,
      printClassMethod
    } = require_class();
    var {
      printTypeParameter,
      printTypeParameters
    } = require_type_parameters();
    var {
      printPropertyKey
    } = require_property();
    var {
      printFunction,
      printMethodInternal
    } = require_function();
    var {
      printInterface
    } = require_interface();
    var {
      printBlock
    } = require_block();
    var {
      printTypeAlias,
      printIntersectionType,
      printUnionType,
      printFunctionType,
      printTupleType,
      printIndexedAccessType,
      printJSDocType
    } = require_type_annotation();
    function printTypescript(path, options, print) {
      const node = path.getValue();
      if (!node.type.startsWith("TS")) {
        return;
      }
      if (isTsKeywordType(node)) {
        return node.type.slice(2, -7).toLowerCase();
      }
      const semi = options.semi ? ";" : "";
      const parts = [];
      switch (node.type) {
        case "TSThisType":
          return "this";
        case "TSTypeAssertion": {
          const shouldBreakAfterCast = !(node.expression.type === "ArrayExpression" || node.expression.type === "ObjectExpression");
          const castGroup = group(["<", indent([softline, print("typeAnnotation")]), softline, ">"]);
          const exprContents = [ifBreak("("), indent([softline, print("expression")]), softline, ifBreak(")")];
          if (shouldBreakAfterCast) {
            return conditionalGroup([[castGroup, print("expression")], [castGroup, group(exprContents, {
              shouldBreak: true
            })], [castGroup, print("expression")]]);
          }
          return group([castGroup, print("expression")]);
        }
        case "TSDeclareFunction":
          return printFunction(path, print, options);
        case "TSExportAssignment":
          return ["export = ", print("expression"), semi];
        case "TSModuleBlock":
          return printBlock(path, options, print);
        case "TSInterfaceBody":
        case "TSTypeLiteral":
          return printObject(path, options, print);
        case "TSTypeAliasDeclaration":
          return printTypeAlias(path, options, print);
        case "TSQualifiedName":
          return join(".", [print("left"), print("right")]);
        case "TSAbstractMethodDefinition":
        case "TSDeclareMethod":
          return printClassMethod(path, options, print);
        case "TSAbstractAccessorProperty":
        case "TSAbstractPropertyDefinition":
          return printClassProperty(path, options, print);
        case "TSInterfaceHeritage":
        case "TSExpressionWithTypeArguments":
          parts.push(print("expression"));
          if (node.typeParameters) {
            parts.push(print("typeParameters"));
          }
          return parts;
        case "TSTemplateLiteralType":
          return printTemplateLiteral(path, print, options);
        case "TSNamedTupleMember":
          return [print("label"), node.optional ? "?" : "", ": ", print("elementType")];
        case "TSRestType":
          return ["...", print("typeAnnotation")];
        case "TSOptionalType":
          return [print("typeAnnotation"), "?"];
        case "TSInterfaceDeclaration":
          return printInterface(path, options, print);
        case "TSClassImplements":
          return [print("expression"), print("typeParameters")];
        case "TSTypeParameterDeclaration":
        case "TSTypeParameterInstantiation":
          return printTypeParameters(path, options, print, "params");
        case "TSTypeParameter":
          return printTypeParameter(path, options, print);
        case "TSSatisfiesExpression":
        case "TSAsExpression": {
          const operator = node.type === "TSAsExpression" ? "as" : "satisfies";
          parts.push(print("expression"), ` ${operator} `, print("typeAnnotation"));
          const parent = path.getParentNode();
          if (isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node) {
            return group([indent([softline, ...parts]), softline]);
          }
          return parts;
        }
        case "TSArrayType":
          return [print("elementType"), "[]"];
        case "TSPropertySignature": {
          if (node.readonly) {
            parts.push("readonly ");
          }
          parts.push(printPropertyKey(path, options, print), printOptionalToken(path));
          if (node.typeAnnotation) {
            parts.push(": ", print("typeAnnotation"));
          }
          if (node.initializer) {
            parts.push(" = ", print("initializer"));
          }
          return parts;
        }
        case "TSParameterProperty":
          if (node.accessibility) {
            parts.push(node.accessibility + " ");
          }
          if (node.export) {
            parts.push("export ");
          }
          if (node.static) {
            parts.push("static ");
          }
          if (node.override) {
            parts.push("override ");
          }
          if (node.readonly) {
            parts.push("readonly ");
          }
          parts.push(print("parameter"));
          return parts;
        case "TSTypeQuery":
          return ["typeof ", print("exprName"), print("typeParameters")];
        case "TSIndexSignature": {
          const parent = path.getParentNode();
          const trailingComma = node.parameters.length > 1 ? ifBreak(shouldPrintComma(options) ? "," : "") : "";
          const parametersGroup = group([indent([softline, join([", ", softline], path.map(print, "parameters"))]), trailingComma, softline]);
          return [node.export ? "export " : "", node.accessibility ? [node.accessibility, " "] : "", node.static ? "static " : "", node.readonly ? "readonly " : "", node.declare ? "declare " : "", "[", node.parameters ? parametersGroup : "", node.typeAnnotation ? "]: " : "]", node.typeAnnotation ? print("typeAnnotation") : "", parent.type === "ClassBody" ? semi : ""];
        }
        case "TSTypePredicate":
          return [node.asserts ? "asserts " : "", print("parameterName"), node.typeAnnotation ? [" is ", print("typeAnnotation")] : ""];
        case "TSNonNullExpression":
          return [print("expression"), "!"];
        case "TSImportType":
          return [!node.isTypeOf ? "" : "typeof ", "import(", print(node.parameter ? "parameter" : "argument"), ")", !node.qualifier ? "" : [".", print("qualifier")], printTypeParameters(path, options, print, "typeParameters")];
        case "TSLiteralType":
          return print("literal");
        case "TSIndexedAccessType":
          return printIndexedAccessType(path, options, print);
        case "TSConstructSignatureDeclaration":
        case "TSCallSignatureDeclaration":
        case "TSConstructorType": {
          if (node.type === "TSConstructorType" && node.abstract) {
            parts.push("abstract ");
          }
          if (node.type !== "TSCallSignatureDeclaration") {
            parts.push("new ");
          }
          parts.push(group(printFunctionParameters(path, print, options, false, true)));
          if (node.returnType || node.typeAnnotation) {
            const isType = node.type === "TSConstructorType";
            parts.push(isType ? " => " : ": ", print("returnType"), print("typeAnnotation"));
          }
          return parts;
        }
        case "TSTypeOperator":
          return [node.operator, " ", print("typeAnnotation")];
        case "TSMappedType": {
          const shouldBreak = hasNewlineInRange(options.originalText, locStart(node), locEnd(node));
          return group(["{", indent([options.bracketSpacing ? line : softline, print("typeParameter"), node.optional ? getTypeScriptMappedTypeModifier(node.optional, "?") : "", node.typeAnnotation ? ": " : "", print("typeAnnotation"), ifBreak(semi)]), printDanglingComments(path, options, true), options.bracketSpacing ? line : softline, "}"], {
            shouldBreak
          });
        }
        case "TSMethodSignature": {
          const kind = node.kind && node.kind !== "method" ? `${node.kind} ` : "";
          parts.push(node.accessibility ? [node.accessibility, " "] : "", kind, node.export ? "export " : "", node.static ? "static " : "", node.readonly ? "readonly " : "", node.abstract ? "abstract " : "", node.declare ? "declare " : "", node.computed ? "[" : "", print("key"), node.computed ? "]" : "", printOptionalToken(path));
          const parametersDoc = printFunctionParameters(path, print, options, false, true);
          const returnTypePropertyName = node.returnType ? "returnType" : "typeAnnotation";
          const returnTypeNode = node[returnTypePropertyName];
          const returnTypeDoc = returnTypeNode ? print(returnTypePropertyName) : "";
          const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);
          parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);
          if (returnTypeNode) {
            parts.push(": ", group(returnTypeDoc));
          }
          return group(parts);
        }
        case "TSNamespaceExportDeclaration":
          parts.push("export as namespace ", print("id"));
          if (options.semi) {
            parts.push(";");
          }
          return group(parts);
        case "TSEnumDeclaration":
          if (node.declare) {
            parts.push("declare ");
          }
          if (node.modifiers) {
            parts.push(printTypeScriptModifiers(path, options, print));
          }
          if (node.const) {
            parts.push("const ");
          }
          parts.push("enum ", print("id"), " ");
          if (node.members.length === 0) {
            parts.push(group(["{", printDanglingComments(path, options), softline, "}"]));
          } else {
            parts.push(group(["{", indent([hardline, printArrayItems(path, options, "members", print), shouldPrintComma(options, "es5") ? "," : ""]), printDanglingComments(path, options, true), hardline, "}"]));
          }
          return parts;
        case "TSEnumMember":
          if (node.computed) {
            parts.push("[", print("id"), "]");
          } else {
            parts.push(print("id"));
          }
          if (node.initializer) {
            parts.push(" = ", print("initializer"));
          }
          return parts;
        case "TSImportEqualsDeclaration":
          if (node.isExport) {
            parts.push("export ");
          }
          parts.push("import ");
          if (node.importKind && node.importKind !== "value") {
            parts.push(node.importKind, " ");
          }
          parts.push(print("id"), " = ", print("moduleReference"));
          if (options.semi) {
            parts.push(";");
          }
          return group(parts);
        case "TSExternalModuleReference":
          return ["require(", print("expression"), ")"];
        case "TSModuleDeclaration": {
          const parent = path.getParentNode();
          const isExternalModule = isStringLiteral(node.id);
          const parentIsDeclaration = parent.type === "TSModuleDeclaration";
          const bodyIsDeclaration = node.body && node.body.type === "TSModuleDeclaration";
          if (parentIsDeclaration) {
            parts.push(".");
          } else {
            if (node.declare) {
              parts.push("declare ");
            }
            parts.push(printTypeScriptModifiers(path, options, print));
            const textBetweenNodeAndItsId = options.originalText.slice(locStart(node), locStart(node.id));
            const isGlobalDeclaration = node.id.type === "Identifier" && node.id.name === "global" && !/namespace|module/.test(textBetweenNodeAndItsId);
            if (!isGlobalDeclaration) {
              parts.push(isExternalModule || /(?:^|\s)module(?:\s|$)/.test(textBetweenNodeAndItsId) ? "module " : "namespace ");
            }
          }
          parts.push(print("id"));
          if (bodyIsDeclaration) {
            parts.push(print("body"));
          } else if (node.body) {
            parts.push(" ", group(print("body")));
          } else {
            parts.push(semi);
          }
          return parts;
        }
        case "TSConditionalType":
          return printTernary(path, options, print);
        case "TSInferType":
          return ["infer", " ", print("typeParameter")];
        case "TSIntersectionType":
          return printIntersectionType(path, options, print);
        case "TSUnionType":
          return printUnionType(path, options, print);
        case "TSFunctionType":
          return printFunctionType(path, options, print);
        case "TSTupleType":
          return printTupleType(path, options, print);
        case "TSTypeReference":
          return [print("typeName"), printTypeParameters(path, options, print, "typeParameters")];
        case "TSTypeAnnotation":
          return print("typeAnnotation");
        case "TSEmptyBodyFunctionExpression":
          return printMethodInternal(path, options, print);
        case "TSJSDocAllType":
          return "*";
        case "TSJSDocUnknownType":
          return "?";
        case "TSJSDocNullableType":
          return printJSDocType(path, print, "?");
        case "TSJSDocNonNullableType":
          return printJSDocType(path, print, "!");
        case "TSInstantiationExpression":
          return [print("expression"), print("typeParameters")];
        default:
          throw new Error(`Unknown TypeScript node type: ${JSON.stringify(node.type)}.`);
      }
    }
    module2.exports = {
      printTypescript
    };
  }
});
var require_comment = __commonJS2({
  "src/language-js/print/comment.js"(exports2, module2) {
    "use strict";
    var {
      hasNewline
    } = require_util();
    var {
      builders: {
        join,
        hardline
      },
      utils: {
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var {
      isLineComment
    } = require_utils7();
    var {
      locStart,
      locEnd
    } = require_loc();
    var isBlockComment = require_is_block_comment();
    function printComment(commentPath, options) {
      const comment = commentPath.getValue();
      if (isLineComment(comment)) {
        return options.originalText.slice(locStart(comment), locEnd(comment)).trimEnd();
      }
      if (isBlockComment(comment)) {
        if (isIndentableBlockComment(comment)) {
          const printed = printIndentableBlockComment(comment);
          if (comment.trailing && !hasNewline(options.originalText, locStart(comment), {
            backwards: true
          })) {
            return [hardline, printed];
          }
          return printed;
        }
        const commentEnd = locEnd(comment);
        const isInsideFlowComment = options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";
        return ["/*", replaceTextEndOfLine(comment.value), isInsideFlowComment ? "*-/" : "*/"];
      }
      throw new Error("Not a comment: " + JSON.stringify(comment));
    }
    function isIndentableBlockComment(comment) {
      const lines = `*${comment.value}*`.split("\n");
      return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");
    }
    function printIndentableBlockComment(comment) {
      const lines = comment.value.split("\n");
      return ["/*", join(hardline, lines.map((line, index) => index === 0 ? line.trimEnd() : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))), "*/"];
    }
    module2.exports = {
      printComment
    };
  }
});
var require_literal = __commonJS2({
  "src/language-js/print/literal.js"(exports2, module2) {
    "use strict";
    var {
      printString,
      printNumber
    } = require_util();
    var {
      replaceTextEndOfLine
    } = require_doc_utils();
    var {
      printDirective
    } = require_misc();
    function printLiteral(path, options) {
      const node = path.getNode();
      switch (node.type) {
        case "RegExpLiteral":
          return printRegex(node);
        case "BigIntLiteral":
          return printBigInt(node.bigint || node.extra.raw);
        case "NumericLiteral":
          return printNumber(node.extra.raw);
        case "StringLiteral":
          return replaceTextEndOfLine(printString(node.extra.raw, options));
        case "NullLiteral":
          return "null";
        case "BooleanLiteral":
          return String(node.value);
        case "DecimalLiteral":
          return printNumber(node.value) + "m";
        case "Literal": {
          if (node.regex) {
            return printRegex(node.regex);
          }
          if (node.bigint) {
            return printBigInt(node.raw);
          }
          if (node.decimal) {
            return printNumber(node.decimal) + "m";
          }
          const {
            value
          } = node;
          if (typeof value === "number") {
            return printNumber(node.raw);
          }
          if (typeof value === "string") {
            return isDirective(path) ? printDirective(node.raw, options) : replaceTextEndOfLine(printString(node.raw, options));
          }
          return String(value);
        }
      }
    }
    function isDirective(path) {
      if (path.getName() !== "expression") {
        return;
      }
      const parent = path.getParentNode();
      return parent.type === "ExpressionStatement" && parent.directive;
    }
    function printBigInt(raw) {
      return raw.toLowerCase();
    }
    function printRegex({
      pattern,
      flags
    }) {
      flags = [...flags].sort().join("");
      return `/${pattern}/${flags}`;
    }
    module2.exports = {
      printLiteral
    };
  }
});
var require_printer_estree = __commonJS2({
  "src/language-js/printer-estree.js"(exports2, module2) {
    "use strict";
    var {
      printDanglingComments
    } = require_comments();
    var {
      hasNewline
    } = require_util();
    var {
      builders: {
        join,
        line,
        hardline,
        softline,
        group,
        indent
      },
      utils: {
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var embed = require_embed();
    var clean = require_clean();
    var {
      insertPragma
    } = require_pragma();
    var handleComments = require_comments2();
    var pathNeedsParens = require_needs_parens();
    var preprocess = require_print_preprocess();
    var {
      hasFlowShorthandAnnotationComment,
      hasComment,
      CommentCheckFlags,
      isTheOnlyJsxElementInMarkdown,
      isLineComment,
      isNextLineEmpty,
      needsHardlineAfterDanglingComment,
      hasIgnoreComment,
      isCallExpression,
      isMemberExpression,
      markerForIfWithoutBlockAndSameLineComment
    } = require_utils7();
    var {
      locStart,
      locEnd
    } = require_loc();
    var isBlockComment = require_is_block_comment();
    var {
      printHtmlBinding,
      isVueEventBindingExpression
    } = require_html_binding();
    var {
      printAngular
    } = require_angular();
    var {
      printJsx,
      hasJsxIgnoreComment
    } = require_jsx();
    var {
      printFlow
    } = require_flow();
    var {
      printTypescript
    } = require_typescript();
    var {
      printOptionalToken,
      printBindExpressionCallee,
      printTypeAnnotation,
      adjustClause,
      printRestSpread,
      printDefiniteToken,
      printDirective
    } = require_misc();
    var {
      printImportDeclaration,
      printExportDeclaration,
      printExportAllDeclaration,
      printModuleSpecifier
    } = require_module();
    var {
      printTernary
    } = require_ternary();
    var {
      printTemplateLiteral
    } = require_template_literal();
    var {
      printArray
    } = require_array4();
    var {
      printObject
    } = require_object();
    var {
      printClass,
      printClassMethod,
      printClassProperty
    } = require_class();
    var {
      printProperty
    } = require_property();
    var {
      printFunction,
      printArrowFunction,
      printMethod,
      printReturnStatement,
      printThrowStatement
    } = require_function();
    var {
      printCallExpression
    } = require_call_expression();
    var {
      printVariableDeclarator,
      printAssignmentExpression
    } = require_assignment();
    var {
      printBinaryishExpression
    } = require_binaryish();
    var {
      printSwitchCaseConsequent
    } = require_statement();
    var {
      printMemberExpression
    } = require_member();
    var {
      printBlock,
      printBlockBody
    } = require_block();
    var {
      printComment
    } = require_comment();
    var {
      printLiteral
    } = require_literal();
    var {
      printDecorators
    } = require_decorators();
    function genericPrint(path, options, print, args) {
      const printed = printPathNoParens(path, options, print, args);
      if (!printed) {
        return "";
      }
      const node = path.getValue();
      const {
        type
      } = node;
      if (type === "ClassMethod" || type === "ClassPrivateMethod" || type === "ClassProperty" || type === "ClassAccessorProperty" || type === "AccessorProperty" || type === "TSAbstractAccessorProperty" || type === "PropertyDefinition" || type === "TSAbstractPropertyDefinition" || type === "ClassPrivateProperty" || type === "MethodDefinition" || type === "TSAbstractMethodDefinition" || type === "TSDeclareMethod") {
        return printed;
      }
      let parts = [printed];
      const printedDecorators = printDecorators(path, options, print);
      const isClassExpressionWithDecorators = node.type === "ClassExpression" && printedDecorators;
      if (printedDecorators) {
        parts = [...printedDecorators, printed];
        if (!isClassExpressionWithDecorators) {
          return group(parts);
        }
      }
      const needsParens = pathNeedsParens(path, options);
      if (!needsParens) {
        if (args && args.needsSemi) {
          parts.unshift(";");
        }
        if (parts.length === 1 && parts[0] === printed) {
          return printed;
        }
        return parts;
      }
      if (isClassExpressionWithDecorators) {
        parts = [indent([line, ...parts])];
      }
      parts.unshift("(");
      if (args && args.needsSemi) {
        parts.unshift(";");
      }
      if (hasFlowShorthandAnnotationComment(node)) {
        const [comment] = node.trailingComments;
        parts.push(" /*", comment.value.trimStart(), "*/");
        comment.printed = true;
      }
      if (isClassExpressionWithDecorators) {
        parts.push(line);
      }
      parts.push(")");
      return parts;
    }
    function printPathNoParens(path, options, print, args) {
      const node = path.getValue();
      const semi = options.semi ? ";" : "";
      if (!node) {
        return "";
      }
      if (typeof node === "string") {
        return node;
      }
      for (const printer of [printLiteral, printHtmlBinding, printAngular, printJsx, printFlow, printTypescript]) {
        const printed = printer(path, options, print);
        if (typeof printed !== "undefined") {
          return printed;
        }
      }
      let parts = [];
      switch (node.type) {
        case "JsExpressionRoot":
          return print("node");
        case "JsonRoot":
          return [print("node"), hardline];
        case "File":
          if (node.program && node.program.interpreter) {
            parts.push(print(["program", "interpreter"]));
          }
          parts.push(print("program"));
          return parts;
        case "Program":
          return printBlockBody(path, options, print);
        case "EmptyStatement":
          return "";
        case "ExpressionStatement": {
          if (options.parser === "__vue_event_binding" || options.parser === "__vue_ts_event_binding") {
            const parent = path.getParentNode();
            if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === node) {
              return [print("expression"), isVueEventBindingExpression(node.expression) ? ";" : ""];
            }
          }
          const danglingComment = printDanglingComments(path, options, true, ({
            marker
          }) => marker === markerForIfWithoutBlockAndSameLineComment);
          return [print("expression"), isTheOnlyJsxElementInMarkdown(options, path) ? "" : semi, danglingComment ? [" ", danglingComment] : ""];
        }
        case "ParenthesizedExpression": {
          const shouldHug = !hasComment(node.expression) && (node.expression.type === "ObjectExpression" || node.expression.type === "ArrayExpression");
          if (shouldHug) {
            return ["(", print("expression"), ")"];
          }
          return group(["(", indent([softline, print("expression")]), softline, ")"]);
        }
        case "AssignmentExpression":
          return printAssignmentExpression(path, options, print);
        case "VariableDeclarator":
          return printVariableDeclarator(path, options, print);
        case "BinaryExpression":
        case "LogicalExpression":
          return printBinaryishExpression(path, options, print);
        case "AssignmentPattern":
          return [print("left"), " = ", print("right")];
        case "OptionalMemberExpression":
        case "MemberExpression": {
          return printMemberExpression(path, options, print);
        }
        case "MetaProperty":
          return [print("meta"), ".", print("property")];
        case "BindExpression":
          if (node.object) {
            parts.push(print("object"));
          }
          parts.push(group(indent([softline, printBindExpressionCallee(path, options, print)])));
          return parts;
        case "Identifier": {
          return [node.name, printOptionalToken(path), printDefiniteToken(path), printTypeAnnotation(path, options, print)];
        }
        case "V8IntrinsicIdentifier":
          return ["%", node.name];
        case "SpreadElement":
        case "SpreadElementPattern":
        case "SpreadProperty":
        case "SpreadPropertyPattern":
        case "RestElement":
          return printRestSpread(path, options, print);
        case "FunctionDeclaration":
        case "FunctionExpression":
          return printFunction(path, print, options, args);
        case "ArrowFunctionExpression":
          return printArrowFunction(path, options, print, args);
        case "YieldExpression":
          parts.push("yield");
          if (node.delegate) {
            parts.push("*");
          }
          if (node.argument) {
            parts.push(" ", print("argument"));
          }
          return parts;
        case "AwaitExpression": {
          parts.push("await");
          if (node.argument) {
            parts.push(" ", print("argument"));
            const parent = path.getParentNode();
            if (isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node) {
              parts = [indent([softline, ...parts]), softline];
              const parentAwaitOrBlock = path.findAncestor((node2) => node2.type === "AwaitExpression" || node2.type === "BlockStatement");
              if (!parentAwaitOrBlock || parentAwaitOrBlock.type !== "AwaitExpression") {
                return group(parts);
              }
            }
          }
          return parts;
        }
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          return printExportDeclaration(path, options, print);
        case "ExportAllDeclaration":
          return printExportAllDeclaration(path, options, print);
        case "ImportDeclaration":
          return printImportDeclaration(path, options, print);
        case "ImportSpecifier":
        case "ExportSpecifier":
        case "ImportNamespaceSpecifier":
        case "ExportNamespaceSpecifier":
        case "ImportDefaultSpecifier":
        case "ExportDefaultSpecifier":
          return printModuleSpecifier(path, options, print);
        case "ImportAttribute":
          return [print("key"), ": ", print("value")];
        case "Import":
          return "import";
        case "BlockStatement":
        case "StaticBlock":
        case "ClassBody":
          return printBlock(path, options, print);
        case "ThrowStatement":
          return printThrowStatement(path, options, print);
        case "ReturnStatement":
          return printReturnStatement(path, options, print);
        case "NewExpression":
        case "ImportExpression":
        case "OptionalCallExpression":
        case "CallExpression":
          return printCallExpression(path, options, print);
        case "ObjectExpression":
        case "ObjectPattern":
        case "RecordExpression":
          return printObject(path, options, print);
        case "ObjectProperty":
        case "Property":
          if (node.method || node.kind === "get" || node.kind === "set") {
            return printMethod(path, options, print);
          }
          return printProperty(path, options, print);
        case "ObjectMethod":
          return printMethod(path, options, print);
        case "Decorator":
          return ["@", print("expression")];
        case "ArrayExpression":
        case "ArrayPattern":
        case "TupleExpression":
          return printArray(path, options, print);
        case "SequenceExpression": {
          const parent = path.getParentNode(0);
          if (parent.type === "ExpressionStatement" || parent.type === "ForStatement") {
            const parts2 = [];
            path.each((expressionPath, index) => {
              if (index === 0) {
                parts2.push(print());
              } else {
                parts2.push(",", indent([line, print()]));
              }
            }, "expressions");
            return group(parts2);
          }
          return group(join([",", line], path.map(print, "expressions")));
        }
        case "ThisExpression":
          return "this";
        case "Super":
          return "super";
        case "Directive":
          return [print("value"), semi];
        case "DirectiveLiteral":
          return printDirective(node.extra.raw, options);
        case "UnaryExpression":
          parts.push(node.operator);
          if (/[a-z]$/.test(node.operator)) {
            parts.push(" ");
          }
          if (hasComment(node.argument)) {
            parts.push(group(["(", indent([softline, print("argument")]), softline, ")"]));
          } else {
            parts.push(print("argument"));
          }
          return parts;
        case "UpdateExpression":
          parts.push(print("argument"), node.operator);
          if (node.prefix) {
            parts.reverse();
          }
          return parts;
        case "ConditionalExpression":
          return printTernary(path, options, print);
        case "VariableDeclaration": {
          const printed = path.map(print, "declarations");
          const parentNode = path.getParentNode();
          const isParentForLoop = parentNode.type === "ForStatement" || parentNode.type === "ForInStatement" || parentNode.type === "ForOfStatement";
          const hasValue = node.declarations.some((decl) => decl.init);
          let firstVariable;
          if (printed.length === 1 && !hasComment(node.declarations[0])) {
            firstVariable = printed[0];
          } else if (printed.length > 0) {
            firstVariable = indent(printed[0]);
          }
          parts = [node.declare ? "declare " : "", node.kind, firstVariable ? [" ", firstVariable] : "", indent(printed.slice(1).map((p) => [",", hasValue && !isParentForLoop ? hardline : line, p]))];
          if (!(isParentForLoop && parentNode.body !== node)) {
            parts.push(semi);
          }
          return group(parts);
        }
        case "WithStatement":
          return group(["with (", print("object"), ")", adjustClause(node.body, print("body"))]);
        case "IfStatement": {
          const con = adjustClause(node.consequent, print("consequent"));
          const opening = group(["if (", group([indent([softline, print("test")]), softline]), ")", con]);
          parts.push(opening);
          if (node.alternate) {
            const commentOnOwnLine = hasComment(node.consequent, CommentCheckFlags.Trailing | CommentCheckFlags.Line) || needsHardlineAfterDanglingComment(node);
            const elseOnSameLine = node.consequent.type === "BlockStatement" && !commentOnOwnLine;
            parts.push(elseOnSameLine ? " " : hardline);
            if (hasComment(node, CommentCheckFlags.Dangling)) {
              parts.push(printDanglingComments(path, options, true), commentOnOwnLine ? hardline : " ");
            }
            parts.push("else", group(adjustClause(node.alternate, print("alternate"), node.alternate.type === "IfStatement")));
          }
          return parts;
        }
        case "ForStatement": {
          const body = adjustClause(node.body, print("body"));
          const dangling = printDanglingComments(path, options, true);
          const printedComments = dangling ? [dangling, softline] : "";
          if (!node.init && !node.test && !node.update) {
            return [printedComments, group(["for (;;)", body])];
          }
          return [printedComments, group(["for (", group([indent([softline, print("init"), ";", line, print("test"), ";", line, print("update")]), softline]), ")", body])];
        }
        case "WhileStatement":
          return group(["while (", group([indent([softline, print("test")]), softline]), ")", adjustClause(node.body, print("body"))]);
        case "ForInStatement":
          return group(["for (", print("left"), " in ", print("right"), ")", adjustClause(node.body, print("body"))]);
        case "ForOfStatement":
          return group(["for", node.await ? " await" : "", " (", print("left"), " of ", print("right"), ")", adjustClause(node.body, print("body"))]);
        case "DoWhileStatement": {
          const clause = adjustClause(node.body, print("body"));
          const doBody = group(["do", clause]);
          parts = [doBody];
          if (node.body.type === "BlockStatement") {
            parts.push(" ");
          } else {
            parts.push(hardline);
          }
          parts.push("while (", group([indent([softline, print("test")]), softline]), ")", semi);
          return parts;
        }
        case "DoExpression":
          return [node.async ? "async " : "", "do ", print("body")];
        case "BreakStatement":
          parts.push("break");
          if (node.label) {
            parts.push(" ", print("label"));
          }
          parts.push(semi);
          return parts;
        case "ContinueStatement":
          parts.push("continue");
          if (node.label) {
            parts.push(" ", print("label"));
          }
          parts.push(semi);
          return parts;
        case "LabeledStatement":
          if (node.body.type === "EmptyStatement") {
            return [print("label"), ":;"];
          }
          return [print("label"), ": ", print("body")];
        case "TryStatement":
          return ["try ", print("block"), node.handler ? [" ", print("handler")] : "", node.finalizer ? [" finally ", print("finalizer")] : ""];
        case "CatchClause":
          if (node.param) {
            const parameterHasComments = hasComment(node.param, (comment) => !isBlockComment(comment) || comment.leading && hasNewline(options.originalText, locEnd(comment)) || comment.trailing && hasNewline(options.originalText, locStart(comment), {
              backwards: true
            }));
            const param = print("param");
            return ["catch ", parameterHasComments ? ["(", indent([softline, param]), softline, ") "] : ["(", param, ") "], print("body")];
          }
          return ["catch ", print("body")];
        case "SwitchStatement":
          return [group(["switch (", indent([softline, print("discriminant")]), softline, ")"]), " {", node.cases.length > 0 ? indent([hardline, join(hardline, path.map((casePath, index, cases) => {
            const caseNode = casePath.getValue();
            return [print(), index !== cases.length - 1 && isNextLineEmpty(caseNode, options) ? hardline : ""];
          }, "cases"))]) : "", hardline, "}"];
        case "SwitchCase": {
          if (node.test) {
            parts.push("case ", print("test"), ":");
          } else {
            parts.push("default:");
          }
          if (hasComment(node, CommentCheckFlags.Dangling)) {
            parts.push(" ", printDanglingComments(path, options, true));
          }
          const consequent = node.consequent.filter((node2) => node2.type !== "EmptyStatement");
          if (consequent.length > 0) {
            const cons = printSwitchCaseConsequent(path, options, print);
            parts.push(consequent.length === 1 && consequent[0].type === "BlockStatement" ? [" ", cons] : indent([hardline, cons]));
          }
          return parts;
        }
        case "DebuggerStatement":
          return ["debugger", semi];
        case "ClassDeclaration":
        case "ClassExpression":
          return printClass(path, options, print);
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "MethodDefinition":
          return printClassMethod(path, options, print);
        case "ClassProperty":
        case "PropertyDefinition":
        case "ClassPrivateProperty":
        case "ClassAccessorProperty":
        case "AccessorProperty":
          return printClassProperty(path, options, print);
        case "TemplateElement":
          return replaceTextEndOfLine(node.value.raw);
        case "TemplateLiteral":
          return printTemplateLiteral(path, print, options);
        case "TaggedTemplateExpression":
          return [print("tag"), print("typeParameters"), print("quasi")];
        case "PrivateIdentifier":
          return ["#", print("name")];
        case "PrivateName":
          return ["#", print("id")];
        case "InterpreterDirective":
          parts.push("#!", node.value, hardline);
          if (isNextLineEmpty(node, options)) {
            parts.push(hardline);
          }
          return parts;
        case "TopicReference":
          return "%";
        case "ArgumentPlaceholder":
          return "?";
        case "ModuleExpression": {
          parts.push("module {");
          const printed = print("body");
          if (printed) {
            parts.push(indent([hardline, printed]), hardline);
          }
          parts.push("}");
          return parts;
        }
        default:
          throw new Error("unknown type: " + JSON.stringify(node.type));
      }
    }
    function canAttachComment(node) {
      return node.type && !isBlockComment(node) && !isLineComment(node) && node.type !== "EmptyStatement" && node.type !== "TemplateElement" && node.type !== "Import" && node.type !== "TSEmptyBodyFunctionExpression";
    }
    module2.exports = {
      preprocess,
      print: genericPrint,
      embed,
      insertPragma,
      massageAstNode: clean,
      hasPrettierIgnore(path) {
        return hasIgnoreComment(path) || hasJsxIgnoreComment(path);
      },
      willPrintOwnComments: handleComments.willPrintOwnComments,
      canAttachComment,
      printComment,
      isBlockComment,
      handleComments: {
        avoidAstMutation: true,
        ownLine: handleComments.handleOwnLineComment,
        endOfLine: handleComments.handleEndOfLineComment,
        remaining: handleComments.handleRemainingComment
      },
      getCommentChildNodes: handleComments.getCommentChildNodes
    };
  }
});
var require_printer_estree_json = __commonJS2({
  "src/language-js/printer-estree-json.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        hardline,
        indent,
        join
      }
    } = require("./doc.js");
    var preprocess = require_print_preprocess();
    function genericPrint(path, options, print) {
      const node = path.getValue();
      switch (node.type) {
        case "JsonRoot":
          return [print("node"), hardline];
        case "ArrayExpression": {
          if (node.elements.length === 0) {
            return "[]";
          }
          const printed = path.map(() => path.getValue() === null ? "null" : print(), "elements");
          return ["[", indent([hardline, join([",", hardline], printed)]), hardline, "]"];
        }
        case "ObjectExpression":
          return node.properties.length === 0 ? "{}" : ["{", indent([hardline, join([",", hardline], path.map(print, "properties"))]), hardline, "}"];
        case "ObjectProperty":
          return [print("key"), ": ", print("value")];
        case "UnaryExpression":
          return [node.operator === "+" ? "" : node.operator, print("argument")];
        case "NullLiteral":
          return "null";
        case "BooleanLiteral":
          return node.value ? "true" : "false";
        case "StringLiteral":
          return JSON.stringify(node.value);
        case "NumericLiteral":
          return isObjectKey(path) ? JSON.stringify(String(node.value)) : JSON.stringify(node.value);
        case "Identifier":
          return isObjectKey(path) ? JSON.stringify(node.name) : node.name;
        case "TemplateLiteral":
          return print(["quasis", 0]);
        case "TemplateElement":
          return JSON.stringify(node.value.cooked);
        default:
          throw new Error("unknown type: " + JSON.stringify(node.type));
      }
    }
    function isObjectKey(path) {
      return path.getName() === "key" && path.getParentNode().type === "ObjectProperty";
    }
    var ignoredProperties = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
    function clean(node, newNode) {
      const {
        type
      } = node;
      if (type === "ObjectProperty") {
        const {
          key
        } = node;
        if (key.type === "Identifier") {
          newNode.key = {
            type: "StringLiteral",
            value: key.name
          };
        } else if (key.type === "NumericLiteral") {
          newNode.key = {
            type: "StringLiteral",
            value: String(key.value)
          };
        }
        return;
      }
      if (type === "UnaryExpression" && node.operator === "+") {
        return newNode.argument;
      }
      if (type === "ArrayExpression") {
        for (const [index, element] of node.elements.entries()) {
          if (element === null) {
            newNode.elements.splice(index, 0, {
              type: "NullLiteral"
            });
          }
        }
        return;
      }
      if (type === "TemplateLiteral") {
        return {
          type: "StringLiteral",
          value: node.quasis[0].value.cooked
        };
      }
    }
    clean.ignoredProperties = ignoredProperties;
    module2.exports = {
      preprocess,
      print: genericPrint,
      massageAstNode: clean
    };
  }
});
var require_common_options = __commonJS2({
  "src/common/common-options.js"(exports2, module2) {
    "use strict";
    var CATEGORY_COMMON = "Common";
    module2.exports = {
      bracketSpacing: {
        since: "0.0.0",
        category: CATEGORY_COMMON,
        type: "boolean",
        default: true,
        description: "Print spaces between brackets.",
        oppositeDescription: "Do not print spaces between brackets."
      },
      singleQuote: {
        since: "0.0.0",
        category: CATEGORY_COMMON,
        type: "boolean",
        default: false,
        description: "Use single quotes instead of double quotes."
      },
      proseWrap: {
        since: "1.8.2",
        category: CATEGORY_COMMON,
        type: "choice",
        default: [{
          since: "1.8.2",
          value: true
        }, {
          since: "1.9.0",
          value: "preserve"
        }],
        description: "How to wrap prose.",
        choices: [{
          since: "1.9.0",
          value: "always",
          description: "Wrap prose if it exceeds the print width."
        }, {
          since: "1.9.0",
          value: "never",
          description: "Do not wrap prose."
        }, {
          since: "1.9.0",
          value: "preserve",
          description: "Wrap prose as-is."
        }]
      },
      bracketSameLine: {
        since: "2.4.0",
        category: CATEGORY_COMMON,
        type: "boolean",
        default: false,
        description: "Put > of opening tags on the last line instead of on a new line."
      },
      singleAttributePerLine: {
        since: "2.6.0",
        category: CATEGORY_COMMON,
        type: "boolean",
        default: false,
        description: "Enforce single attribute per line in HTML, Vue and JSX."
      }
    };
  }
});
var require_options2 = __commonJS2({
  "src/language-js/options.js"(exports2, module2) {
    "use strict";
    var commonOptions = require_common_options();
    var CATEGORY_JAVASCRIPT = "JavaScript";
    module2.exports = {
      arrowParens: {
        since: "1.9.0",
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: [{
          since: "1.9.0",
          value: "avoid"
        }, {
          since: "2.0.0",
          value: "always"
        }],
        description: "Include parentheses around a sole arrow function parameter.",
        choices: [{
          value: "always",
          description: "Always include parens. Example: `(x) => x`"
        }, {
          value: "avoid",
          description: "Omit parens when possible. Example: `x => x`"
        }]
      },
      bracketSameLine: commonOptions.bracketSameLine,
      bracketSpacing: commonOptions.bracketSpacing,
      jsxBracketSameLine: {
        since: "0.17.0",
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        description: "Put > on the last line instead of at a new line.",
        deprecated: "2.4.0"
      },
      semi: {
        since: "1.0.0",
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        default: true,
        description: "Print semicolons.",
        oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
      },
      singleQuote: commonOptions.singleQuote,
      jsxSingleQuote: {
        since: "1.15.0",
        category: CATEGORY_JAVASCRIPT,
        type: "boolean",
        default: false,
        description: "Use single quotes in JSX."
      },
      quoteProps: {
        since: "1.17.0",
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: "as-needed",
        description: "Change when properties in objects are quoted.",
        choices: [{
          value: "as-needed",
          description: "Only add quotes around object properties where required."
        }, {
          value: "consistent",
          description: "If at least one property in an object requires quotes, quote all properties."
        }, {
          value: "preserve",
          description: "Respect the input use of quotes in object properties."
        }]
      },
      trailingComma: {
        since: "0.0.0",
        category: CATEGORY_JAVASCRIPT,
        type: "choice",
        default: [{
          since: "0.0.0",
          value: false
        }, {
          since: "0.19.0",
          value: "none"
        }, {
          since: "2.0.0",
          value: "es5"
        }],
        description: "Print trailing commas wherever possible when multi-line.",
        choices: [{
          value: "es5",
          description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
        }, {
          value: "none",
          description: "No trailing commas."
        }, {
          value: "all",
          description: "Trailing commas wherever possible (including function arguments)."
        }]
      },
      singleAttributePerLine: commonOptions.singleAttributePerLine
    };
  }
});
var require_parsers = __commonJS2({
  "src/language-js/parse/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get babel() {
        return require("./parser-babel.js").parsers.babel;
      },
      get "babel-flow"() {
        return require("./parser-babel.js").parsers["babel-flow"];
      },
      get "babel-ts"() {
        return require("./parser-babel.js").parsers["babel-ts"];
      },
      get json() {
        return require("./parser-babel.js").parsers.json;
      },
      get json5() {
        return require("./parser-babel.js").parsers.json5;
      },
      get "json-stringify"() {
        return require("./parser-babel.js").parsers["json-stringify"];
      },
      get __js_expression() {
        return require("./parser-babel.js").parsers.__js_expression;
      },
      get __vue_expression() {
        return require("./parser-babel.js").parsers.__vue_expression;
      },
      get __vue_ts_expression() {
        return require("./parser-babel.js").parsers.__vue_ts_expression;
      },
      get __vue_event_binding() {
        return require("./parser-babel.js").parsers.__vue_event_binding;
      },
      get __vue_ts_event_binding() {
        return require("./parser-babel.js").parsers.__vue_ts_event_binding;
      },
      get flow() {
        return require("./parser-flow.js").parsers.flow;
      },
      get typescript() {
        return require("./parser-typescript.js").parsers.typescript;
      },
      get __ng_action() {
        return require("./parser-angular.js").parsers.__ng_action;
      },
      get __ng_binding() {
        return require("./parser-angular.js").parsers.__ng_binding;
      },
      get __ng_interpolation() {
        return require("./parser-angular.js").parsers.__ng_interpolation;
      },
      get __ng_directive() {
        return require("./parser-angular.js").parsers.__ng_directive;
      },
      get acorn() {
        return require("./parser-espree.js").parsers.acorn;
      },
      get espree() {
        return require("./parser-espree.js").parsers.espree;
      },
      get meriyah() {
        return require("./parser-meriyah.js").parsers.meriyah;
      },
      get __babel_estree() {
        return require("./parser-babel.js").parsers.__babel_estree;
      }
    };
  }
});
var require_JavaScript = __commonJS2({
  "node_modules/linguist-languages/data/JavaScript.json"(exports2, module2) {
    module2.exports = {
      name: "JavaScript",
      type: "programming",
      tmScope: "source.js",
      aceMode: "javascript",
      codemirrorMode: "javascript",
      codemirrorMimeType: "text/javascript",
      color: "#f1e05a",
      aliases: ["js", "node"],
      extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"],
      filenames: ["Jakefile"],
      interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"],
      languageId: 183
    };
  }
});
var require_TypeScript = __commonJS2({
  "node_modules/linguist-languages/data/TypeScript.json"(exports2, module2) {
    module2.exports = {
      name: "TypeScript",
      type: "programming",
      color: "#3178c6",
      aliases: ["ts"],
      interpreters: ["deno", "ts-node"],
      extensions: [".ts", ".cts", ".mts"],
      tmScope: "source.ts",
      aceMode: "typescript",
      codemirrorMode: "javascript",
      codemirrorMimeType: "application/typescript",
      languageId: 378
    };
  }
});
var require_TSX = __commonJS2({
  "node_modules/linguist-languages/data/TSX.json"(exports2, module2) {
    module2.exports = {
      name: "TSX",
      type: "programming",
      color: "#3178c6",
      group: "TypeScript",
      extensions: [".tsx"],
      tmScope: "source.tsx",
      aceMode: "javascript",
      codemirrorMode: "jsx",
      codemirrorMimeType: "text/jsx",
      languageId: 94901924
    };
  }
});
var require_JSON = __commonJS2({
  "node_modules/linguist-languages/data/JSON.json"(exports2, module2) {
    module2.exports = {
      name: "JSON",
      type: "data",
      color: "#292929",
      tmScope: "source.json",
      aceMode: "json",
      codemirrorMode: "javascript",
      codemirrorMimeType: "application/json",
      aliases: ["geojson", "jsonl", "topojson"],
      extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"],
      filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"],
      languageId: 174
    };
  }
});
var require_JSON_with_Comments = __commonJS2({
  "node_modules/linguist-languages/data/JSON with Comments.json"(exports2, module2) {
    module2.exports = {
      name: "JSON with Comments",
      type: "data",
      color: "#292929",
      group: "JSON",
      tmScope: "source.js",
      aceMode: "javascript",
      codemirrorMode: "javascript",
      codemirrorMimeType: "text/javascript",
      aliases: ["jsonc"],
      extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"],
      filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"],
      languageId: 423
    };
  }
});
var require_JSON5 = __commonJS2({
  "node_modules/linguist-languages/data/JSON5.json"(exports2, module2) {
    module2.exports = {
      name: "JSON5",
      type: "data",
      color: "#267CB9",
      extensions: [".json5"],
      tmScope: "source.js",
      aceMode: "javascript",
      codemirrorMode: "javascript",
      codemirrorMimeType: "application/json",
      languageId: 175
    };
  }
});
var require_language_js = __commonJS2({
  "src/language-js/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var estreePrinter = require_printer_estree();
    var estreeJsonPrinter = require_printer_estree_json();
    var options = require_options2();
    var parsers = require_parsers();
    var languages = [createLanguage(require_JavaScript(), (data) => ({
      since: "0.0.0",
      parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"],
      vscodeLanguageIds: ["javascript", "mongo"],
      interpreters: [...data.interpreters, "zx"],
      extensions: [...data.extensions.filter((extension) => extension !== ".jsx"), ".wxs"]
    })), createLanguage(require_JavaScript(), () => ({
      name: "Flow",
      since: "0.0.0",
      parsers: ["flow", "babel-flow"],
      vscodeLanguageIds: ["javascript"],
      aliases: [],
      filenames: [],
      extensions: [".js.flow"]
    })), createLanguage(require_JavaScript(), () => ({
      name: "JSX",
      since: "0.0.0",
      parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"],
      vscodeLanguageIds: ["javascriptreact"],
      aliases: void 0,
      filenames: void 0,
      extensions: [".jsx"],
      group: "JavaScript",
      interpreters: void 0,
      tmScope: "source.js.jsx",
      aceMode: "javascript",
      codemirrorMode: "jsx",
      codemirrorMimeType: "text/jsx",
      color: void 0
    })), createLanguage(require_TypeScript(), () => ({
      since: "1.4.0",
      parsers: ["typescript", "babel-ts"],
      vscodeLanguageIds: ["typescript"]
    })), createLanguage(require_TSX(), () => ({
      since: "1.4.0",
      parsers: ["typescript", "babel-ts"],
      vscodeLanguageIds: ["typescriptreact"]
    })), createLanguage(require_JSON(), () => ({
      name: "JSON.stringify",
      since: "1.13.0",
      parsers: ["json-stringify"],
      vscodeLanguageIds: ["json"],
      extensions: [".importmap"],
      filenames: ["package.json", "package-lock.json", "composer.json"]
    })), createLanguage(require_JSON(), (data) => ({
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["json"],
      extensions: data.extensions.filter((extension) => extension !== ".jsonl")
    })), createLanguage(require_JSON_with_Comments(), (data) => ({
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["jsonc"],
      filenames: [...data.filenames, ".eslintrc", ".swcrc"]
    })), createLanguage(require_JSON5(), () => ({
      since: "1.13.0",
      parsers: ["json5"],
      vscodeLanguageIds: ["json5"]
    }))];
    var printers = {
      estree: estreePrinter,
      "estree-json": estreeJsonPrinter
    };
    module2.exports = {
      languages,
      options,
      printers,
      parsers
    };
  }
});
var require_clean2 = __commonJS2({
  "src/language-css/clean.js"(exports2, module2) {
    "use strict";
    var {
      isFrontMatterNode
    } = require_util();
    var getLast = require_get_last();
    var ignoredProperties = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
    function clean(ast, newObj, parent) {
      if (isFrontMatterNode(ast) && ast.lang === "yaml") {
        delete newObj.value;
      }
      if (ast.type === "css-comment" && parent.type === "css-root" && parent.nodes.length > 0) {
        if (parent.nodes[0] === ast || isFrontMatterNode(parent.nodes[0]) && parent.nodes[1] === ast) {
          delete newObj.text;
          if (/^\*\s*@(?:format|prettier)\s*$/.test(ast.text)) {
            return null;
          }
        }
        if (parent.type === "css-root" && getLast(parent.nodes) === ast) {
          return null;
        }
      }
      if (ast.type === "value-root") {
        delete newObj.text;
      }
      if (ast.type === "media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {
        delete newObj.value;
      }
      if (ast.type === "css-rule") {
        delete newObj.params;
      }
      if (ast.type === "selector-combinator") {
        newObj.value = newObj.value.replace(/\s+/g, " ");
      }
      if (ast.type === "media-feature") {
        newObj.value = newObj.value.replace(/ /g, "");
      }
      if (ast.type === "value-word" && (ast.isColor && ast.isHex || ["initial", "inherit", "unset", "revert"].includes(newObj.value.replace().toLowerCase())) || ast.type === "media-feature" || ast.type === "selector-root-invalid" || ast.type === "selector-pseudo") {
        newObj.value = newObj.value.toLowerCase();
      }
      if (ast.type === "css-decl") {
        newObj.prop = newObj.prop.toLowerCase();
      }
      if (ast.type === "css-atrule" || ast.type === "css-import") {
        newObj.name = newObj.name.toLowerCase();
      }
      if (ast.type === "value-number") {
        newObj.unit = newObj.unit.toLowerCase();
      }
      if ((ast.type === "media-feature" || ast.type === "media-keyword" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-url" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "value-string") && newObj.value) {
        newObj.value = cleanCSSStrings(newObj.value);
      }
      if (ast.type === "selector-attribute") {
        newObj.attribute = newObj.attribute.trim();
        if (newObj.namespace) {
          if (typeof newObj.namespace === "string") {
            newObj.namespace = newObj.namespace.trim();
            if (newObj.namespace.length === 0) {
              newObj.namespace = true;
            }
          }
        }
        if (newObj.value) {
          newObj.value = newObj.value.trim().replace(/^["']|["']$/g, "");
          delete newObj.quoted;
        }
      }
      if ((ast.type === "media-value" || ast.type === "media-type" || ast.type === "value-number" || ast.type === "selector-root-invalid" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "selector-tag") && newObj.value) {
        newObj.value = newObj.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (match, numStr, unit) => {
          const num = Number(numStr);
          return Number.isNaN(num) ? match : num + unit.toLowerCase();
        });
      }
      if (ast.type === "selector-tag") {
        const lowercasedValue = ast.value.toLowerCase();
        if (["from", "to"].includes(lowercasedValue)) {
          newObj.value = lowercasedValue;
        }
      }
      if (ast.type === "css-atrule" && ast.name.toLowerCase() === "supports") {
        delete newObj.value;
      }
      if (ast.type === "selector-unknown") {
        delete newObj.value;
      }
      if (ast.type === "value-comma_group") {
        const index = ast.groups.findIndex((node) => node.type === "value-number" && node.unit === "...");
        if (index !== -1) {
          newObj.groups[index].unit = "";
          newObj.groups.splice(index + 1, 0, {
            type: "value-word",
            value: "...",
            isColor: false,
            isHex: false
          });
        }
      }
      if (ast.type === "value-comma_group" && ast.groups.some((node) => node.type === "value-atword" && node.value.endsWith("[") || node.type === "value-word" && node.value.startsWith("]"))) {
        return {
          type: "value-atword",
          value: ast.groups.map((node) => node.value).join(""),
          group: {
            open: null,
            close: null,
            groups: [],
            type: "value-paren_group"
          }
        };
      }
    }
    clean.ignoredProperties = ignoredProperties;
    function cleanCSSStrings(value) {
      return value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
    }
    module2.exports = clean;
  }
});
var require_print = __commonJS2({
  "src/utils/front-matter/print.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        hardline,
        markAsRoot
      }
    } = require("./doc.js");
    function print(node, textToDoc) {
      if (node.lang === "yaml") {
        const value = node.value.trim();
        const doc2 = value ? textToDoc(value, {
          parser: "yaml"
        }, {
          stripTrailingHardline: true
        }) : "";
        return markAsRoot([node.startDelimiter, hardline, doc2, doc2 ? hardline : "", node.endDelimiter]);
      }
    }
    module2.exports = print;
  }
});
var require_embed2 = __commonJS2({
  "src/language-css/embed.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        hardline
      }
    } = require("./doc.js");
    var printFrontMatter = require_print();
    function embed(path, print, textToDoc) {
      const node = path.getValue();
      if (node.type === "front-matter") {
        const doc2 = printFrontMatter(node, textToDoc);
        return doc2 ? [doc2, hardline] : "";
      }
    }
    module2.exports = embed;
  }
});
var require_parse4 = __commonJS2({
  "src/utils/front-matter/parse.js"(exports2, module2) {
    "use strict";
    var frontMatterRegex = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
    function parse(text) {
      const match = text.match(frontMatterRegex);
      if (!match) {
        return {
          content: text
        };
      }
      const {
        startDelimiter,
        language,
        value = "",
        endDelimiter
      } = match.groups;
      let lang = language.trim() || "yaml";
      if (startDelimiter === "+++") {
        lang = "toml";
      }
      if (lang !== "yaml" && startDelimiter !== endDelimiter) {
        return {
          content: text
        };
      }
      const [raw] = match;
      const frontMatter = {
        type: "front-matter",
        lang,
        value,
        startDelimiter,
        endDelimiter,
        raw: raw.replace(/\n$/, "")
      };
      return {
        frontMatter,
        content: raw.replace(/[^\n]/g, " ") + text.slice(raw.length)
      };
    }
    module2.exports = parse;
  }
});
var require_pragma2 = __commonJS2({
  "src/language-css/pragma.js"(exports2, module2) {
    "use strict";
    var jsPragma = require_pragma();
    var parseFrontMatter = require_parse4();
    function hasPragma(text) {
      return jsPragma.hasPragma(parseFrontMatter(text).content);
    }
    function insertPragma(text) {
      const {
        frontMatter,
        content
      } = parseFrontMatter(text);
      return (frontMatter ? frontMatter.raw + "\n\n" : "") + jsPragma.insertPragma(content);
    }
    module2.exports = {
      hasPragma,
      insertPragma
    };
  }
});
var require_utils8 = __commonJS2({
  "src/language-css/utils/index.js"(exports2, module2) {
    "use strict";
    var colorAdjusterFunctions = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
    function getAncestorCounter(path, typeOrTypes) {
      const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];
      let counter = -1;
      let ancestorNode;
      while (ancestorNode = path.getParentNode(++counter)) {
        if (types.includes(ancestorNode.type)) {
          return counter;
        }
      }
      return -1;
    }
    function getAncestorNode(path, typeOrTypes) {
      const counter = getAncestorCounter(path, typeOrTypes);
      return counter === -1 ? null : path.getParentNode(counter);
    }
    function getPropOfDeclNode(path) {
      var _declAncestorNode$pro;
      const declAncestorNode = getAncestorNode(path, "css-decl");
      return declAncestorNode === null || declAncestorNode === void 0 ? void 0 : (_declAncestorNode$pro = declAncestorNode.prop) === null || _declAncestorNode$pro === void 0 ? void 0 : _declAncestorNode$pro.toLowerCase();
    }
    var wideKeywords = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
    function isWideKeywords(value) {
      return wideKeywords.has(value.toLowerCase());
    }
    function isKeyframeAtRuleKeywords(path, value) {
      const atRuleAncestorNode = getAncestorNode(path, "css-atrule");
      return (atRuleAncestorNode === null || atRuleAncestorNode === void 0 ? void 0 : atRuleAncestorNode.name) && atRuleAncestorNode.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(value.toLowerCase());
    }
    function maybeToLowerCase(value) {
      return value.includes("$") || value.includes("@") || value.includes("#") || value.startsWith("%") || value.startsWith("--") || value.startsWith(":--") || value.includes("(") && value.includes(")") ? value : value.toLowerCase();
    }
    function insideValueFunctionNode(path, functionName) {
      var _funcAncestorNode$val;
      const funcAncestorNode = getAncestorNode(path, "value-func");
      return (funcAncestorNode === null || funcAncestorNode === void 0 ? void 0 : (_funcAncestorNode$val = funcAncestorNode.value) === null || _funcAncestorNode$val === void 0 ? void 0 : _funcAncestorNode$val.toLowerCase()) === functionName;
    }
    function insideICSSRuleNode(path) {
      var _ruleAncestorNode$raw;
      const ruleAncestorNode = getAncestorNode(path, "css-rule");
      const selector = ruleAncestorNode === null || ruleAncestorNode === void 0 ? void 0 : (_ruleAncestorNode$raw = ruleAncestorNode.raws) === null || _ruleAncestorNode$raw === void 0 ? void 0 : _ruleAncestorNode$raw.selector;
      return selector && (selector.startsWith(":import") || selector.startsWith(":export"));
    }
    function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {
      const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames) ? atRuleNameOrAtRuleNames : [atRuleNameOrAtRuleNames];
      const atRuleAncestorNode = getAncestorNode(path, "css-atrule");
      return atRuleAncestorNode && atRuleNames.includes(atRuleAncestorNode.name.toLowerCase());
    }
    function insideURLFunctionInImportAtRuleNode(path) {
      const node = path.getValue();
      const atRuleAncestorNode = getAncestorNode(path, "css-atrule");
      return (atRuleAncestorNode === null || atRuleAncestorNode === void 0 ? void 0 : atRuleAncestorNode.name) === "import" && node.groups[0].value === "url" && node.groups.length === 2;
    }
    function isURLFunctionNode(node) {
      return node.type === "value-func" && node.value.toLowerCase() === "url";
    }
    function isLastNode(path, node) {
      var _path$getParentNode;
      const nodes = (_path$getParentNode = path.getParentNode()) === null || _path$getParentNode === void 0 ? void 0 : _path$getParentNode.nodes;
      return nodes && nodes.indexOf(node) === nodes.length - 1;
    }
    function isDetachedRulesetDeclarationNode(node) {
      const {
        selector
      } = node;
      if (!selector) {
        return false;
      }
      return typeof selector === "string" && /^@.+:.*$/.test(selector) || selector.value && /^@.+:.*$/.test(selector.value);
    }
    function isForKeywordNode(node) {
      return node.type === "value-word" && ["from", "through", "end"].includes(node.value);
    }
    function isIfElseKeywordNode(node) {
      return node.type === "value-word" && ["and", "or", "not"].includes(node.value);
    }
    function isEachKeywordNode(node) {
      return node.type === "value-word" && node.value === "in";
    }
    function isMultiplicationNode(node) {
      return node.type === "value-operator" && node.value === "*";
    }
    function isDivisionNode(node) {
      return node.type === "value-operator" && node.value === "/";
    }
    function isAdditionNode(node) {
      return node.type === "value-operator" && node.value === "+";
    }
    function isSubtractionNode(node) {
      return node.type === "value-operator" && node.value === "-";
    }
    function isModuloNode(node) {
      return node.type === "value-operator" && node.value === "%";
    }
    function isMathOperatorNode(node) {
      return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);
    }
    function isEqualityOperatorNode(node) {
      return node.type === "value-word" && ["==", "!="].includes(node.value);
    }
    function isRelationalOperatorNode(node) {
      return node.type === "value-word" && ["<", ">", "<=", ">="].includes(node.value);
    }
    function isSCSSControlDirectiveNode(node) {
      return node.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(node.name);
    }
    function isDetachedRulesetCallNode(node) {
      var _node$raws;
      return ((_node$raws = node.raws) === null || _node$raws === void 0 ? void 0 : _node$raws.params) && /^\(\s*\)$/.test(node.raws.params);
    }
    function isTemplatePlaceholderNode(node) {
      return node.name.startsWith("prettier-placeholder");
    }
    function isTemplatePropNode(node) {
      return node.prop.startsWith("@prettier-placeholder");
    }
    function isPostcssSimpleVarNode(currentNode, nextNode) {
      return currentNode.value === "$$" && currentNode.type === "value-func" && (nextNode === null || nextNode === void 0 ? void 0 : nextNode.type) === "value-word" && !nextNode.raws.before;
    }
    function hasComposesNode(node) {
      var _node$value, _node$value$group;
      return ((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.type) === "value-root" && ((_node$value$group = node.value.group) === null || _node$value$group === void 0 ? void 0 : _node$value$group.type) === "value-value" && node.prop.toLowerCase() === "composes";
    }
    function hasParensAroundNode(node) {
      var _node$value2, _node$value2$group, _node$value2$group$gr;
      return ((_node$value2 = node.value) === null || _node$value2 === void 0 ? void 0 : (_node$value2$group = _node$value2.group) === null || _node$value2$group === void 0 ? void 0 : (_node$value2$group$gr = _node$value2$group.group) === null || _node$value2$group$gr === void 0 ? void 0 : _node$value2$group$gr.type) === "value-paren_group" && node.value.group.group.open !== null && node.value.group.group.close !== null;
    }
    function hasEmptyRawBefore(node) {
      var _node$raws2;
      return ((_node$raws2 = node.raws) === null || _node$raws2 === void 0 ? void 0 : _node$raws2.before) === "";
    }
    function isKeyValuePairNode(node) {
      var _node$groups, _node$groups$;
      return node.type === "value-comma_group" && ((_node$groups = node.groups) === null || _node$groups === void 0 ? void 0 : (_node$groups$ = _node$groups[1]) === null || _node$groups$ === void 0 ? void 0 : _node$groups$.type) === "value-colon";
    }
    function isKeyValuePairInParenGroupNode(node) {
      var _node$groups2;
      return node.type === "value-paren_group" && ((_node$groups2 = node.groups) === null || _node$groups2 === void 0 ? void 0 : _node$groups2[0]) && isKeyValuePairNode(node.groups[0]);
    }
    function isSCSSMapItemNode(path) {
      var _declNode$prop;
      const node = path.getValue();
      if (node.groups.length === 0) {
        return false;
      }
      const parentParentNode = path.getParentNode(1);
      if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {
        return false;
      }
      const declNode = getAncestorNode(path, "css-decl");
      if (declNode !== null && declNode !== void 0 && (_declNode$prop = declNode.prop) !== null && _declNode$prop !== void 0 && _declNode$prop.startsWith("$")) {
        return true;
      }
      if (isKeyValuePairInParenGroupNode(parentParentNode)) {
        return true;
      }
      if (parentParentNode.type === "value-func") {
        return true;
      }
      return false;
    }
    function isInlineValueCommentNode(node) {
      return node.type === "value-comment" && node.inline;
    }
    function isHashNode(node) {
      return node.type === "value-word" && node.value === "#";
    }
    function isLeftCurlyBraceNode(node) {
      return node.type === "value-word" && node.value === "{";
    }
    function isRightCurlyBraceNode(node) {
      return node.type === "value-word" && node.value === "}";
    }
    function isWordNode(node) {
      return ["value-word", "value-atword"].includes(node.type);
    }
    function isColonNode(node) {
      return (node === null || node === void 0 ? void 0 : node.type) === "value-colon";
    }
    function isKeyInValuePairNode(node, parentNode) {
      if (!isKeyValuePairNode(parentNode)) {
        return false;
      }
      const {
        groups
      } = parentNode;
      const index = groups.indexOf(node);
      if (index === -1) {
        return false;
      }
      return isColonNode(groups[index + 1]);
    }
    function isMediaAndSupportsKeywords(node) {
      return node.value && ["not", "and", "or"].includes(node.value.toLowerCase());
    }
    function isColorAdjusterFuncNode(node) {
      if (node.type !== "value-func") {
        return false;
      }
      return colorAdjusterFunctions.has(node.value.toLowerCase());
    }
    function lastLineHasInlineComment(text) {
      return /\/\//.test(text.split(/[\n\r]/).pop());
    }
    function isAtWordPlaceholderNode(node) {
      return (node === null || node === void 0 ? void 0 : node.type) === "value-atword" && node.value.startsWith("prettier-placeholder-");
    }
    function isConfigurationNode(node, parentNode) {
      var _node$open, _node$close;
      if (((_node$open = node.open) === null || _node$open === void 0 ? void 0 : _node$open.value) !== "(" || ((_node$close = node.close) === null || _node$close === void 0 ? void 0 : _node$close.value) !== ")" || node.groups.some((group) => group.type !== "value-comma_group")) {
        return false;
      }
      if (parentNode.type === "value-comma_group") {
        const prevIdx = parentNode.groups.indexOf(node) - 1;
        const maybeWithNode = parentNode.groups[prevIdx];
        if ((maybeWithNode === null || maybeWithNode === void 0 ? void 0 : maybeWithNode.type) === "value-word" && maybeWithNode.value === "with") {
          return true;
        }
      }
      return false;
    }
    function isParenGroupNode(node) {
      var _node$open2, _node$close2;
      return node.type === "value-paren_group" && ((_node$open2 = node.open) === null || _node$open2 === void 0 ? void 0 : _node$open2.value) === "(" && ((_node$close2 = node.close) === null || _node$close2 === void 0 ? void 0 : _node$close2.value) === ")";
    }
    module2.exports = {
      getAncestorCounter,
      getAncestorNode,
      getPropOfDeclNode,
      maybeToLowerCase,
      insideValueFunctionNode,
      insideICSSRuleNode,
      insideAtRuleNode,
      insideURLFunctionInImportAtRuleNode,
      isKeyframeAtRuleKeywords,
      isWideKeywords,
      isLastNode,
      isSCSSControlDirectiveNode,
      isDetachedRulesetDeclarationNode,
      isRelationalOperatorNode,
      isEqualityOperatorNode,
      isMultiplicationNode,
      isDivisionNode,
      isAdditionNode,
      isSubtractionNode,
      isModuloNode,
      isMathOperatorNode,
      isEachKeywordNode,
      isForKeywordNode,
      isURLFunctionNode,
      isIfElseKeywordNode,
      hasComposesNode,
      hasParensAroundNode,
      hasEmptyRawBefore,
      isDetachedRulesetCallNode,
      isTemplatePlaceholderNode,
      isTemplatePropNode,
      isPostcssSimpleVarNode,
      isKeyValuePairNode,
      isKeyValuePairInParenGroupNode,
      isKeyInValuePairNode,
      isSCSSMapItemNode,
      isInlineValueCommentNode,
      isHashNode,
      isLeftCurlyBraceNode,
      isRightCurlyBraceNode,
      isWordNode,
      isColonNode,
      isMediaAndSupportsKeywords,
      isColorAdjusterFuncNode,
      lastLineHasInlineComment,
      isAtWordPlaceholderNode,
      isConfigurationNode,
      isParenGroupNode
    };
  }
});
var require_line_column_to_index = __commonJS2({
  "src/utils/line-column-to-index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(lineColumn, text) {
      let index = 0;
      for (let i = 0; i < lineColumn.line - 1; ++i) {
        index = text.indexOf("\n", index) + 1;
      }
      return index + lineColumn.column;
    };
  }
});
var require_loc2 = __commonJS2({
  "src/language-css/loc.js"(exports2, module2) {
    "use strict";
    var {
      skipEverythingButNewLine
    } = require_skip();
    var getLast = require_get_last();
    var lineColumnToIndex = require_line_column_to_index();
    function calculateLocStart(node, text) {
      if (typeof node.sourceIndex === "number") {
        return node.sourceIndex;
      }
      return node.source ? lineColumnToIndex(node.source.start, text) - 1 : null;
    }
    function calculateLocEnd(node, text) {
      if (node.type === "css-comment" && node.inline) {
        return skipEverythingButNewLine(text, node.source.startOffset);
      }
      const endNode = node.nodes && getLast(node.nodes);
      if (endNode && node.source && !node.source.end) {
        node = endNode;
      }
      if (node.source && node.source.end) {
        return lineColumnToIndex(node.source.end, text);
      }
      return null;
    }
    function calculateLoc(node, text) {
      if (node.source) {
        node.source.startOffset = calculateLocStart(node, text);
        node.source.endOffset = calculateLocEnd(node, text);
      }
      for (const key in node) {
        const child = node[key];
        if (key === "source" || !child || typeof child !== "object") {
          continue;
        }
        if (child.type === "value-root" || child.type === "value-unknown") {
          calculateValueNodeLoc(child, getValueRootOffset(node), child.text || child.value);
        } else {
          calculateLoc(child, text);
        }
      }
    }
    function calculateValueNodeLoc(node, rootOffset, text) {
      if (node.source) {
        node.source.startOffset = calculateLocStart(node, text) + rootOffset;
        node.source.endOffset = calculateLocEnd(node, text) + rootOffset;
      }
      for (const key in node) {
        const child = node[key];
        if (key === "source" || !child || typeof child !== "object") {
          continue;
        }
        calculateValueNodeLoc(child, rootOffset, text);
      }
    }
    function getValueRootOffset(node) {
      let result = node.source.startOffset;
      if (typeof node.prop === "string") {
        result += node.prop.length;
      }
      if (node.type === "css-atrule" && typeof node.name === "string") {
        result += 1 + node.name.length + node.raws.afterName.match(/^\s*:?\s*/)[0].length;
      }
      if (node.type !== "css-atrule" && node.raws && typeof node.raws.between === "string") {
        result += node.raws.between.length;
      }
      return result;
    }
    function replaceQuotesInInlineComments(text) {
      let state = "initial";
      let stateToReturnFromQuotes = "initial";
      let inlineCommentStartIndex;
      let inlineCommentContainsQuotes = false;
      const inlineCommentsToReplace = [];
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        switch (state) {
          case "initial":
            if (c === "'") {
              state = "single-quotes";
              continue;
            }
            if (c === '"') {
              state = "double-quotes";
              continue;
            }
            if ((c === "u" || c === "U") && text.slice(i, i + 4).toLowerCase() === "url(") {
              state = "url";
              i += 3;
              continue;
            }
            if (c === "*" && text[i - 1] === "/") {
              state = "comment-block";
              continue;
            }
            if (c === "/" && text[i - 1] === "/") {
              state = "comment-inline";
              inlineCommentStartIndex = i - 1;
              continue;
            }
            continue;
          case "single-quotes":
            if (c === "'" && text[i - 1] !== "\\") {
              state = stateToReturnFromQuotes;
              stateToReturnFromQuotes = "initial";
            }
            if (c === "\n" || c === "\r") {
              return text;
            }
            continue;
          case "double-quotes":
            if (c === '"' && text[i - 1] !== "\\") {
              state = stateToReturnFromQuotes;
              stateToReturnFromQuotes = "initial";
            }
            if (c === "\n" || c === "\r") {
              return text;
            }
            continue;
          case "url":
            if (c === ")") {
              state = "initial";
            }
            if (c === "\n" || c === "\r") {
              return text;
            }
            if (c === "'") {
              state = "single-quotes";
              stateToReturnFromQuotes = "url";
              continue;
            }
            if (c === '"') {
              state = "double-quotes";
              stateToReturnFromQuotes = "url";
              continue;
            }
            continue;
          case "comment-block":
            if (c === "/" && text[i - 1] === "*") {
              state = "initial";
            }
            continue;
          case "comment-inline":
            if (c === '"' || c === "'" || c === "*") {
              inlineCommentContainsQuotes = true;
            }
            if (c === "\n" || c === "\r") {
              if (inlineCommentContainsQuotes) {
                inlineCommentsToReplace.push([inlineCommentStartIndex, i]);
              }
              state = "initial";
              inlineCommentContainsQuotes = false;
            }
            continue;
        }
      }
      for (const [start, end] of inlineCommentsToReplace) {
        text = text.slice(0, start) + text.slice(start, end).replace(/["'*]/g, " ") + text.slice(end);
      }
      return text;
    }
    function locStart(node) {
      return node.source.startOffset;
    }
    function locEnd(node) {
      return node.source.endOffset;
    }
    module2.exports = {
      locStart,
      locEnd,
      calculateLoc,
      replaceQuotesInInlineComments
    };
  }
});
var require_is_less_parser = __commonJS2({
  "src/language-css/utils/is-less-parser.js"(exports2, module2) {
    "use strict";
    function isLessParser(options) {
      return options.parser === "css" || options.parser === "less";
    }
    module2.exports = isLessParser;
  }
});
var require_is_scss = __commonJS2({
  "src/language-css/utils/is-scss.js"(exports2, module2) {
    "use strict";
    function isSCSS(parser, text) {
      const hasExplicitParserChoice = parser === "less" || parser === "scss";
      const IS_POSSIBLY_SCSS = /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/;
      return hasExplicitParserChoice ? parser === "scss" : IS_POSSIBLY_SCSS.test(text);
    }
    module2.exports = isSCSS;
  }
});
var require_css_units_evaluate = __commonJS2({
  "src/language-css/utils/css-units.evaluate.js"(exports2, module2) {
    module2.exports = {
      em: "em",
      rem: "rem",
      ex: "ex",
      rex: "rex",
      cap: "cap",
      rcap: "rcap",
      ch: "ch",
      rch: "rch",
      ic: "ic",
      ric: "ric",
      lh: "lh",
      rlh: "rlh",
      vw: "vw",
      svw: "svw",
      lvw: "lvw",
      dvw: "dvw",
      vh: "vh",
      svh: "svh",
      lvh: "lvh",
      dvh: "dvh",
      vi: "vi",
      svi: "svi",
      lvi: "lvi",
      dvi: "dvi",
      vb: "vb",
      svb: "svb",
      lvb: "lvb",
      dvb: "dvb",
      vmin: "vmin",
      svmin: "svmin",
      lvmin: "lvmin",
      dvmin: "dvmin",
      vmax: "vmax",
      svmax: "svmax",
      lvmax: "lvmax",
      dvmax: "dvmax",
      cm: "cm",
      mm: "mm",
      q: "Q",
      in: "in",
      pt: "pt",
      pc: "pc",
      px: "px",
      deg: "deg",
      grad: "grad",
      rad: "rad",
      turn: "turn",
      s: "s",
      ms: "ms",
      hz: "Hz",
      khz: "kHz",
      dpi: "dpi",
      dpcm: "dpcm",
      dppx: "dppx",
      x: "x"
    };
  }
});
var require_print_unit = __commonJS2({
  "src/language-css/utils/print-unit.js"(exports2, module2) {
    "use strict";
    var CSS_UNITS = require_css_units_evaluate();
    function printUnit(unit) {
      const lowercased = unit.toLowerCase();
      return Object.prototype.hasOwnProperty.call(CSS_UNITS, lowercased) ? CSS_UNITS[lowercased] : unit;
    }
    module2.exports = printUnit;
  }
});
var require_printer_postcss = __commonJS2({
  "src/language-css/printer-postcss.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    var {
      printNumber,
      printString,
      hasNewline,
      isFrontMatterNode,
      isNextLineEmpty,
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        join,
        line,
        hardline,
        softline,
        group,
        fill,
        indent,
        dedent,
        ifBreak,
        breakParent
      },
      utils: {
        removeLines,
        getDocParts
      }
    } = require("./doc.js");
    var clean = require_clean2();
    var embed = require_embed2();
    var {
      insertPragma
    } = require_pragma2();
    var {
      getAncestorNode,
      getPropOfDeclNode,
      maybeToLowerCase,
      insideValueFunctionNode,
      insideICSSRuleNode,
      insideAtRuleNode,
      insideURLFunctionInImportAtRuleNode,
      isKeyframeAtRuleKeywords,
      isWideKeywords,
      isLastNode,
      isSCSSControlDirectiveNode,
      isDetachedRulesetDeclarationNode,
      isRelationalOperatorNode,
      isEqualityOperatorNode,
      isMultiplicationNode,
      isDivisionNode,
      isAdditionNode,
      isSubtractionNode,
      isMathOperatorNode,
      isEachKeywordNode,
      isForKeywordNode,
      isURLFunctionNode,
      isIfElseKeywordNode,
      hasComposesNode,
      hasParensAroundNode,
      hasEmptyRawBefore,
      isKeyValuePairNode,
      isKeyInValuePairNode,
      isDetachedRulesetCallNode,
      isTemplatePlaceholderNode,
      isTemplatePropNode,
      isPostcssSimpleVarNode,
      isSCSSMapItemNode,
      isInlineValueCommentNode,
      isHashNode,
      isLeftCurlyBraceNode,
      isRightCurlyBraceNode,
      isWordNode,
      isColonNode,
      isMediaAndSupportsKeywords,
      isColorAdjusterFuncNode,
      lastLineHasInlineComment,
      isAtWordPlaceholderNode,
      isConfigurationNode,
      isParenGroupNode
    } = require_utils8();
    var {
      locStart,
      locEnd
    } = require_loc2();
    var isLessParser = require_is_less_parser();
    var isSCSS = require_is_scss();
    var printUnit = require_print_unit();
    function shouldPrintComma(options) {
      return options.trailingComma === "es5" || options.trailingComma === "all";
    }
    function genericPrint(path, options, print) {
      const node = path.getValue();
      if (!node) {
        return "";
      }
      if (typeof node === "string") {
        return node;
      }
      switch (node.type) {
        case "front-matter":
          return [node.raw, hardline];
        case "css-root": {
          const nodes = printNodeSequence(path, options, print);
          let after = node.raws.after.trim();
          if (after.startsWith(";")) {
            after = after.slice(1).trim();
          }
          return [nodes, after ? ` ${after}` : "", getDocParts(nodes).length > 0 ? hardline : ""];
        }
        case "css-comment": {
          const isInlineComment = node.inline || node.raws.inline;
          const text = options.originalText.slice(locStart(node), locEnd(node));
          return isInlineComment ? text.trimEnd() : text;
        }
        case "css-rule": {
          return [print("selector"), node.important ? " !important" : "", node.nodes ? [node.selector && node.selector.type === "selector-unknown" && lastLineHasInlineComment(node.selector.value) ? line : " ", "{", node.nodes.length > 0 ? indent([hardline, printNodeSequence(path, options, print)]) : "", hardline, "}", isDetachedRulesetDeclarationNode(node) ? ";" : ""] : ";"];
        }
        case "css-decl": {
          const parentNode = path.getParentNode();
          const {
            between: rawBetween
          } = node.raws;
          const trimmedBetween = rawBetween.trim();
          const isColon = trimmedBetween === ":";
          let value = hasComposesNode(node) ? removeLines(print("value")) : print("value");
          if (!isColon && lastLineHasInlineComment(trimmedBetween)) {
            value = indent([hardline, dedent(value)]);
          }
          return [node.raws.before.replace(/[\s;]/g, ""), parentNode.type === "css-atrule" && parentNode.variable || insideICSSRuleNode(path) ? node.prop : maybeToLowerCase(node.prop), trimmedBetween.startsWith("//") ? " " : "", trimmedBetween, node.extend ? "" : " ", isLessParser(options) && node.extend && node.selector ? ["extend(", print("selector"), ")"] : "", value, node.raws.important ? node.raws.important.replace(/\s*!\s*important/i, " !important") : node.important ? " !important" : "", node.raws.scssDefault ? node.raws.scssDefault.replace(/\s*!default/i, " !default") : node.scssDefault ? " !default" : "", node.raws.scssGlobal ? node.raws.scssGlobal.replace(/\s*!global/i, " !global") : node.scssGlobal ? " !global" : "", node.nodes ? [" {", indent([softline, printNodeSequence(path, options, print)]), softline, "}"] : isTemplatePropNode(node) && !parentNode.raws.semicolon && options.originalText[locEnd(node) - 1] !== ";" ? "" : options.__isHTMLStyleAttribute && isLastNode(path, node) ? ifBreak(";") : ";"];
        }
        case "css-atrule": {
          const parentNode = path.getParentNode();
          const isTemplatePlaceholderNodeWithoutSemiColon = isTemplatePlaceholderNode(node) && !parentNode.raws.semicolon && options.originalText[locEnd(node) - 1] !== ";";
          if (isLessParser(options)) {
            if (node.mixin) {
              return [print("selector"), node.important ? " !important" : "", isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
            }
            if (node.function) {
              return [node.name, print("params"), isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
            }
            if (node.variable) {
              return ["@", node.name, ": ", node.value ? print("value") : "", node.raws.between.trim() ? node.raws.between.trim() + " " : "", node.nodes ? ["{", indent([node.nodes.length > 0 ? softline : "", printNodeSequence(path, options, print)]), softline, "}"] : "", isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
            }
          }
          return ["@", isDetachedRulesetCallNode(node) || node.name.endsWith(":") ? node.name : maybeToLowerCase(node.name), node.params ? [isDetachedRulesetCallNode(node) ? "" : isTemplatePlaceholderNode(node) ? node.raws.afterName === "" ? "" : node.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(node.raws.afterName) ? [hardline, hardline] : /^\s*\n/.test(node.raws.afterName) ? hardline : " " : " ", print("params")] : "", node.selector ? indent([" ", print("selector")]) : "", node.value ? group([" ", print("value"), isSCSSControlDirectiveNode(node) ? hasParensAroundNode(node) ? " " : line : ""]) : node.name === "else" ? " " : "", node.nodes ? [isSCSSControlDirectiveNode(node) ? "" : node.selector && !node.selector.nodes && typeof node.selector.value === "string" && lastLineHasInlineComment(node.selector.value) || !node.selector && typeof node.params === "string" && lastLineHasInlineComment(node.params) ? line : " ", "{", indent([node.nodes.length > 0 ? softline : "", printNodeSequence(path, options, print)]), softline, "}"] : isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];
        }
        case "media-query-list": {
          const parts = [];
          path.each((childPath) => {
            const node2 = childPath.getValue();
            if (node2.type === "media-query" && node2.value === "") {
              return;
            }
            parts.push(print());
          }, "nodes");
          return group(indent(join(line, parts)));
        }
        case "media-query": {
          return [join(" ", path.map(print, "nodes")), isLastNode(path, node) ? "" : ","];
        }
        case "media-type": {
          return adjustNumbers(adjustStrings(node.value, options));
        }
        case "media-feature-expression": {
          if (!node.nodes) {
            return node.value;
          }
          return ["(", ...path.map(print, "nodes"), ")"];
        }
        case "media-feature": {
          return maybeToLowerCase(adjustStrings(node.value.replace(/ +/g, " "), options));
        }
        case "media-colon": {
          return [node.value, " "];
        }
        case "media-value": {
          return adjustNumbers(adjustStrings(node.value, options));
        }
        case "media-keyword": {
          return adjustStrings(node.value, options);
        }
        case "media-url": {
          return adjustStrings(node.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), options);
        }
        case "media-unknown": {
          return node.value;
        }
        case "selector-root": {
          return group([insideAtRuleNode(path, "custom-selector") ? [getAncestorNode(path, "css-atrule").customSelector, line] : "", join([",", insideAtRuleNode(path, ["extend", "custom-selector", "nest"]) ? line : hardline], path.map(print, "nodes"))]);
        }
        case "selector-selector": {
          return group(indent(path.map(print, "nodes")));
        }
        case "selector-comment": {
          return node.value;
        }
        case "selector-string": {
          return adjustStrings(node.value, options);
        }
        case "selector-tag": {
          const parentNode = path.getParentNode();
          const index = parentNode && parentNode.nodes.indexOf(node);
          const prevNode = index && parentNode.nodes[index - 1];
          return [node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", prevNode.type === "selector-nesting" ? node.value : adjustNumbers(isKeyframeAtRuleKeywords(path, node.value) ? node.value.toLowerCase() : node.value)];
        }
        case "selector-id": {
          return ["#", node.value];
        }
        case "selector-class": {
          return [".", adjustNumbers(adjustStrings(node.value, options))];
        }
        case "selector-attribute": {
          var _node$operator;
          return ["[", node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", node.attribute.trim(), (_node$operator = node.operator) !== null && _node$operator !== void 0 ? _node$operator : "", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options), options) : "", node.insensitive ? " i" : "", "]"];
        }
        case "selector-combinator": {
          if (node.value === "+" || node.value === ">" || node.value === "~" || node.value === ">>>") {
            const parentNode = path.getParentNode();
            const leading2 = parentNode.type === "selector-selector" && parentNode.nodes[0] === node ? "" : line;
            return [leading2, node.value, isLastNode(path, node) ? "" : " "];
          }
          const leading = node.value.trim().startsWith("(") ? line : "";
          const value = adjustNumbers(adjustStrings(node.value.trim(), options)) || line;
          return [leading, value];
        }
        case "selector-universal": {
          return [node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", node.value];
        }
        case "selector-pseudo": {
          return [maybeToLowerCase(node.value), isNonEmptyArray(node.nodes) ? group(["(", indent([softline, join([",", line], path.map(print, "nodes"))]), softline, ")"]) : ""];
        }
        case "selector-nesting": {
          return node.value;
        }
        case "selector-unknown": {
          const ruleAncestorNode = getAncestorNode(path, "css-rule");
          if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {
            return adjustNumbers(adjustStrings(maybeToLowerCase(node.value), options));
          }
          const parentNode = path.getParentNode();
          if (parentNode.raws && parentNode.raws.selector) {
            const start = locStart(parentNode);
            const end = start + parentNode.raws.selector.length;
            return options.originalText.slice(start, end).trim();
          }
          const grandParent = path.getParentNode(1);
          if (parentNode.type === "value-paren_group" && grandParent && grandParent.type === "value-func" && grandParent.value === "selector") {
            const start = locEnd(parentNode.open) + 1;
            const end = locStart(parentNode.close);
            const selector = options.originalText.slice(start, end).trim();
            return lastLineHasInlineComment(selector) ? [breakParent, selector] : selector;
          }
          return node.value;
        }
        case "value-value":
        case "value-root": {
          return print("group");
        }
        case "value-comment": {
          return options.originalText.slice(locStart(node), locEnd(node));
        }
        case "value-comma_group": {
          const parentNode = path.getParentNode();
          const parentParentNode = path.getParentNode(1);
          const declAncestorProp = getPropOfDeclNode(path);
          const isGridValue = declAncestorProp && parentNode.type === "value-value" && (declAncestorProp === "grid" || declAncestorProp.startsWith("grid-template"));
          const atRuleAncestorNode = getAncestorNode(path, "css-atrule");
          const isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode(atRuleAncestorNode);
          const hasInlineComment = node.groups.some((node2) => isInlineValueCommentNode(node2));
          const printed = path.map(print, "groups");
          const parts = [];
          const insideURLFunction = insideValueFunctionNode(path, "url");
          let insideSCSSInterpolationInString = false;
          let didBreak = false;
          for (let i = 0; i < node.groups.length; ++i) {
            var _iNode$value;
            parts.push(printed[i]);
            const iPrevNode = node.groups[i - 1];
            const iNode = node.groups[i];
            const iNextNode = node.groups[i + 1];
            const iNextNextNode = node.groups[i + 2];
            if (insideURLFunction) {
              if (iNextNode && isAdditionNode(iNextNode) || isAdditionNode(iNode)) {
                parts.push(" ");
              }
              continue;
            }
            if (insideAtRuleNode(path, "forward") && iNode.type === "value-word" && iNode.value && iPrevNode !== void 0 && iPrevNode.type === "value-word" && iPrevNode.value === "as" && iNextNode.type === "value-operator" && iNextNode.value === "*") {
              continue;
            }
            if (!iNextNode) {
              continue;
            }
            if (iNode.type === "value-word" && iNode.value.endsWith("-") && isAtWordPlaceholderNode(iNextNode)) {
              continue;
            }
            if (iNode.type === "value-string" && iNode.quoted) {
              const positionOfOpeningInterpolation = iNode.value.lastIndexOf("#{");
              const positionOfClosingInterpolation = iNode.value.lastIndexOf("}");
              if (positionOfOpeningInterpolation !== -1 && positionOfClosingInterpolation !== -1) {
                insideSCSSInterpolationInString = positionOfOpeningInterpolation > positionOfClosingInterpolation;
              } else if (positionOfOpeningInterpolation !== -1) {
                insideSCSSInterpolationInString = true;
              } else if (positionOfClosingInterpolation !== -1) {
                insideSCSSInterpolationInString = false;
              }
            }
            if (insideSCSSInterpolationInString) {
              continue;
            }
            if (isColonNode(iNode) || isColonNode(iNextNode)) {
              continue;
            }
            if (iNode.type === "value-atword" && (iNode.value === "" || iNode.value.endsWith("["))) {
              continue;
            }
            if (iNextNode.type === "value-word" && iNextNode.value.startsWith("]")) {
              continue;
            }
            if (iNode.value === "~") {
              continue;
            }
            if (iNode.value && iNode.value.includes("\\") && iNextNode && iNextNode.type !== "value-comment") {
              continue;
            }
            if (iPrevNode && iPrevNode.value && iPrevNode.value.indexOf("\\") === iPrevNode.value.length - 1 && iNode.type === "value-operator" && iNode.value === "/") {
              continue;
            }
            if (iNode.value === "\\") {
              continue;
            }
            if (isPostcssSimpleVarNode(iNode, iNextNode)) {
              continue;
            }
            if (isHashNode(iNode) || isLeftCurlyBraceNode(iNode) || isRightCurlyBraceNode(iNextNode) || isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode) || isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode)) {
              continue;
            }
            if (iNode.value === "--" && isHashNode(iNextNode)) {
              continue;
            }
            const isMathOperator = isMathOperatorNode(iNode);
            const isNextMathOperator = isMathOperatorNode(iNextNode);
            if ((isMathOperator && isHashNode(iNextNode) || isNextMathOperator && isRightCurlyBraceNode(iNode)) && hasEmptyRawBefore(iNextNode)) {
              continue;
            }
            if (!iPrevNode && isDivisionNode(iNode)) {
              continue;
            }
            if (insideValueFunctionNode(path, "calc") && (isAdditionNode(iNode) || isAdditionNode(iNextNode) || isSubtractionNode(iNode) || isSubtractionNode(iNextNode)) && hasEmptyRawBefore(iNextNode)) {
              continue;
            }
            const isColorAdjusterNode = (isAdditionNode(iNode) || isSubtractionNode(iNode)) && i === 0 && (iNextNode.type === "value-number" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode(parentParentNode) && !hasEmptyRawBefore(iNextNode);
            const requireSpaceBeforeOperator = iNextNextNode && iNextNextNode.type === "value-func" || iNextNextNode && isWordNode(iNextNextNode) || iNode.type === "value-func" || isWordNode(iNode);
            const requireSpaceAfterOperator = iNextNode.type === "value-func" || isWordNode(iNextNode) || iPrevNode && iPrevNode.type === "value-func" || iPrevNode && isWordNode(iPrevNode);
            if (!(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) && !insideValueFunctionNode(path, "calc") && !isColorAdjusterNode && (isDivisionNode(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode(iNode) && !requireSpaceAfterOperator || isAdditionNode(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode(iNode) && !requireSpaceAfterOperator || isSubtractionNode(iNextNode) || isSubtractionNode(iNode)) && (hasEmptyRawBefore(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode(iPrevNode)))) {
              continue;
            }
            if ((options.parser === "scss" || options.parser === "less") && isMathOperator && iNode.value === "-" && isParenGroupNode(iNextNode) && locEnd(iNode) === locStart(iNextNode.open) && iNextNode.open.value === "(") {
              continue;
            }
            if (isInlineValueCommentNode(iNode)) {
              if (parentNode.type === "value-paren_group") {
                parts.push(dedent(hardline));
                continue;
              }
              parts.push(hardline);
              continue;
            }
            if (isControlDirective && (isEqualityOperatorNode(iNextNode) || isRelationalOperatorNode(iNextNode) || isIfElseKeywordNode(iNextNode) || isEachKeywordNode(iNode) || isForKeywordNode(iNode))) {
              parts.push(" ");
              continue;
            }
            if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === "namespace") {
              parts.push(" ");
              continue;
            }
            if (isGridValue) {
              if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {
                parts.push(hardline);
                didBreak = true;
              } else {
                parts.push(" ");
              }
              continue;
            }
            if (isNextMathOperator) {
              parts.push(" ");
              continue;
            }
            if (iNextNode && iNextNode.value === "...") {
              continue;
            }
            if (isAtWordPlaceholderNode(iNode) && isAtWordPlaceholderNode(iNextNode) && locEnd(iNode) === locStart(iNextNode)) {
              continue;
            }
            if (isAtWordPlaceholderNode(iNode) && isParenGroupNode(iNextNode) && locEnd(iNode) === locStart(iNextNode.open)) {
              parts.push(softline);
              continue;
            }
            if (iNode.value === "with" && isParenGroupNode(iNextNode)) {
              parts.push(" ");
              continue;
            }
            if ((_iNode$value = iNode.value) !== null && _iNode$value !== void 0 && _iNode$value.endsWith("#") && iNextNode.value === "{" && isParenGroupNode(iNextNode.group)) {
              continue;
            }
            parts.push(line);
          }
          if (hasInlineComment) {
            parts.push(breakParent);
          }
          if (didBreak) {
            parts.unshift(hardline);
          }
          if (isControlDirective) {
            return group(indent(parts));
          }
          if (insideURLFunctionInImportAtRuleNode(path)) {
            return group(fill(parts));
          }
          return group(indent(fill(parts)));
        }
        case "value-paren_group": {
          const parentNode = path.getParentNode();
          if (parentNode && isURLFunctionNode(parentNode) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === "value-comma_group" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === "value-word" && node.groups[0].groups[0].value.startsWith("data:"))) {
            return [node.open ? print("open") : "", join(",", path.map(print, "groups")), node.close ? print("close") : ""];
          }
          if (!node.open) {
            const printed2 = path.map(print, "groups");
            const res = [];
            for (let i = 0; i < printed2.length; i++) {
              if (i !== 0) {
                res.push([",", line]);
              }
              res.push(printed2[i]);
            }
            return group(indent(fill(res)));
          }
          const isSCSSMapItem = isSCSSMapItemNode(path);
          const lastItem = getLast(node.groups);
          const isLastItemComment = lastItem && lastItem.type === "value-comment";
          const isKey = isKeyInValuePairNode(node, parentNode);
          const isConfiguration = isConfigurationNode(node, parentNode);
          const shouldBreak = isConfiguration || isSCSSMapItem && !isKey;
          const shouldDedent = isConfiguration || isKey;
          const printed = group([node.open ? print("open") : "", indent([softline, join([line], path.map((childPath, index) => {
            const child = childPath.getValue();
            const isLast = index === node.groups.length - 1;
            let printed2 = [print(), isLast ? "" : ","];
            if (isKeyValuePairNode(child) && child.type === "value-comma_group" && child.groups && child.groups[0].type !== "value-paren_group" && child.groups[2] && child.groups[2].type === "value-paren_group") {
              const parts = getDocParts(printed2[0].contents.contents);
              parts[1] = group(parts[1]);
              printed2 = [group(dedent(printed2))];
            }
            if (!isLast && child.type === "value-comma_group" && isNonEmptyArray(child.groups)) {
              let last = getLast(child.groups);
              if (!last.source && last.close) {
                last = last.close;
              }
              if (last.source && isNextLineEmpty(options.originalText, last, locEnd)) {
                printed2.push(hardline);
              }
            }
            return printed2;
          }, "groups"))]), ifBreak(!isLastItemComment && isSCSS(options.parser, options.originalText) && isSCSSMapItem && shouldPrintComma(options) ? "," : ""), softline, node.close ? print("close") : ""], {
            shouldBreak
          });
          return shouldDedent ? dedent(printed) : printed;
        }
        case "value-func": {
          return [node.value, insideAtRuleNode(path, "supports") && isMediaAndSupportsKeywords(node) ? " " : "", print("group")];
        }
        case "value-paren": {
          return node.value;
        }
        case "value-number": {
          return [printCssNumber(node.value), printUnit(node.unit)];
        }
        case "value-operator": {
          return node.value;
        }
        case "value-word": {
          if (node.isColor && node.isHex || isWideKeywords(node.value)) {
            return node.value.toLowerCase();
          }
          return node.value;
        }
        case "value-colon": {
          const parentNode = path.getParentNode();
          const index = parentNode && parentNode.groups.indexOf(node);
          const prevNode = index && parentNode.groups[index - 1];
          return [node.value, prevNode && typeof prevNode.value === "string" && getLast(prevNode.value) === "\\" || insideValueFunctionNode(path, "url") ? "" : line];
        }
        case "value-comma": {
          return [node.value, " "];
        }
        case "value-string": {
          return printString(node.raws.quote + node.value + node.raws.quote, options);
        }
        case "value-atword": {
          return ["@", node.value];
        }
        case "value-unicode-range": {
          return node.value;
        }
        case "value-unknown": {
          return node.value;
        }
        default:
          throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);
      }
    }
    function printNodeSequence(path, options, print) {
      const parts = [];
      path.each((pathChild, i, nodes) => {
        const prevNode = nodes[i - 1];
        if (prevNode && prevNode.type === "css-comment" && prevNode.text.trim() === "prettier-ignore") {
          const childNode = pathChild.getValue();
          parts.push(options.originalText.slice(locStart(childNode), locEnd(childNode)));
        } else {
          parts.push(print());
        }
        if (i !== nodes.length - 1) {
          if (nodes[i + 1].type === "css-comment" && !hasNewline(options.originalText, locStart(nodes[i + 1]), {
            backwards: true
          }) && !isFrontMatterNode(nodes[i]) || nodes[i + 1].type === "css-atrule" && nodes[i + 1].name === "else" && nodes[i].type !== "css-comment") {
            parts.push(" ");
          } else {
            parts.push(options.__isHTMLStyleAttribute ? line : hardline);
            if (isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd) && !isFrontMatterNode(nodes[i])) {
              parts.push(hardline);
            }
          }
        }
      }, "nodes");
      return parts;
    }
    var STRING_REGEX = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs;
    var NUMBER_REGEX = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g;
    var STANDARD_UNIT_REGEX = /[A-Za-z]+/g;
    var WORD_PART_REGEX = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g;
    var ADJUST_NUMBERS_REGEX = new RegExp(STRING_REGEX.source + `|(${WORD_PART_REGEX.source})?(${NUMBER_REGEX.source})(${STANDARD_UNIT_REGEX.source})?`, "g");
    function adjustStrings(value, options) {
      return value.replace(STRING_REGEX, (match) => printString(match, options));
    }
    function quoteAttributeValue(value, options) {
      const quote = options.singleQuote ? "'" : '"';
      return value.includes('"') || value.includes("'") ? value : quote + value + quote;
    }
    function adjustNumbers(value) {
      return value.replace(ADJUST_NUMBERS_REGEX, (match, quote, wordPart, number, unit) => !wordPart && number ? printCssNumber(number) + maybeToLowerCase(unit || "") : match);
    }
    function printCssNumber(rawNumber) {
      return printNumber(rawNumber).replace(/\.0(?=$|e)/, "");
    }
    module2.exports = {
      print: genericPrint,
      embed,
      insertPragma,
      massageAstNode: clean
    };
  }
});
var require_options3 = __commonJS2({
  "src/language-css/options.js"(exports2, module2) {
    "use strict";
    var commonOptions = require_common_options();
    module2.exports = {
      singleQuote: commonOptions.singleQuote
    };
  }
});
var require_parsers2 = __commonJS2({
  "src/language-css/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get css() {
        return require("./parser-postcss.js").parsers.css;
      },
      get less() {
        return require("./parser-postcss.js").parsers.less;
      },
      get scss() {
        return require("./parser-postcss.js").parsers.scss;
      }
    };
  }
});
var require_CSS = __commonJS2({
  "node_modules/linguist-languages/data/CSS.json"(exports2, module2) {
    module2.exports = {
      name: "CSS",
      type: "markup",
      tmScope: "source.css",
      aceMode: "css",
      codemirrorMode: "css",
      codemirrorMimeType: "text/css",
      color: "#563d7c",
      extensions: [".css"],
      languageId: 50
    };
  }
});
var require_PostCSS = __commonJS2({
  "node_modules/linguist-languages/data/PostCSS.json"(exports2, module2) {
    module2.exports = {
      name: "PostCSS",
      type: "markup",
      color: "#dc3a0c",
      tmScope: "source.postcss",
      group: "CSS",
      extensions: [".pcss", ".postcss"],
      aceMode: "text",
      languageId: 262764437
    };
  }
});
var require_Less = __commonJS2({
  "node_modules/linguist-languages/data/Less.json"(exports2, module2) {
    module2.exports = {
      name: "Less",
      type: "markup",
      color: "#1d365d",
      aliases: ["less-css"],
      extensions: [".less"],
      tmScope: "source.css.less",
      aceMode: "less",
      codemirrorMode: "css",
      codemirrorMimeType: "text/css",
      languageId: 198
    };
  }
});
var require_SCSS = __commonJS2({
  "node_modules/linguist-languages/data/SCSS.json"(exports2, module2) {
    module2.exports = {
      name: "SCSS",
      type: "markup",
      color: "#c6538c",
      tmScope: "source.css.scss",
      aceMode: "scss",
      codemirrorMode: "css",
      codemirrorMimeType: "text/x-scss",
      extensions: [".scss"],
      languageId: 329
    };
  }
});
var require_language_css = __commonJS2({
  "src/language-css/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var printer = require_printer_postcss();
    var options = require_options3();
    var parsers = require_parsers2();
    var languages = [createLanguage(require_CSS(), (data) => ({
      since: "1.4.0",
      parsers: ["css"],
      vscodeLanguageIds: ["css"],
      extensions: [...data.extensions, ".wxss"]
    })), createLanguage(require_PostCSS(), () => ({
      since: "1.4.0",
      parsers: ["css"],
      vscodeLanguageIds: ["postcss"]
    })), createLanguage(require_Less(), () => ({
      since: "1.4.0",
      parsers: ["less"],
      vscodeLanguageIds: ["less"]
    })), createLanguage(require_SCSS(), () => ({
      since: "1.4.0",
      parsers: ["scss"],
      vscodeLanguageIds: ["scss"]
    }))];
    var printers = {
      postcss: printer
    };
    module2.exports = {
      languages,
      options,
      printers,
      parsers
    };
  }
});
var require_loc3 = __commonJS2({
  "src/language-handlebars/loc.js"(exports2, module2) {
    "use strict";
    function locStart(node) {
      return node.loc.start.offset;
    }
    function locEnd(node) {
      return node.loc.end.offset;
    }
    module2.exports = {
      locStart,
      locEnd
    };
  }
});
var require_clean3 = __commonJS2({
  "src/language-handlebars/clean.js"(exports2, module2) {
    "use strict";
    function clean(ast, newNode) {
      if (ast.type === "TextNode") {
        const trimmed = ast.chars.trim();
        if (!trimmed) {
          return null;
        }
        newNode.chars = trimmed.replace(/[\t\n\f\r ]+/g, " ");
      }
      if (ast.type === "AttrNode" && ast.name.toLowerCase() === "class") {
        delete newNode.value;
      }
    }
    clean.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]);
    module2.exports = clean;
  }
});
var require_html_void_elements_evaluate = __commonJS2({
  "src/language-handlebars/html-void-elements.evaluate.js"(exports2, module2) {
    module2.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
  }
});
var require_utils9 = __commonJS2({
  "src/language-handlebars/utils.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    var htmlVoidElements = require_html_void_elements_evaluate();
    function isLastNodeOfSiblings(path) {
      const node = path.getValue();
      const parentNode = path.getParentNode(0);
      if (isParentOfSomeType(path, ["ElementNode"]) && getLast(parentNode.children) === node) {
        return true;
      }
      if (isParentOfSomeType(path, ["Block"]) && getLast(parentNode.body) === node) {
        return true;
      }
      return false;
    }
    function isUppercase(string) {
      return string.toUpperCase() === string;
    }
    function isGlimmerComponent(node) {
      return isNodeOfSomeType(node, ["ElementNode"]) && typeof node.tag === "string" && !node.tag.startsWith(":") && (isUppercase(node.tag[0]) || node.tag.includes("."));
    }
    var voidTags = new Set(htmlVoidElements);
    function isVoidTag(tag) {
      return voidTags.has(tag.toLowerCase()) && !isUppercase(tag[0]);
    }
    function isVoid(node) {
      return node.selfClosing === true || isVoidTag(node.tag) || isGlimmerComponent(node) && node.children.every((node2) => isWhitespaceNode(node2));
    }
    function isWhitespaceNode(node) {
      return isNodeOfSomeType(node, ["TextNode"]) && !/\S/.test(node.chars);
    }
    function isNodeOfSomeType(node, types) {
      return node && types.includes(node.type);
    }
    function isParentOfSomeType(path, types) {
      const parentNode = path.getParentNode(0);
      return isNodeOfSomeType(parentNode, types);
    }
    function isPreviousNodeOfSomeType(path, types) {
      const previousNode = getPreviousNode(path);
      return isNodeOfSomeType(previousNode, types);
    }
    function isNextNodeOfSomeType(path, types) {
      const nextNode = getNextNode(path);
      return isNodeOfSomeType(nextNode, types);
    }
    function getSiblingNode(path, offset) {
      var _path$getParentNode2, _ref7, _ref8, _parentNode$children;
      const node = path.getValue();
      const parentNode = (_path$getParentNode2 = path.getParentNode(0)) !== null && _path$getParentNode2 !== void 0 ? _path$getParentNode2 : {};
      const children = (_ref7 = (_ref8 = (_parentNode$children = parentNode.children) !== null && _parentNode$children !== void 0 ? _parentNode$children : parentNode.body) !== null && _ref8 !== void 0 ? _ref8 : parentNode.parts) !== null && _ref7 !== void 0 ? _ref7 : [];
      const index = children.indexOf(node);
      return index !== -1 && children[index + offset];
    }
    function getPreviousNode(path, lookBack = 1) {
      return getSiblingNode(path, -lookBack);
    }
    function getNextNode(path) {
      return getSiblingNode(path, 1);
    }
    function isPrettierIgnoreNode(node) {
      return isNodeOfSomeType(node, ["MustacheCommentStatement"]) && typeof node.value === "string" && node.value.trim() === "prettier-ignore";
    }
    function hasPrettierIgnore(path) {
      const node = path.getValue();
      const previousPreviousNode = getPreviousNode(path, 2);
      return isPrettierIgnoreNode(node) || isPrettierIgnoreNode(previousPreviousNode);
    }
    module2.exports = {
      getNextNode,
      getPreviousNode,
      hasPrettierIgnore,
      isLastNodeOfSiblings,
      isNextNodeOfSomeType,
      isNodeOfSomeType,
      isParentOfSomeType,
      isPreviousNodeOfSomeType,
      isVoid,
      isWhitespaceNode
    };
  }
});
var require_printer_glimmer = __commonJS2({
  "src/language-handlebars/printer-glimmer.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        dedent,
        fill,
        group,
        hardline,
        ifBreak,
        indent,
        join,
        line,
        softline
      },
      utils: {
        getDocParts,
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var {
      getPreferredQuote,
      isNonEmptyArray
    } = require_util();
    var {
      locStart,
      locEnd
    } = require_loc3();
    var clean = require_clean3();
    var {
      getNextNode,
      getPreviousNode,
      hasPrettierIgnore,
      isLastNodeOfSiblings,
      isNextNodeOfSomeType,
      isNodeOfSomeType,
      isParentOfSomeType,
      isPreviousNodeOfSomeType,
      isVoid,
      isWhitespaceNode
    } = require_utils9();
    var NEWLINES_TO_PRESERVE_MAX = 2;
    function print(path, options, print2) {
      const node = path.getValue();
      if (!node) {
        return "";
      }
      if (hasPrettierIgnore(path)) {
        return options.originalText.slice(locStart(node), locEnd(node));
      }
      const favoriteQuote = options.singleQuote ? "'" : '"';
      switch (node.type) {
        case "Block":
        case "Program":
        case "Template": {
          return group(path.map(print2, "body"));
        }
        case "ElementNode": {
          const startingTag = group(printStartingTag(path, print2));
          const escapeNextElementNode = options.htmlWhitespaceSensitivity === "ignore" && isNextNodeOfSomeType(path, ["ElementNode"]) ? softline : "";
          if (isVoid(node)) {
            return [startingTag, escapeNextElementNode];
          }
          const endingTag = ["</", node.tag, ">"];
          if (node.children.length === 0) {
            return [startingTag, indent(endingTag), escapeNextElementNode];
          }
          if (options.htmlWhitespaceSensitivity === "ignore") {
            return [startingTag, indent(printChildren(path, options, print2)), hardline, indent(endingTag), escapeNextElementNode];
          }
          return [startingTag, indent(group(printChildren(path, options, print2))), indent(endingTag), escapeNextElementNode];
        }
        case "BlockStatement": {
          const pp = path.getParentNode(1);
          const isElseIfLike = pp && pp.inverse && pp.inverse.body.length === 1 && pp.inverse.body[0] === node && pp.inverse.body[0].path.parts[0] === pp.path.parts[0];
          if (isElseIfLike) {
            return [printElseIfLikeBlock(path, print2, pp.inverse.body[0].path.parts[0]), printProgram(path, print2, options), printInverse(path, print2, options)];
          }
          return [printOpenBlock(path, print2), group([printProgram(path, print2, options), printInverse(path, print2, options), printCloseBlock(path, print2, options)])];
        }
        case "ElementModifierStatement": {
          return group(["{{", printPathAndParams(path, print2), "}}"]);
        }
        case "MustacheStatement": {
          return group([printOpeningMustache(node), printPathAndParams(path, print2), printClosingMustache(node)]);
        }
        case "SubExpression": {
          return group(["(", printSubExpressionPathAndParams(path, print2), softline, ")"]);
        }
        case "AttrNode": {
          const isText = node.value.type === "TextNode";
          const isEmptyText = isText && node.value.chars === "";
          if (isEmptyText && locStart(node.value) === locEnd(node.value)) {
            return node.name;
          }
          const quote = isText ? getPreferredQuote(node.value.chars, favoriteQuote).quote : node.value.type === "ConcatStatement" ? getPreferredQuote(node.value.parts.filter((part) => part.type === "TextNode").map((part) => part.chars).join(""), favoriteQuote).quote : "";
          const valueDoc = print2("value");
          return [node.name, "=", quote, node.name === "class" && quote ? group(indent(valueDoc)) : valueDoc, quote];
        }
        case "ConcatStatement": {
          return path.map(print2, "parts");
        }
        case "Hash": {
          return join(line, path.map(print2, "pairs"));
        }
        case "HashPair": {
          return [node.key, "=", print2("value")];
        }
        case "TextNode": {
          let text = node.chars.replace(/{{/g, "\\{{");
          const attrName = getCurrentAttributeName(path);
          if (attrName) {
            if (attrName === "class") {
              const formattedClasses = text.trim().split(/\s+/).join(" ");
              let leadingSpace2 = false;
              let trailingSpace2 = false;
              if (isParentOfSomeType(path, ["ConcatStatement"])) {
                if (isPreviousNodeOfSomeType(path, ["MustacheStatement"]) && /^\s/.test(text)) {
                  leadingSpace2 = true;
                }
                if (isNextNodeOfSomeType(path, ["MustacheStatement"]) && /\s$/.test(text) && formattedClasses !== "") {
                  trailingSpace2 = true;
                }
              }
              return [leadingSpace2 ? line : "", formattedClasses, trailingSpace2 ? line : ""];
            }
            return replaceTextEndOfLine(text);
          }
          const whitespacesOnlyRE = /^[\t\n\f\r ]*$/;
          const isWhitespaceOnly = whitespacesOnlyRE.test(text);
          const isFirstElement = !getPreviousNode(path);
          const isLastElement = !getNextNode(path);
          if (options.htmlWhitespaceSensitivity !== "ignore") {
            const leadingWhitespacesRE = /^[\t\n\f\r ]*/;
            const trailingWhitespacesRE = /[\t\n\f\r ]*$/;
            const shouldTrimTrailingNewlines = isLastElement && isParentOfSomeType(path, ["Template"]);
            const shouldTrimLeadingNewlines = isFirstElement && isParentOfSomeType(path, ["Template"]);
            if (isWhitespaceOnly) {
              if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {
                return "";
              }
              let breaks = [line];
              const newlines = countNewLines(text);
              if (newlines) {
                breaks = generateHardlines(newlines);
              }
              if (isLastNodeOfSiblings(path)) {
                breaks = breaks.map((newline) => dedent(newline));
              }
              return breaks;
            }
            const [lead] = text.match(leadingWhitespacesRE);
            const [tail] = text.match(trailingWhitespacesRE);
            let leadBreaks = [];
            if (lead) {
              leadBreaks = [line];
              const leadingNewlines = countNewLines(lead);
              if (leadingNewlines) {
                leadBreaks = generateHardlines(leadingNewlines);
              }
              text = text.replace(leadingWhitespacesRE, "");
            }
            let trailBreaks = [];
            if (tail) {
              if (!shouldTrimTrailingNewlines) {
                trailBreaks = [line];
                const trailingNewlines = countNewLines(tail);
                if (trailingNewlines) {
                  trailBreaks = generateHardlines(trailingNewlines);
                }
                if (isLastNodeOfSiblings(path)) {
                  trailBreaks = trailBreaks.map((hardline2) => dedent(hardline2));
                }
              }
              text = text.replace(trailingWhitespacesRE, "");
            }
            return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];
          }
          const lineBreaksCount = countNewLines(text);
          let leadingLineBreaksCount = countLeadingNewLines(text);
          let trailingLineBreaksCount = countTrailingNewLines(text);
          if ((isFirstElement || isLastElement) && isWhitespaceOnly && isParentOfSomeType(path, ["Block", "ElementNode", "Template"])) {
            return "";
          }
          if (isWhitespaceOnly && lineBreaksCount) {
            leadingLineBreaksCount = Math.min(lineBreaksCount, NEWLINES_TO_PRESERVE_MAX);
            trailingLineBreaksCount = 0;
          } else {
            if (isNextNodeOfSomeType(path, ["BlockStatement", "ElementNode"])) {
              trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);
            }
            if (isPreviousNodeOfSomeType(path, ["BlockStatement", "ElementNode"])) {
              leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);
            }
          }
          let leadingSpace = "";
          let trailingSpace = "";
          if (trailingLineBreaksCount === 0 && isNextNodeOfSomeType(path, ["MustacheStatement"])) {
            trailingSpace = " ";
          }
          if (leadingLineBreaksCount === 0 && isPreviousNodeOfSomeType(path, ["MustacheStatement"])) {
            leadingSpace = " ";
          }
          if (isFirstElement) {
            leadingLineBreaksCount = 0;
            leadingSpace = "";
          }
          if (isLastElement) {
            trailingLineBreaksCount = 0;
            trailingSpace = "";
          }
          text = text.replace(/^[\t\n\f\r ]+/g, leadingSpace).replace(/[\t\n\f\r ]+$/, trailingSpace);
          return [...generateHardlines(leadingLineBreaksCount), fill(getTextValueParts(text)), ...generateHardlines(trailingLineBreaksCount)];
        }
        case "MustacheCommentStatement": {
          const start = locStart(node);
          const end = locEnd(node);
          const isLeftWhiteSpaceSensitive = options.originalText.charAt(start + 2) === "~";
          const isRightWhitespaceSensitive = options.originalText.charAt(end - 3) === "~";
          const dashes = node.value.includes("}}") ? "--" : "";
          return ["{{", isLeftWhiteSpaceSensitive ? "~" : "", "!", dashes, node.value, dashes, isRightWhitespaceSensitive ? "~" : "", "}}"];
        }
        case "PathExpression": {
          return node.original;
        }
        case "BooleanLiteral": {
          return String(node.value);
        }
        case "CommentStatement": {
          return ["<!--", node.value, "-->"];
        }
        case "StringLiteral": {
          if (needsOppositeQuote(path)) {
            const printFavoriteQuote = !options.singleQuote ? "'" : '"';
            return printStringLiteral(node.value, printFavoriteQuote);
          }
          return printStringLiteral(node.value, favoriteQuote);
        }
        case "NumberLiteral": {
          return String(node.value);
        }
        case "UndefinedLiteral": {
          return "undefined";
        }
        case "NullLiteral": {
          return "null";
        }
        default:
          throw new Error("unknown glimmer type: " + JSON.stringify(node.type));
      }
    }
    function sortByLoc(a, b) {
      return locStart(a) - locStart(b);
    }
    function printStartingTag(path, print2) {
      const node = path.getValue();
      const types = ["attributes", "modifiers", "comments"].filter((property) => isNonEmptyArray(node[property]));
      const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);
      for (const attributeType of types) {
        path.each((attributePath) => {
          const index = attributes.indexOf(attributePath.getValue());
          attributes.splice(index, 1, [line, print2()]);
        }, attributeType);
      }
      if (isNonEmptyArray(node.blockParams)) {
        attributes.push(line, printBlockParams(node));
      }
      return ["<", node.tag, indent(attributes), printStartingTagEndMarker(node)];
    }
    function printChildren(path, options, print2) {
      const node = path.getValue();
      const isEmpty = node.children.every((node2) => isWhitespaceNode(node2));
      if (options.htmlWhitespaceSensitivity === "ignore" && isEmpty) {
        return "";
      }
      return path.map((childPath, childIndex) => {
        const printedChild = print2();
        if (childIndex === 0 && options.htmlWhitespaceSensitivity === "ignore") {
          return [softline, printedChild];
        }
        return printedChild;
      }, "children");
    }
    function printStartingTagEndMarker(node) {
      if (isVoid(node)) {
        return ifBreak([softline, "/>"], [" />", softline]);
      }
      return ifBreak([softline, ">"], ">");
    }
    function printOpeningMustache(node) {
      const mustache = node.escaped === false ? "{{{" : "{{";
      const strip = node.strip && node.strip.open ? "~" : "";
      return [mustache, strip];
    }
    function printClosingMustache(node) {
      const mustache = node.escaped === false ? "}}}" : "}}";
      const strip = node.strip && node.strip.close ? "~" : "";
      return [strip, mustache];
    }
    function printOpeningBlockOpeningMustache(node) {
      const opening = printOpeningMustache(node);
      const strip = node.openStrip.open ? "~" : "";
      return [opening, strip, "#"];
    }
    function printOpeningBlockClosingMustache(node) {
      const closing = printClosingMustache(node);
      const strip = node.openStrip.close ? "~" : "";
      return [strip, closing];
    }
    function printClosingBlockOpeningMustache(node) {
      const opening = printOpeningMustache(node);
      const strip = node.closeStrip.open ? "~" : "";
      return [opening, strip, "/"];
    }
    function printClosingBlockClosingMustache(node) {
      const closing = printClosingMustache(node);
      const strip = node.closeStrip.close ? "~" : "";
      return [strip, closing];
    }
    function printInverseBlockOpeningMustache(node) {
      const opening = printOpeningMustache(node);
      const strip = node.inverseStrip.open ? "~" : "";
      return [opening, strip];
    }
    function printInverseBlockClosingMustache(node) {
      const closing = printClosingMustache(node);
      const strip = node.inverseStrip.close ? "~" : "";
      return [strip, closing];
    }
    function printOpenBlock(path, print2) {
      const node = path.getValue();
      const parts = [];
      const paramsDoc = printParams(path, print2);
      if (paramsDoc) {
        parts.push(group(paramsDoc));
      }
      if (isNonEmptyArray(node.program.blockParams)) {
        parts.push(printBlockParams(node.program));
      }
      return group([printOpeningBlockOpeningMustache(node), printPath(path, print2), parts.length > 0 ? indent([line, join(line, parts)]) : "", softline, printOpeningBlockClosingMustache(node)]);
    }
    function printElseBlock(node, options) {
      return [options.htmlWhitespaceSensitivity === "ignore" ? hardline : "", printInverseBlockOpeningMustache(node), "else", printInverseBlockClosingMustache(node)];
    }
    function printElseIfLikeBlock(path, print2, ifLikeKeyword) {
      const node = path.getValue();
      const parentNode = path.getParentNode(1);
      return group([printInverseBlockOpeningMustache(parentNode), ["else", " ", ifLikeKeyword], indent([line, group(printParams(path, print2)), ...isNonEmptyArray(node.program.blockParams) ? [line, printBlockParams(node.program)] : []]), softline, printInverseBlockClosingMustache(parentNode)]);
    }
    function printCloseBlock(path, print2, options) {
      const node = path.getValue();
      if (options.htmlWhitespaceSensitivity === "ignore") {
        const escape = blockStatementHasOnlyWhitespaceInProgram(node) ? softline : hardline;
        return [escape, printClosingBlockOpeningMustache(node), print2("path"), printClosingBlockClosingMustache(node)];
      }
      return [printClosingBlockOpeningMustache(node), print2("path"), printClosingBlockClosingMustache(node)];
    }
    function blockStatementHasOnlyWhitespaceInProgram(node) {
      return isNodeOfSomeType(node, ["BlockStatement"]) && node.program.body.every((node2) => isWhitespaceNode(node2));
    }
    function blockStatementHasElseIfLike(node) {
      return blockStatementHasElse(node) && node.inverse.body.length === 1 && isNodeOfSomeType(node.inverse.body[0], ["BlockStatement"]) && node.inverse.body[0].path.parts[0] === node.path.parts[0];
    }
    function blockStatementHasElse(node) {
      return isNodeOfSomeType(node, ["BlockStatement"]) && node.inverse;
    }
    function printProgram(path, print2, options) {
      const node = path.getValue();
      if (blockStatementHasOnlyWhitespaceInProgram(node)) {
        return "";
      }
      const program = print2("program");
      if (options.htmlWhitespaceSensitivity === "ignore") {
        return indent([hardline, program]);
      }
      return indent(program);
    }
    function printInverse(path, print2, options) {
      const node = path.getValue();
      const inverse = print2("inverse");
      const printed = options.htmlWhitespaceSensitivity === "ignore" ? [hardline, inverse] : inverse;
      if (blockStatementHasElseIfLike(node)) {
        return printed;
      }
      if (blockStatementHasElse(node)) {
        return [printElseBlock(node, options), indent(printed)];
      }
      return "";
    }
    function getTextValueParts(value) {
      return getDocParts(join(line, splitByHtmlWhitespace(value)));
    }
    function splitByHtmlWhitespace(string) {
      return string.split(/[\t\n\f\r ]+/);
    }
    function getCurrentAttributeName(path) {
      for (let depth = 0; depth < 2; depth++) {
        const parentNode = path.getParentNode(depth);
        if (parentNode && parentNode.type === "AttrNode") {
          return parentNode.name.toLowerCase();
        }
      }
    }
    function countNewLines(string) {
      string = typeof string === "string" ? string : "";
      return string.split("\n").length - 1;
    }
    function countLeadingNewLines(string) {
      string = typeof string === "string" ? string : "";
      const newLines = (string.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
      return countNewLines(newLines);
    }
    function countTrailingNewLines(string) {
      string = typeof string === "string" ? string : "";
      const newLines = (string.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
      return countNewLines(newLines);
    }
    function generateHardlines(number = 0) {
      return Array.from({
        length: Math.min(number, NEWLINES_TO_PRESERVE_MAX)
      }).fill(hardline);
    }
    function printStringLiteral(stringLiteral, favoriteQuote) {
      const {
        quote,
        regex
      } = getPreferredQuote(stringLiteral, favoriteQuote);
      return [quote, stringLiteral.replace(regex, `\\${quote}`), quote];
    }
    function needsOppositeQuote(path) {
      let index = 0;
      let parentNode = path.getParentNode(index);
      while (parentNode && isNodeOfSomeType(parentNode, ["SubExpression"])) {
        index++;
        parentNode = path.getParentNode(index);
      }
      if (parentNode && isNodeOfSomeType(path.getParentNode(index + 1), ["ConcatStatement"]) && isNodeOfSomeType(path.getParentNode(index + 2), ["AttrNode"])) {
        return true;
      }
      return false;
    }
    function printSubExpressionPathAndParams(path, print2) {
      const printed = printPath(path, print2);
      const params = printParams(path, print2);
      if (!params) {
        return printed;
      }
      return indent([printed, line, group(params)]);
    }
    function printPathAndParams(path, print2) {
      const p = printPath(path, print2);
      const params = printParams(path, print2);
      if (!params) {
        return p;
      }
      return [indent([p, line, params]), softline];
    }
    function printPath(path, print2) {
      return print2("path");
    }
    function printParams(path, print2) {
      const node = path.getValue();
      const parts = [];
      if (node.params.length > 0) {
        const params = path.map(print2, "params");
        parts.push(...params);
      }
      if (node.hash && node.hash.pairs.length > 0) {
        const hash = print2("hash");
        parts.push(hash);
      }
      if (parts.length === 0) {
        return "";
      }
      return join(line, parts);
    }
    function printBlockParams(node) {
      return ["as |", node.blockParams.join(" "), "|"];
    }
    module2.exports = {
      print,
      massageAstNode: clean
    };
  }
});
var require_parsers3 = __commonJS2({
  "src/language-handlebars/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get glimmer() {
        return require("./parser-glimmer.js").parsers.glimmer;
      }
    };
  }
});
var require_Handlebars = __commonJS2({
  "node_modules/linguist-languages/data/Handlebars.json"(exports2, module2) {
    module2.exports = {
      name: "Handlebars",
      type: "markup",
      color: "#f7931e",
      aliases: ["hbs", "htmlbars"],
      extensions: [".handlebars", ".hbs"],
      tmScope: "text.html.handlebars",
      aceMode: "handlebars",
      languageId: 155
    };
  }
});
var require_language_handlebars = __commonJS2({
  "src/language-handlebars/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var printer = require_printer_glimmer();
    var parsers = require_parsers3();
    var languages = [createLanguage(require_Handlebars(), () => ({
      since: "2.3.0",
      parsers: ["glimmer"],
      vscodeLanguageIds: ["handlebars"]
    }))];
    var printers = {
      glimmer: printer
    };
    module2.exports = {
      languages,
      printers,
      parsers
    };
  }
});
var require_pragma3 = __commonJS2({
  "src/language-graphql/pragma.js"(exports2, module2) {
    "use strict";
    function hasPragma(text) {
      return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(text);
    }
    function insertPragma(text) {
      return "# @format\n\n" + text;
    }
    module2.exports = {
      hasPragma,
      insertPragma
    };
  }
});
var require_loc4 = __commonJS2({
  "src/language-graphql/loc.js"(exports2, module2) {
    "use strict";
    function locStart(node) {
      if (typeof node.start === "number") {
        return node.start;
      }
      return node.loc && node.loc.start;
    }
    function locEnd(node) {
      if (typeof node.end === "number") {
        return node.end;
      }
      return node.loc && node.loc.end;
    }
    module2.exports = {
      locStart,
      locEnd
    };
  }
});
var require_printer_graphql = __commonJS2({
  "src/language-graphql/printer-graphql.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        join,
        hardline,
        line,
        softline,
        group,
        indent,
        ifBreak
      }
    } = require("./doc.js");
    var {
      isNextLineEmpty,
      isNonEmptyArray
    } = require_util();
    var {
      insertPragma
    } = require_pragma3();
    var {
      locStart,
      locEnd
    } = require_loc4();
    function genericPrint(path, options, print) {
      const node = path.getValue();
      if (!node) {
        return "";
      }
      if (typeof node === "string") {
        return node;
      }
      switch (node.kind) {
        case "Document": {
          const parts = [];
          path.each((pathChild, index, definitions) => {
            parts.push(print());
            if (index !== definitions.length - 1) {
              parts.push(hardline);
              if (isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd)) {
                parts.push(hardline);
              }
            }
          }, "definitions");
          return [...parts, hardline];
        }
        case "OperationDefinition": {
          const hasOperation = options.originalText[locStart(node)] !== "{";
          const hasName = Boolean(node.name);
          return [hasOperation ? node.operation : "", hasOperation && hasName ? [" ", print("name")] : "", hasOperation && !hasName && isNonEmptyArray(node.variableDefinitions) ? " " : "", isNonEmptyArray(node.variableDefinitions) ? group(["(", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "variableDefinitions"))]), softline, ")"]) : "", printDirectives(path, print, node), node.selectionSet ? !hasOperation && !hasName ? "" : " " : "", print("selectionSet")];
        }
        case "FragmentDefinition": {
          return ["fragment ", print("name"), isNonEmptyArray(node.variableDefinitions) ? group(["(", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "variableDefinitions"))]), softline, ")"]) : "", " on ", print("typeCondition"), printDirectives(path, print, node), " ", print("selectionSet")];
        }
        case "SelectionSet": {
          return ["{", indent([hardline, join(hardline, printSequence(path, options, print, "selections"))]), hardline, "}"];
        }
        case "Field": {
          return group([node.alias ? [print("alias"), ": "] : "", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : "", printDirectives(path, print, node), node.selectionSet ? " " : "", print("selectionSet")]);
        }
        case "Name": {
          return node.value;
        }
        case "StringValue": {
          if (node.block) {
            const lines = node.value.replace(/"""/g, "\\$&").split("\n");
            if (lines.length === 1) {
              lines[0] = lines[0].trim();
            }
            if (lines.every((line2) => line2 === "")) {
              lines.length = 0;
            }
            return join(hardline, ['"""', ...lines, '"""']);
          }
          return ['"', node.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
        }
        case "IntValue":
        case "FloatValue":
        case "EnumValue": {
          return node.value;
        }
        case "BooleanValue": {
          return node.value ? "true" : "false";
        }
        case "NullValue": {
          return "null";
        }
        case "Variable": {
          return ["$", print("name")];
        }
        case "ListValue": {
          return group(["[", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "values"))]), softline, "]"]);
        }
        case "ObjectValue": {
          return group(["{", options.bracketSpacing && node.fields.length > 0 ? " " : "", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "fields"))]), softline, ifBreak("", options.bracketSpacing && node.fields.length > 0 ? " " : ""), "}"]);
        }
        case "ObjectField":
        case "Argument": {
          return [print("name"), ": ", print("value")];
        }
        case "Directive": {
          return ["@", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : ""];
        }
        case "NamedType": {
          return print("name");
        }
        case "VariableDefinition": {
          return [print("variable"), ": ", print("type"), node.defaultValue ? [" = ", print("defaultValue")] : "", printDirectives(path, print, node)];
        }
        case "ObjectTypeExtension":
        case "ObjectTypeDefinition": {
          return [print("description"), node.description ? hardline : "", node.kind === "ObjectTypeExtension" ? "extend " : "", "type ", print("name"), node.interfaces.length > 0 ? [" implements ", ...printInterfaces(path, options, print)] : "", printDirectives(path, print, node), node.fields.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "fields"))]), hardline, "}"] : ""];
        }
        case "FieldDefinition": {
          return [print("description"), node.description ? hardline : "", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : "", ": ", print("type"), printDirectives(path, print, node)];
        }
        case "DirectiveDefinition": {
          return [print("description"), node.description ? hardline : "", "directive ", "@", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : "", node.repeatable ? " repeatable" : "", " on ", join(" | ", path.map(print, "locations"))];
        }
        case "EnumTypeExtension":
        case "EnumTypeDefinition": {
          return [print("description"), node.description ? hardline : "", node.kind === "EnumTypeExtension" ? "extend " : "", "enum ", print("name"), printDirectives(path, print, node), node.values.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "values"))]), hardline, "}"] : ""];
        }
        case "EnumValueDefinition": {
          return [print("description"), node.description ? hardline : "", print("name"), printDirectives(path, print, node)];
        }
        case "InputValueDefinition": {
          return [print("description"), node.description ? node.description.block ? hardline : line : "", print("name"), ": ", print("type"), node.defaultValue ? [" = ", print("defaultValue")] : "", printDirectives(path, print, node)];
        }
        case "InputObjectTypeExtension":
        case "InputObjectTypeDefinition": {
          return [print("description"), node.description ? hardline : "", node.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", print("name"), printDirectives(path, print, node), node.fields.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "fields"))]), hardline, "}"] : ""];
        }
        case "SchemaExtension": {
          return ["extend schema", printDirectives(path, print, node), ...node.operationTypes.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "operationTypes"))]), hardline, "}"] : []];
        }
        case "SchemaDefinition": {
          return [print("description"), node.description ? hardline : "", "schema", printDirectives(path, print, node), " {", node.operationTypes.length > 0 ? indent([hardline, join(hardline, printSequence(path, options, print, "operationTypes"))]) : "", hardline, "}"];
        }
        case "OperationTypeDefinition": {
          return [print("operation"), ": ", print("type")];
        }
        case "InterfaceTypeExtension":
        case "InterfaceTypeDefinition": {
          return [print("description"), node.description ? hardline : "", node.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", print("name"), node.interfaces.length > 0 ? [" implements ", ...printInterfaces(path, options, print)] : "", printDirectives(path, print, node), node.fields.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "fields"))]), hardline, "}"] : ""];
        }
        case "FragmentSpread": {
          return ["...", print("name"), printDirectives(path, print, node)];
        }
        case "InlineFragment": {
          return ["...", node.typeCondition ? [" on ", print("typeCondition")] : "", printDirectives(path, print, node), " ", print("selectionSet")];
        }
        case "UnionTypeExtension":
        case "UnionTypeDefinition": {
          return group([print("description"), node.description ? hardline : "", group([node.kind === "UnionTypeExtension" ? "extend " : "", "union ", print("name"), printDirectives(path, print, node), node.types.length > 0 ? [" =", ifBreak("", " "), indent([ifBreak([line, "  "]), join([line, "| "], path.map(print, "types"))])] : ""])]);
        }
        case "ScalarTypeExtension":
        case "ScalarTypeDefinition": {
          return [print("description"), node.description ? hardline : "", node.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", print("name"), printDirectives(path, print, node)];
        }
        case "NonNullType": {
          return [print("type"), "!"];
        }
        case "ListType": {
          return ["[", print("type"), "]"];
        }
        default:
          throw new Error("unknown graphql type: " + JSON.stringify(node.kind));
      }
    }
    function printDirectives(path, print, node) {
      if (node.directives.length === 0) {
        return "";
      }
      const printed = join(line, path.map(print, "directives"));
      if (node.kind === "FragmentDefinition" || node.kind === "OperationDefinition") {
        return group([line, printed]);
      }
      return [" ", group(indent([softline, printed]))];
    }
    function printSequence(path, options, print, property) {
      return path.map((path2, index, sequence) => {
        const printed = print();
        if (index < sequence.length - 1 && isNextLineEmpty(options.originalText, path2.getValue(), locEnd)) {
          return [printed, hardline];
        }
        return printed;
      }, property);
    }
    function canAttachComment(node) {
      return node.kind && node.kind !== "Comment";
    }
    function printComment(commentPath) {
      const comment = commentPath.getValue();
      if (comment.kind === "Comment") {
        return "#" + comment.value.trimEnd();
      }
      throw new Error("Not a comment: " + JSON.stringify(comment));
    }
    function printInterfaces(path, options, print) {
      const node = path.getNode();
      const parts = [];
      const {
        interfaces
      } = node;
      const printed = path.map((node2) => print(node2), "interfaces");
      for (let index = 0; index < interfaces.length; index++) {
        const interfaceNode = interfaces[index];
        parts.push(printed[index]);
        const nextInterfaceNode = interfaces[index + 1];
        if (nextInterfaceNode) {
          const textBetween = options.originalText.slice(interfaceNode.loc.end, nextInterfaceNode.loc.start);
          const hasComment = textBetween.includes("#");
          const separator = textBetween.replace(/#.*/g, "").trim();
          parts.push(separator === "," ? "," : " &", hasComment ? line : " ");
        }
      }
      return parts;
    }
    function clean(node, newNode) {
      if (node.kind === "StringValue" && node.block && !node.value.includes("\n")) {
        newNode.value = newNode.value.trim();
      }
    }
    clean.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
    function hasPrettierIgnore(path) {
      var _node$comments;
      const node = path.getValue();
      return node === null || node === void 0 ? void 0 : (_node$comments = node.comments) === null || _node$comments === void 0 ? void 0 : _node$comments.some((comment) => comment.value.trim() === "prettier-ignore");
    }
    module2.exports = {
      print: genericPrint,
      massageAstNode: clean,
      hasPrettierIgnore,
      insertPragma,
      printComment,
      canAttachComment
    };
  }
});
var require_options4 = __commonJS2({
  "src/language-graphql/options.js"(exports2, module2) {
    "use strict";
    var commonOptions = require_common_options();
    module2.exports = {
      bracketSpacing: commonOptions.bracketSpacing
    };
  }
});
var require_parsers4 = __commonJS2({
  "src/language-graphql/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get graphql() {
        return require("./parser-graphql.js").parsers.graphql;
      }
    };
  }
});
var require_GraphQL = __commonJS2({
  "node_modules/linguist-languages/data/GraphQL.json"(exports2, module2) {
    module2.exports = {
      name: "GraphQL",
      type: "data",
      color: "#e10098",
      extensions: [".graphql", ".gql", ".graphqls"],
      tmScope: "source.graphql",
      aceMode: "text",
      languageId: 139
    };
  }
});
var require_language_graphql = __commonJS2({
  "src/language-graphql/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var printer = require_printer_graphql();
    var options = require_options4();
    var parsers = require_parsers4();
    var languages = [createLanguage(require_GraphQL(), () => ({
      since: "1.5.0",
      parsers: ["graphql"],
      vscodeLanguageIds: ["graphql"]
    }))];
    var printers = {
      graphql: printer
    };
    module2.exports = {
      languages,
      options,
      printers,
      parsers
    };
  }
});
var require_collapse_white_space = __commonJS2({
  "node_modules/collapse-white-space/index.js"(exports2, module2) {
    "use strict";
    module2.exports = collapse;
    function collapse(value) {
      return String(value).replace(/\s+/g, " ");
    }
  }
});
var require_loc5 = __commonJS2({
  "src/language-markdown/loc.js"(exports2, module2) {
    "use strict";
    function locStart(node) {
      return node.position.start.offset;
    }
    function locEnd(node) {
      return node.position.end.offset;
    }
    module2.exports = {
      locStart,
      locEnd
    };
  }
});
var require_constants_evaluate = __commonJS2({
  "src/language-markdown/constants.evaluate.js"(exports2, module2) {
    module2.exports = {
      cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",
      kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
      punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
    };
  }
});
var require_utils10 = __commonJS2({
  "src/language-markdown/utils.js"(exports2, module2) {
    "use strict";
    var {
      getLast
    } = require_util();
    var {
      locStart,
      locEnd
    } = require_loc5();
    var {
      cjkPattern,
      kPattern,
      punctuationPattern
    } = require_constants_evaluate();
    var INLINE_NODE_TYPES = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"];
    var INLINE_NODE_WRAPPER_TYPES = [...INLINE_NODE_TYPES, "tableCell", "paragraph", "heading"];
    var kRegex = new RegExp(kPattern);
    var punctuationRegex = new RegExp(punctuationPattern);
    function splitText(text, options) {
      const KIND_NON_CJK = "non-cjk";
      const KIND_CJ_LETTER = "cj-letter";
      const KIND_K_LETTER = "k-letter";
      const KIND_CJK_PUNCTUATION = "cjk-punctuation";
      const nodes = [];
      const tokens = (options.proseWrap === "preserve" ? text : text.replace(new RegExp(`(${cjkPattern})
(${cjkPattern})`, "g"), "$1$2")).split(/([\t\n ]+)/);
      for (const [index, token] of tokens.entries()) {
        if (index % 2 === 1) {
          nodes.push({
            type: "whitespace",
            value: /\n/.test(token) ? "\n" : " "
          });
          continue;
        }
        if ((index === 0 || index === tokens.length - 1) && token === "") {
          continue;
        }
        const innerTokens = token.split(new RegExp(`(${cjkPattern})`));
        for (const [innerIndex, innerToken] of innerTokens.entries()) {
          if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {
            continue;
          }
          if (innerIndex % 2 === 0) {
            if (innerToken !== "") {
              appendNode({
                type: "word",
                value: innerToken,
                kind: KIND_NON_CJK,
                hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),
                hasTrailingPunctuation: punctuationRegex.test(getLast(innerToken))
              });
            }
            continue;
          }
          appendNode(punctuationRegex.test(innerToken) ? {
            type: "word",
            value: innerToken,
            kind: KIND_CJK_PUNCTUATION,
            hasLeadingPunctuation: true,
            hasTrailingPunctuation: true
          } : {
            type: "word",
            value: innerToken,
            kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,
            hasLeadingPunctuation: false,
            hasTrailingPunctuation: false
          });
        }
      }
      return nodes;
      function appendNode(node) {
        const lastNode = getLast(nodes);
        if (lastNode && lastNode.type === "word") {
          if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {
            nodes.push({
              type: "whitespace",
              value: " "
            });
          } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && ![lastNode.value, node.value].some((value) => /\u3000/.test(value))) {
            nodes.push({
              type: "whitespace",
              value: ""
            });
          }
        }
        nodes.push(node);
        function isBetween(kind1, kind2) {
          return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;
        }
      }
    }
    function getOrderedListItemInfo(orderListItem, originalText) {
      const [, numberText, marker, leadingSpaces] = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
      return {
        numberText,
        marker,
        leadingSpaces
      };
    }
    function hasGitDiffFriendlyOrderedList(node, options) {
      if (!node.ordered) {
        return false;
      }
      if (node.children.length < 2) {
        return false;
      }
      const firstNumber = Number(getOrderedListItemInfo(node.children[0], options.originalText).numberText);
      const secondNumber = Number(getOrderedListItemInfo(node.children[1], options.originalText).numberText);
      if (firstNumber === 0 && node.children.length > 2) {
        const thirdNumber = Number(getOrderedListItemInfo(node.children[2], options.originalText).numberText);
        return secondNumber === 1 && thirdNumber === 1;
      }
      return secondNumber === 1;
    }
    function getFencedCodeBlockValue(node, originalText) {
      const {
        value
      } = node;
      if (node.position.end.offset === originalText.length && value.endsWith("\n") && originalText.endsWith("\n")) {
        return value.slice(0, -1);
      }
      return value;
    }
    function mapAst(ast, handler) {
      return function preorder(node, index, parentStack) {
        const newNode = Object.assign({}, handler(node, index, parentStack));
        if (newNode.children) {
          newNode.children = newNode.children.map((child, index2) => preorder(child, index2, [newNode, ...parentStack]));
        }
        return newNode;
      }(ast, null, []);
    }
    function isAutolink(node) {
      if ((node === null || node === void 0 ? void 0 : node.type) !== "link" || node.children.length !== 1) {
        return false;
      }
      const [child] = node.children;
      return locStart(node) === locStart(child) && locEnd(node) === locEnd(child);
    }
    module2.exports = {
      mapAst,
      splitText,
      punctuationPattern,
      getFencedCodeBlockValue,
      getOrderedListItemInfo,
      hasGitDiffFriendlyOrderedList,
      INLINE_NODE_TYPES,
      INLINE_NODE_WRAPPER_TYPES,
      isAutolink
    };
  }
});
var require_embed3 = __commonJS2({
  "src/language-markdown/embed.js"(exports2, module2) {
    "use strict";
    var {
      inferParserByLanguage,
      getMaxContinuousCount
    } = require_util();
    var {
      builders: {
        hardline,
        markAsRoot
      },
      utils: {
        replaceEndOfLine
      }
    } = require("./doc.js");
    var printFrontMatter = require_print();
    var {
      getFencedCodeBlockValue
    } = require_utils10();
    function embed(path, print, textToDoc, options) {
      const node = path.getValue();
      if (node.type === "code" && node.lang !== null) {
        const parser = inferParserByLanguage(node.lang, options);
        if (parser) {
          const styleUnit = options.__inJsTemplate ? "~" : "`";
          const style = styleUnit.repeat(Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1));
          const newOptions = {
            parser
          };
          if (node.lang === "tsx") {
            newOptions.filepath = "dummy.tsx";
          }
          const doc2 = textToDoc(getFencedCodeBlockValue(node, options.originalText), newOptions, {
            stripTrailingHardline: true
          });
          return markAsRoot([style, node.lang, node.meta ? " " + node.meta : "", hardline, replaceEndOfLine(doc2), hardline, style]);
        }
      }
      switch (node.type) {
        case "front-matter":
          return printFrontMatter(node, textToDoc);
        case "importExport":
          return [textToDoc(node.value, {
            parser: "babel"
          }, {
            stripTrailingHardline: true
          }), hardline];
        case "jsx":
          return textToDoc(`<$>${node.value}</$>`, {
            parser: "__js_expression",
            rootMarker: "mdx"
          }, {
            stripTrailingHardline: true
          });
      }
      return null;
    }
    module2.exports = embed;
  }
});
var require_pragma4 = __commonJS2({
  "src/language-markdown/pragma.js"(exports2, module2) {
    "use strict";
    var parseFrontMatter = require_parse4();
    var pragmas = ["format", "prettier"];
    function startWithPragma(text) {
      const pragma = `@(${pragmas.join("|")})`;
      const regex = new RegExp([`<!--\\s*${pragma}\\s*-->`, `{\\s*\\/\\*\\s*${pragma}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${pragma}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m");
      const matched = text.match(regex);
      return (matched === null || matched === void 0 ? void 0 : matched.index) === 0;
    }
    module2.exports = {
      startWithPragma,
      hasPragma: (text) => startWithPragma(parseFrontMatter(text).content.trimStart()),
      insertPragma: (text) => {
        const extracted = parseFrontMatter(text);
        const pragma = `<!-- @${pragmas[0]} -->`;
        return extracted.frontMatter ? `${extracted.frontMatter.raw}

${pragma}

${extracted.content}` : `${pragma}

${extracted.content}`;
      }
    };
  }
});
var require_print_preprocess2 = __commonJS2({
  "src/language-markdown/print-preprocess.js"(exports2, module2) {
    "use strict";
    var getLast = require_get_last();
    var {
      getOrderedListItemInfo,
      mapAst,
      splitText
    } = require_utils10();
    var isSingleCharRegex = /^.$/su;
    function preprocess(ast, options) {
      ast = restoreUnescapedCharacter(ast, options);
      ast = mergeContinuousTexts(ast);
      ast = transformInlineCode(ast, options);
      ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);
      ast = markAlignedList(ast, options);
      ast = splitTextIntoSentences(ast, options);
      ast = transformImportExport(ast);
      ast = mergeContinuousImportExport(ast);
      return ast;
    }
    function transformImportExport(ast) {
      return mapAst(ast, (node) => {
        if (node.type !== "import" && node.type !== "export") {
          return node;
        }
        return Object.assign(Object.assign({}, node), {}, {
          type: "importExport"
        });
      });
    }
    function transformInlineCode(ast, options) {
      return mapAst(ast, (node) => {
        if (node.type !== "inlineCode" || options.proseWrap === "preserve") {
          return node;
        }
        return Object.assign(Object.assign({}, node), {}, {
          value: node.value.replace(/\s+/g, " ")
        });
      });
    }
    function restoreUnescapedCharacter(ast, options) {
      return mapAst(ast, (node) => node.type !== "text" || node.value === "*" || node.value === "_" || !isSingleCharRegex.test(node.value) || node.position.end.offset - node.position.start.offset === node.value.length ? node : Object.assign(Object.assign({}, node), {}, {
        value: options.originalText.slice(node.position.start.offset, node.position.end.offset)
      }));
    }
    function mergeContinuousImportExport(ast) {
      return mergeChildren(ast, (prevNode, node) => prevNode.type === "importExport" && node.type === "importExport", (prevNode, node) => ({
        type: "importExport",
        value: prevNode.value + "\n\n" + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      }));
    }
    function mergeChildren(ast, shouldMerge, mergeNode) {
      return mapAst(ast, (node) => {
        if (!node.children) {
          return node;
        }
        const children = node.children.reduce((current, child) => {
          const lastChild = getLast(current);
          if (lastChild && shouldMerge(lastChild, child)) {
            current.splice(-1, 1, mergeNode(lastChild, child));
          } else {
            current.push(child);
          }
          return current;
        }, []);
        return Object.assign(Object.assign({}, node), {}, {
          children
        });
      });
    }
    function mergeContinuousTexts(ast) {
      return mergeChildren(ast, (prevNode, node) => prevNode.type === "text" && node.type === "text", (prevNode, node) => ({
        type: "text",
        value: prevNode.value + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      }));
    }
    function splitTextIntoSentences(ast, options) {
      return mapAst(ast, (node, index, [parentNode]) => {
        if (node.type !== "text") {
          return node;
        }
        let {
          value
        } = node;
        if (parentNode.type === "paragraph") {
          if (index === 0) {
            value = value.trimStart();
          }
          if (index === parentNode.children.length - 1) {
            value = value.trimEnd();
          }
        }
        return {
          type: "sentence",
          position: node.position,
          children: splitText(value, options)
        };
      });
    }
    function transformIndentedCodeblockAndMarkItsParentList(ast, options) {
      return mapAst(ast, (node, index, parentStack) => {
        if (node.type === "code") {
          const isIndented = /^\n?(?: {4,}|\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));
          node.isIndented = isIndented;
          if (isIndented) {
            for (let i = 0; i < parentStack.length; i++) {
              const parent = parentStack[i];
              if (parent.hasIndentedCodeblock) {
                break;
              }
              if (parent.type === "list") {
                parent.hasIndentedCodeblock = true;
              }
            }
          }
        }
        return node;
      });
    }
    function markAlignedList(ast, options) {
      return mapAst(ast, (node, index, parentStack) => {
        if (node.type === "list" && node.children.length > 0) {
          for (let i = 0; i < parentStack.length; i++) {
            const parent = parentStack[i];
            if (parent.type === "list" && !parent.isAligned) {
              node.isAligned = false;
              return node;
            }
          }
          node.isAligned = isAligned(node);
        }
        return node;
      });
      function getListItemStart(listItem) {
        return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;
      }
      function isAligned(list) {
        if (!list.ordered) {
          return true;
        }
        const [firstItem, secondItem] = list.children;
        const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);
        if (firstInfo.leadingSpaces.length > 1) {
          return true;
        }
        const firstStart = getListItemStart(firstItem);
        if (firstStart === -1) {
          return false;
        }
        if (list.children.length === 1) {
          return firstStart % options.tabWidth === 0;
        }
        const secondStart = getListItemStart(secondItem);
        if (firstStart !== secondStart) {
          return false;
        }
        if (firstStart % options.tabWidth === 0) {
          return true;
        }
        const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);
        return secondInfo.leadingSpaces.length > 1;
      }
    }
    module2.exports = preprocess;
  }
});
var require_clean4 = __commonJS2({
  "src/language-markdown/clean.js"(exports2, module2) {
    "use strict";
    var collapseWhiteSpace = require_collapse_white_space();
    var {
      isFrontMatterNode
    } = require_util();
    var {
      startWithPragma
    } = require_pragma4();
    var ignoredProperties = /* @__PURE__ */ new Set(["position", "raw"]);
    function clean(ast, newObj, parent) {
      if (ast.type === "front-matter" || ast.type === "code" || ast.type === "yaml" || ast.type === "import" || ast.type === "export" || ast.type === "jsx") {
        delete newObj.value;
      }
      if (ast.type === "list") {
        delete newObj.isAligned;
      }
      if (ast.type === "list" || ast.type === "listItem") {
        delete newObj.spread;
        delete newObj.loose;
      }
      if (ast.type === "text") {
        return null;
      }
      if (ast.type === "inlineCode") {
        newObj.value = ast.value.replace(/[\t\n ]+/g, " ");
      }
      if (ast.type === "wikiLink") {
        newObj.value = ast.value.trim().replace(/[\t\n]+/g, " ");
      }
      if (ast.type === "definition" || ast.type === "linkReference" || ast.type === "imageReference") {
        newObj.label = collapseWhiteSpace(ast.label);
      }
      if ((ast.type === "definition" || ast.type === "link" || ast.type === "image") && ast.title) {
        newObj.title = ast.title.replace(/\\(["')])/g, "$1");
      }
      if (parent && parent.type === "root" && parent.children.length > 0 && (parent.children[0] === ast || isFrontMatterNode(parent.children[0]) && parent.children[1] === ast) && ast.type === "html" && startWithPragma(ast.value)) {
        return null;
      }
    }
    clean.ignoredProperties = ignoredProperties;
    module2.exports = clean;
  }
});
var require_printer_markdown = __commonJS2({
  "src/language-markdown/printer-markdown.js"(exports2, module2) {
    "use strict";
    var collapseWhiteSpace = require_collapse_white_space();
    var {
      getLast,
      getMinNotPresentContinuousCount,
      getMaxContinuousCount,
      getStringWidth,
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        breakParent,
        join,
        line,
        literalline,
        markAsRoot,
        hardline,
        softline,
        ifBreak,
        fill,
        align,
        indent,
        group,
        hardlineWithoutBreakParent
      },
      utils: {
        normalizeDoc,
        replaceTextEndOfLine
      },
      printer: {
        printDocToString
      }
    } = require("./doc.js");
    var embed = require_embed3();
    var {
      insertPragma
    } = require_pragma4();
    var {
      locStart,
      locEnd
    } = require_loc5();
    var preprocess = require_print_preprocess2();
    var clean = require_clean4();
    var {
      getFencedCodeBlockValue,
      hasGitDiffFriendlyOrderedList,
      splitText,
      punctuationPattern,
      INLINE_NODE_TYPES,
      INLINE_NODE_WRAPPER_TYPES,
      isAutolink
    } = require_utils10();
    var TRAILING_HARDLINE_NODES = /* @__PURE__ */ new Set(["importExport"]);
    var SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link", "wikiLink"];
    var SIBLING_NODE_TYPES = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
    function genericPrint(path, options, print) {
      const node = path.getValue();
      if (shouldRemainTheSameContent(path)) {
        return splitText(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map((node2) => node2.type === "word" ? node2.value : node2.value === "" ? "" : printLine(path, node2.value, options));
      }
      switch (node.type) {
        case "front-matter":
          return options.originalText.slice(node.position.start.offset, node.position.end.offset);
        case "root":
          if (node.children.length === 0) {
            return "";
          }
          return [normalizeDoc(printRoot(path, options, print)), !TRAILING_HARDLINE_NODES.has(getLastDescendantNode(node).type) ? hardline : ""];
        case "paragraph":
          return printChildren(path, options, print, {
            postprocessor: fill
          });
        case "sentence":
          return printChildren(path, options, print);
        case "word": {
          let escapedValue = node.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${punctuationPattern})(_+)`, `(_+)(${punctuationPattern}|$)`].join("|"), "g"), (_, text1, underscore1, underscore2, text2) => (underscore1 ? `${text1}${underscore1}` : `${underscore2}${text2}`).replace(/_/g, "\\_"));
          const isFirstSentence = (node2, name, index) => node2.type === "sentence" && index === 0;
          const isLastChildAutolink = (node2, name, index) => isAutolink(node2.children[index - 1]);
          if (escapedValue !== node.value && (path.match(void 0, isFirstSentence, isLastChildAutolink) || path.match(void 0, isFirstSentence, (node2, name, index) => node2.type === "emphasis" && index === 0, isLastChildAutolink))) {
            escapedValue = escapedValue.replace(/^(\\?[*_])+/, (prefix) => prefix.replace(/\\/g, ""));
          }
          return escapedValue;
        }
        case "whitespace": {
          const parentNode = path.getParentNode();
          const index = parentNode.children.indexOf(node);
          const nextNode = parentNode.children[index + 1];
          const proseWrap = nextNode && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(nextNode.value) ? "never" : options.proseWrap;
          return printLine(path, node.value, {
            proseWrap
          });
        }
        case "emphasis": {
          let style;
          if (isAutolink(node.children[0])) {
            style = options.originalText[node.position.start.offset];
          } else {
            const parentNode = path.getParentNode();
            const index = parentNode.children.indexOf(node);
            const prevNode = parentNode.children[index - 1];
            const nextNode = parentNode.children[index + 1];
            const hasPrevOrNextWord = prevNode && prevNode.type === "sentence" && prevNode.children.length > 0 && getLast(prevNode.children).type === "word" && !getLast(prevNode.children).hasTrailingPunctuation || nextNode && nextNode.type === "sentence" && nextNode.children.length > 0 && nextNode.children[0].type === "word" && !nextNode.children[0].hasLeadingPunctuation;
            style = hasPrevOrNextWord || getAncestorNode(path, "emphasis") ? "*" : "_";
          }
          return [style, printChildren(path, options, print), style];
        }
        case "strong":
          return ["**", printChildren(path, options, print), "**"];
        case "delete":
          return ["~~", printChildren(path, options, print), "~~"];
        case "inlineCode": {
          const backtickCount = getMinNotPresentContinuousCount(node.value, "`");
          const style = "`".repeat(backtickCount || 1);
          const gap = backtickCount && !/^\s/.test(node.value) ? " " : "";
          return [style, gap, node.value, gap, style];
        }
        case "wikiLink": {
          let contents = "";
          if (options.proseWrap === "preserve") {
            contents = node.value;
          } else {
            contents = node.value.replace(/[\t\n]+/g, " ");
          }
          return ["[[", contents, "]]"];
        }
        case "link":
          switch (options.originalText[node.position.start.offset]) {
            case "<": {
              const mailto = "mailto:";
              const url = node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;
              return ["<", url, ">"];
            }
            case "[":
              return ["[", printChildren(path, options, print), "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"];
            default:
              return options.originalText.slice(node.position.start.offset, node.position.end.offset);
          }
        case "image":
          return ["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"];
        case "blockquote":
          return ["> ", align("> ", printChildren(path, options, print))];
        case "heading":
          return ["#".repeat(node.depth) + " ", printChildren(path, options, print)];
        case "code": {
          if (node.isIndented) {
            const alignment = " ".repeat(4);
            return align(alignment, [alignment, ...replaceTextEndOfLine(node.value, hardline)]);
          }
          const styleUnit = options.__inJsTemplate ? "~" : "`";
          const style = styleUnit.repeat(Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1));
          return [style, node.lang || "", node.meta ? " " + node.meta : "", hardline, ...replaceTextEndOfLine(getFencedCodeBlockValue(node, options.originalText), hardline), hardline, style];
        }
        case "html": {
          const parentNode = path.getParentNode();
          const value = parentNode.type === "root" && getLast(parentNode.children) === node ? node.value.trimEnd() : node.value;
          const isHtmlComment = /^<!--.*-->$/s.test(value);
          return replaceTextEndOfLine(value, isHtmlComment ? hardline : markAsRoot(literalline));
        }
        case "list": {
          const nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());
          const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(node, options);
          return printChildren(path, options, print, {
            processor: (childPath, index) => {
              const prefix = getPrefix();
              const childNode = childPath.getValue();
              if (childNode.children.length === 2 && childNode.children[1].type === "html" && childNode.children[0].position.start.column !== childNode.children[1].position.start.column) {
                return [prefix, printListItem(childPath, options, print, prefix)];
              }
              return [prefix, align(" ".repeat(prefix.length), printListItem(childPath, options, print, prefix))];
              function getPrefix() {
                const rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";
                return node.isAligned || node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options) : rawPrefix;
              }
            }
          });
        }
        case "thematicBreak": {
          const counter = getAncestorCounter(path, "list");
          if (counter === -1) {
            return "---";
          }
          const nthSiblingIndex = getNthListSiblingIndex(path.getParentNode(counter), path.getParentNode(counter + 1));
          return nthSiblingIndex % 2 === 0 ? "***" : "---";
        }
        case "linkReference":
          return ["[", printChildren(path, options, print), "]", node.referenceType === "full" ? printLinkReference(node) : node.referenceType === "collapsed" ? "[]" : ""];
        case "imageReference":
          switch (node.referenceType) {
            case "full":
              return ["![", node.alt || "", "]", printLinkReference(node)];
            default:
              return ["![", node.alt, "]", node.referenceType === "collapsed" ? "[]" : ""];
          }
        case "definition": {
          const lineOrSpace = options.proseWrap === "always" ? line : " ";
          return group([printLinkReference(node), ":", indent([lineOrSpace, printUrl(node.url), node.title === null ? "" : [lineOrSpace, printTitle(node.title, options, false)]])]);
        }
        case "footnote":
          return ["[^", printChildren(path, options, print), "]"];
        case "footnoteReference":
          return printFootnoteReference(node);
        case "footnoteDefinition": {
          const nextNode = path.getParentNode().children[path.getName() + 1];
          const shouldInlineFootnote = node.children.length === 1 && node.children[0].type === "paragraph" && (options.proseWrap === "never" || options.proseWrap === "preserve" && node.children[0].position.start.line === node.children[0].position.end.line);
          return [printFootnoteReference(node), ": ", shouldInlineFootnote ? printChildren(path, options, print) : group([align(" ".repeat(4), printChildren(path, options, print, {
            processor: (childPath, index) => index === 0 ? group([softline, print()]) : print()
          })), nextNode && nextNode.type === "footnoteDefinition" ? softline : ""])];
        }
        case "table":
          return printTable(path, options, print);
        case "tableCell":
          return printChildren(path, options, print);
        case "break":
          return /\s/.test(options.originalText[node.position.start.offset]) ? ["  ", markAsRoot(literalline)] : ["\\", hardline];
        case "liquidNode":
          return replaceTextEndOfLine(node.value, hardline);
        case "importExport":
          return [node.value, hardline];
        case "esComment":
          return ["{/* ", node.value, " */}"];
        case "jsx":
          return node.value;
        case "math":
          return ["$$", hardline, node.value ? [...replaceTextEndOfLine(node.value, hardline), hardline] : "", "$$"];
        case "inlineMath": {
          return options.originalText.slice(locStart(node), locEnd(node));
        }
        case "tableRow":
        case "listItem":
        default:
          throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);
      }
    }
    function printListItem(path, options, print, listPrefix) {
      const node = path.getValue();
      const prefix = node.checked === null ? "" : node.checked ? "[x] " : "[ ] ";
      return [prefix, printChildren(path, options, print, {
        processor: (childPath, index) => {
          if (index === 0 && childPath.getValue().type !== "list") {
            return align(" ".repeat(prefix.length), print());
          }
          const alignment = " ".repeat(clamp(options.tabWidth - listPrefix.length, 0, 3));
          return [alignment, align(alignment, print())];
        }
      })];
    }
    function alignListPrefix(prefix, options) {
      const additionalSpaces = getAdditionalSpaces();
      return prefix + " ".repeat(additionalSpaces >= 4 ? 0 : additionalSpaces);
      function getAdditionalSpaces() {
        const restSpaces = prefix.length % options.tabWidth;
        return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;
      }
    }
    function getNthListSiblingIndex(node, parentNode) {
      return getNthSiblingIndex(node, parentNode, (siblingNode) => siblingNode.ordered === node.ordered);
    }
    function getNthSiblingIndex(node, parentNode, condition) {
      let index = -1;
      for (const childNode of parentNode.children) {
        if (childNode.type === node.type && condition(childNode)) {
          index++;
        } else {
          index = -1;
        }
        if (childNode === node) {
          return index;
        }
      }
    }
    function getAncestorCounter(path, typeOrTypes) {
      const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];
      let counter = -1;
      let ancestorNode;
      while (ancestorNode = path.getParentNode(++counter)) {
        if (types.includes(ancestorNode.type)) {
          return counter;
        }
      }
      return -1;
    }
    function getAncestorNode(path, typeOrTypes) {
      const counter = getAncestorCounter(path, typeOrTypes);
      return counter === -1 ? null : path.getParentNode(counter);
    }
    function printLine(path, value, options) {
      if (options.proseWrap === "preserve" && value === "\n") {
        return hardline;
      }
      const isBreakable = options.proseWrap === "always" && !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);
      return value !== "" ? isBreakable ? line : " " : isBreakable ? softline : "";
    }
    function printTable(path, options, print) {
      const node = path.getValue();
      const columnMaxWidths = [];
      const contents = path.map((rowPath) => rowPath.map((cellPath, columnIndex) => {
        const text = printDocToString(print(), options).formatted;
        const width = getStringWidth(text);
        columnMaxWidths[columnIndex] = Math.max(columnMaxWidths[columnIndex] || 3, width);
        return {
          text,
          width
        };
      }, "children"), "children");
      const alignedTable = printTableContents(false);
      if (options.proseWrap !== "never") {
        return [breakParent, alignedTable];
      }
      const compactTable = printTableContents(true);
      return [breakParent, group(ifBreak(compactTable, alignedTable))];
      function printTableContents(isCompact) {
        const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];
        if (contents.length > 1) {
          parts.push(join(hardlineWithoutBreakParent, contents.slice(1).map((rowContents) => printRow(rowContents, isCompact))));
        }
        return join(hardlineWithoutBreakParent, parts);
      }
      function printAlign(isCompact) {
        const align2 = columnMaxWidths.map((width, index) => {
          const align3 = node.align[index];
          const first = align3 === "center" || align3 === "left" ? ":" : "-";
          const last = align3 === "center" || align3 === "right" ? ":" : "-";
          const middle = isCompact ? "-" : "-".repeat(width - 2);
          return `${first}${middle}${last}`;
        });
        return `| ${align2.join(" | ")} |`;
      }
      function printRow(rowContents, isCompact) {
        const columns = rowContents.map(({
          text,
          width
        }, columnIndex) => {
          if (isCompact) {
            return text;
          }
          const spaces = columnMaxWidths[columnIndex] - width;
          const align2 = node.align[columnIndex];
          let before = 0;
          if (align2 === "right") {
            before = spaces;
          } else if (align2 === "center") {
            before = Math.floor(spaces / 2);
          }
          const after = spaces - before;
          return `${" ".repeat(before)}${text}${" ".repeat(after)}`;
        });
        return `| ${columns.join(" | ")} |`;
      }
    }
    function printRoot(path, options, print) {
      const ignoreRanges = [];
      let ignoreStart = null;
      const {
        children
      } = path.getValue();
      for (const [index, childNode] of children.entries()) {
        switch (isPrettierIgnore(childNode)) {
          case "start":
            if (ignoreStart === null) {
              ignoreStart = {
                index,
                offset: childNode.position.end.offset
              };
            }
            break;
          case "end":
            if (ignoreStart !== null) {
              ignoreRanges.push({
                start: ignoreStart,
                end: {
                  index,
                  offset: childNode.position.start.offset
                }
              });
              ignoreStart = null;
            }
            break;
          default:
            break;
        }
      }
      return printChildren(path, options, print, {
        processor: (childPath, index) => {
          if (ignoreRanges.length > 0) {
            const ignoreRange = ignoreRanges[0];
            if (index === ignoreRange.start.index) {
              return [printIgnoreComment(children[ignoreRange.start.index]), options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), printIgnoreComment(children[ignoreRange.end.index])];
            }
            if (ignoreRange.start.index < index && index < ignoreRange.end.index) {
              return false;
            }
            if (index === ignoreRange.end.index) {
              ignoreRanges.shift();
              return false;
            }
          }
          return print();
        }
      });
    }
    function printChildren(path, options, print, events = {}) {
      const {
        postprocessor
      } = events;
      const processor = events.processor || (() => print());
      const node = path.getValue();
      const parts = [];
      let lastChildNode;
      path.each((childPath, index) => {
        const childNode = childPath.getValue();
        const result = processor(childPath, index);
        if (result !== false) {
          const data = {
            parts,
            prevNode: lastChildNode,
            parentNode: node,
            options
          };
          if (shouldPrePrintHardline(childNode, data)) {
            parts.push(hardline);
            if (lastChildNode && TRAILING_HARDLINE_NODES.has(lastChildNode.type)) {
              if (shouldPrePrintTripleHardline(childNode, data)) {
                parts.push(hardline);
              }
            } else {
              if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {
                parts.push(hardline);
              }
              if (shouldPrePrintTripleHardline(childNode, data)) {
                parts.push(hardline);
              }
            }
          }
          parts.push(result);
          lastChildNode = childNode;
        }
      }, "children");
      return postprocessor ? postprocessor(parts) : parts;
    }
    function printIgnoreComment(node) {
      if (node.type === "html") {
        return node.value;
      }
      if (node.type === "paragraph" && Array.isArray(node.children) && node.children.length === 1 && node.children[0].type === "esComment") {
        return ["{/* ", node.children[0].value, " */}"];
      }
    }
    function getLastDescendantNode(node) {
      let current = node;
      while (isNonEmptyArray(current.children)) {
        current = getLast(current.children);
      }
      return current;
    }
    function isPrettierIgnore(node) {
      let match;
      if (node.type === "html") {
        match = node.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
      } else {
        let comment;
        if (node.type === "esComment") {
          comment = node;
        } else if (node.type === "paragraph" && node.children.length === 1 && node.children[0].type === "esComment") {
          comment = node.children[0];
        }
        if (comment) {
          match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);
        }
      }
      return match ? match[1] || "next" : false;
    }
    function shouldPrePrintHardline(node, data) {
      const isFirstNode = data.parts.length === 0;
      const isInlineNode = INLINE_NODE_TYPES.includes(node.type);
      const isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES.includes(data.parentNode.type);
      return !isFirstNode && !isInlineNode && !isInlineHTML;
    }
    function shouldPrePrintDoubleHardline(node, data) {
      var _data$prevNode, _data$prevNode2, _data$prevNode3;
      const isSequence = (data.prevNode && data.prevNode.type) === node.type;
      const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);
      const isInTightListItem = data.parentNode.type === "listItem" && !data.parentNode.loose;
      const isPrevNodeLooseListItem = ((_data$prevNode = data.prevNode) === null || _data$prevNode === void 0 ? void 0 : _data$prevNode.type) === "listItem" && data.prevNode.loose;
      const isPrevNodePrettierIgnore = isPrettierIgnore(data.prevNode) === "next";
      const isBlockHtmlWithoutBlankLineBetweenPrevHtml = node.type === "html" && ((_data$prevNode2 = data.prevNode) === null || _data$prevNode2 === void 0 ? void 0 : _data$prevNode2.type) === "html" && data.prevNode.position.end.line + 1 === node.position.start.line;
      const isHtmlDirectAfterListItem = node.type === "html" && data.parentNode.type === "listItem" && ((_data$prevNode3 = data.prevNode) === null || _data$prevNode3 === void 0 ? void 0 : _data$prevNode3.type) === "paragraph" && data.prevNode.position.end.line + 1 === node.position.start.line;
      return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isHtmlDirectAfterListItem);
    }
    function shouldPrePrintTripleHardline(node, data) {
      const isPrevNodeList = data.prevNode && data.prevNode.type === "list";
      const isIndentedCode = node.type === "code" && node.isIndented;
      return isPrevNodeList && isIndentedCode;
    }
    function shouldRemainTheSameContent(path) {
      const ancestorNode = getAncestorNode(path, ["linkReference", "imageReference"]);
      return ancestorNode && (ancestorNode.type !== "linkReference" || ancestorNode.referenceType !== "full");
    }
    function printUrl(url, dangerousCharOrChars = []) {
      const dangerousChars = [" ", ...Array.isArray(dangerousCharOrChars) ? dangerousCharOrChars : [dangerousCharOrChars]];
      return new RegExp(dangerousChars.map((x) => `\\${x}`).join("|")).test(url) ? `<${url}>` : url;
    }
    function printTitle(title, options, printSpace = true) {
      if (!title) {
        return "";
      }
      if (printSpace) {
        return " " + printTitle(title, options, false);
      }
      title = title.replace(/\\(["')])/g, "$1");
      if (title.includes('"') && title.includes("'") && !title.includes(")")) {
        return `(${title})`;
      }
      const singleCount = title.split("'").length - 1;
      const doubleCount = title.split('"').length - 1;
      const quote = singleCount > doubleCount ? '"' : doubleCount > singleCount ? "'" : options.singleQuote ? "'" : '"';
      title = title.replace(/\\/, "\\\\");
      title = title.replace(new RegExp(`(${quote})`, "g"), "\\$1");
      return `${quote}${title}${quote}`;
    }
    function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
    }
    function hasPrettierIgnore(path) {
      const index = Number(path.getName());
      if (index === 0) {
        return false;
      }
      const prevNode = path.getParentNode().children[index - 1];
      return isPrettierIgnore(prevNode) === "next";
    }
    function printLinkReference(node) {
      return `[${collapseWhiteSpace(node.label)}]`;
    }
    function printFootnoteReference(node) {
      return `[^${node.label}]`;
    }
    module2.exports = {
      preprocess,
      print: genericPrint,
      embed,
      massageAstNode: clean,
      hasPrettierIgnore,
      insertPragma
    };
  }
});
var require_options5 = __commonJS2({
  "src/language-markdown/options.js"(exports2, module2) {
    "use strict";
    var commonOptions = require_common_options();
    module2.exports = {
      proseWrap: commonOptions.proseWrap,
      singleQuote: commonOptions.singleQuote
    };
  }
});
var require_parsers5 = __commonJS2({
  "src/language-markdown/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get remark() {
        return require("./parser-markdown.js").parsers.remark;
      },
      get markdown() {
        return require("./parser-markdown.js").parsers.remark;
      },
      get mdx() {
        return require("./parser-markdown.js").parsers.mdx;
      }
    };
  }
});
var require_Markdown = __commonJS2({
  "node_modules/linguist-languages/data/Markdown.json"(exports2, module2) {
    module2.exports = {
      name: "Markdown",
      type: "prose",
      color: "#083fa1",
      aliases: ["pandoc"],
      aceMode: "markdown",
      codemirrorMode: "gfm",
      codemirrorMimeType: "text/x-gfm",
      wrap: true,
      extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"],
      filenames: ["contents.lr"],
      tmScope: "source.gfm",
      languageId: 222
    };
  }
});
var require_language_markdown = __commonJS2({
  "src/language-markdown/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var printer = require_printer_markdown();
    var options = require_options5();
    var parsers = require_parsers5();
    var languages = [createLanguage(require_Markdown(), (data) => ({
      since: "1.8.0",
      parsers: ["markdown"],
      vscodeLanguageIds: ["markdown"],
      filenames: [...data.filenames, "README"],
      extensions: data.extensions.filter((extension) => extension !== ".mdx")
    })), createLanguage(require_Markdown(), () => ({
      name: "MDX",
      since: "1.15.0",
      parsers: ["mdx"],
      vscodeLanguageIds: ["mdx"],
      filenames: [],
      extensions: [".mdx"]
    }))];
    var printers = {
      mdast: printer
    };
    module2.exports = {
      languages,
      options,
      printers,
      parsers
    };
  }
});
var require_clean5 = __commonJS2({
  "src/language-html/clean.js"(exports2, module2) {
    "use strict";
    var {
      isFrontMatterNode
    } = require_util();
    var ignoredProperties = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
    function clean(ast, newNode) {
      if (ast.type === "text" || ast.type === "comment") {
        return null;
      }
      if (isFrontMatterNode(ast) || ast.type === "yaml" || ast.type === "toml") {
        return null;
      }
      if (ast.type === "attribute") {
        delete newNode.value;
      }
      if (ast.type === "docType") {
        delete newNode.value;
      }
    }
    clean.ignoredProperties = ignoredProperties;
    module2.exports = clean;
  }
});
var require_constants_evaluate2 = __commonJS2({
  "src/language-html/constants.evaluate.js"(exports2, module2) {
    module2.exports = {
      CSS_DISPLAY_TAGS: {
        area: "none",
        base: "none",
        basefont: "none",
        datalist: "none",
        head: "none",
        link: "none",
        meta: "none",
        noembed: "none",
        noframes: "none",
        param: "block",
        rp: "none",
        script: "block",
        source: "block",
        style: "none",
        template: "inline",
        track: "block",
        title: "none",
        html: "block",
        body: "block",
        address: "block",
        blockquote: "block",
        center: "block",
        div: "block",
        figure: "block",
        figcaption: "block",
        footer: "block",
        form: "block",
        header: "block",
        hr: "block",
        legend: "block",
        listing: "block",
        main: "block",
        p: "block",
        plaintext: "block",
        pre: "block",
        xmp: "block",
        slot: "contents",
        ruby: "ruby",
        rt: "ruby-text",
        article: "block",
        aside: "block",
        h1: "block",
        h2: "block",
        h3: "block",
        h4: "block",
        h5: "block",
        h6: "block",
        hgroup: "block",
        nav: "block",
        section: "block",
        dir: "block",
        dd: "block",
        dl: "block",
        dt: "block",
        ol: "block",
        ul: "block",
        li: "list-item",
        table: "table",
        caption: "table-caption",
        colgroup: "table-column-group",
        col: "table-column",
        thead: "table-header-group",
        tbody: "table-row-group",
        tfoot: "table-footer-group",
        tr: "table-row",
        td: "table-cell",
        th: "table-cell",
        fieldset: "block",
        button: "inline-block",
        details: "block",
        summary: "block",
        dialog: "block",
        meter: "inline-block",
        progress: "inline-block",
        object: "inline-block",
        video: "inline-block",
        audio: "inline-block",
        select: "inline-block",
        option: "block",
        optgroup: "block"
      },
      CSS_DISPLAY_DEFAULT: "inline",
      CSS_WHITE_SPACE_TAGS: {
        listing: "pre",
        plaintext: "pre",
        pre: "pre",
        xmp: "pre",
        nobr: "nowrap",
        table: "initial",
        textarea: "pre-wrap"
      },
      CSS_WHITE_SPACE_DEFAULT: "normal"
    };
  }
});
var require_is_unknown_namespace = __commonJS2({
  "src/language-html/utils/is-unknown-namespace.js"(exports2, module2) {
    "use strict";
    function isUnknownNamespace(node) {
      return node.type === "element" && !node.hasExplicitNamespace && !["html", "svg"].includes(node.namespace);
    }
    module2.exports = isUnknownNamespace;
  }
});
var require_utils11 = __commonJS2({
  "src/language-html/utils/index.js"(exports2, module2) {
    "use strict";
    var {
      inferParserByLanguage,
      isFrontMatterNode
    } = require_util();
    var {
      builders: {
        line,
        hardline,
        join
      },
      utils: {
        getDocParts,
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var {
      CSS_DISPLAY_TAGS,
      CSS_DISPLAY_DEFAULT,
      CSS_WHITE_SPACE_TAGS,
      CSS_WHITE_SPACE_DEFAULT
    } = require_constants_evaluate2();
    var isUnknownNamespace = require_is_unknown_namespace();
    var HTML_WHITESPACE = /* @__PURE__ */ new Set(["	", "\n", "\f", "\r", " "]);
    var htmlTrimStart = (string) => string.replace(/^[\t\n\f\r ]+/, "");
    var htmlTrimEnd = (string) => string.replace(/[\t\n\f\r ]+$/, "");
    var htmlTrim = (string) => htmlTrimStart(htmlTrimEnd(string));
    var htmlTrimLeadingBlankLines = (string) => string.replace(/^[\t\f\r ]*\n/g, "");
    var htmlTrimPreserveIndentation = (string) => htmlTrimLeadingBlankLines(htmlTrimEnd(string));
    var splitByHtmlWhitespace = (string) => string.split(/[\t\n\f\r ]+/);
    var getLeadingHtmlWhitespace = (string) => string.match(/^[\t\n\f\r ]*/)[0];
    var getLeadingAndTrailingHtmlWhitespace = (string) => {
      const [, leadingWhitespace, text, trailingWhitespace] = string.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
      return {
        leadingWhitespace,
        trailingWhitespace,
        text
      };
    };
    var hasHtmlWhitespace = (string) => /[\t\n\f\r ]/.test(string);
    function shouldPreserveContent(node, options) {
      if (node.type === "ieConditionalComment" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {
        return true;
      }
      if (node.type === "ieConditionalComment" && !node.complete) {
        return true;
      }
      if (isPreLikeNode(node) && node.children.some((child) => child.type !== "text" && child.type !== "interpolation")) {
        return true;
      }
      if (isVueNonHtmlBlock(node, options) && !isScriptLikeTag(node) && node.type !== "interpolation") {
        return true;
      }
      return false;
    }
    function hasPrettierIgnore(node) {
      if (node.type === "attribute") {
        return false;
      }
      if (!node.parent) {
        return false;
      }
      if (!node.prev) {
        return false;
      }
      return isPrettierIgnore(node.prev);
    }
    function isPrettierIgnore(node) {
      return node.type === "comment" && node.value.trim() === "prettier-ignore";
    }
    function isTextLikeNode(node) {
      return node.type === "text" || node.type === "comment";
    }
    function isScriptLikeTag(node) {
      return node.type === "element" && (node.fullName === "script" || node.fullName === "style" || node.fullName === "svg:style" || isUnknownNamespace(node) && (node.name === "script" || node.name === "style"));
    }
    function canHaveInterpolation(node) {
      return node.children && !isScriptLikeTag(node);
    }
    function isWhitespaceSensitiveNode(node) {
      return isScriptLikeTag(node) || node.type === "interpolation" || isIndentationSensitiveNode(node);
    }
    function isIndentationSensitiveNode(node) {
      return getNodeCssStyleWhiteSpace(node).startsWith("pre");
    }
    function isLeadingSpaceSensitiveNode(node, options) {
      const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();
      if (isLeadingSpaceSensitive && !node.prev && node.parent && node.parent.tagDefinition && node.parent.tagDefinition.ignoreFirstLf) {
        return node.type === "interpolation";
      }
      return isLeadingSpaceSensitive;
      function _isLeadingSpaceSensitiveNode() {
        if (isFrontMatterNode(node)) {
          return false;
        }
        if ((node.type === "text" || node.type === "interpolation") && node.prev && (node.prev.type === "text" || node.prev.type === "interpolation")) {
          return true;
        }
        if (!node.parent || node.parent.cssDisplay === "none") {
          return false;
        }
        if (isPreLikeNode(node.parent)) {
          return true;
        }
        if (!node.prev && (node.parent.type === "root" || isPreLikeNode(node) && node.parent || isScriptLikeTag(node.parent) || isVueCustomBlock(node.parent, options) || !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
          return false;
        }
        if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {
          return false;
        }
        return true;
      }
    }
    function isTrailingSpaceSensitiveNode(node, options) {
      if (isFrontMatterNode(node)) {
        return false;
      }
      if ((node.type === "text" || node.type === "interpolation") && node.next && (node.next.type === "text" || node.next.type === "interpolation")) {
        return true;
      }
      if (!node.parent || node.parent.cssDisplay === "none") {
        return false;
      }
      if (isPreLikeNode(node.parent)) {
        return true;
      }
      if (!node.next && (node.parent.type === "root" || isPreLikeNode(node) && node.parent || isScriptLikeTag(node.parent) || isVueCustomBlock(node.parent, options) || !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
        return false;
      }
      if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {
        return false;
      }
      return true;
    }
    function isDanglingSpaceSensitiveNode(node) {
      return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);
    }
    function forceNextEmptyLine(node) {
      return isFrontMatterNode(node) || node.next && node.sourceSpan.end && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;
    }
    function forceBreakContent(node) {
      return forceBreakChildren(node) || node.type === "element" && node.children.length > 0 && (["body", "script", "style"].includes(node.name) || node.children.some((child) => hasNonTextChild(child))) || node.firstChild && node.firstChild === node.lastChild && node.firstChild.type !== "text" && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));
    }
    function forceBreakChildren(node) {
      return node.type === "element" && node.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(node.name) || node.cssDisplay.startsWith("table") && node.cssDisplay !== "table-cell");
    }
    function preferHardlineAsLeadingSpaces(node) {
      return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);
    }
    function preferHardlineAsTrailingSpaces(node) {
      return preferHardlineAsSurroundingSpaces(node) || node.type === "element" && node.fullName === "br" || hasSurroundingLineBreak(node);
    }
    function hasSurroundingLineBreak(node) {
      return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);
    }
    function hasLeadingLineBreak(node) {
      return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === "root" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);
    }
    function hasTrailingLineBreak(node) {
      return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === "root" || node.parent.endSourceSpan && node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);
    }
    function preferHardlineAsSurroundingSpaces(node) {
      switch (node.type) {
        case "ieConditionalComment":
        case "comment":
        case "directive":
          return true;
        case "element":
          return ["script", "select"].includes(node.name);
      }
      return false;
    }
    function getLastDescendant(node) {
      return node.lastChild ? getLastDescendant(node.lastChild) : node;
    }
    function hasNonTextChild(node) {
      return node.children && node.children.some((child) => child.type !== "text");
    }
    function _inferScriptParser(node) {
      const {
        type,
        lang
      } = node.attrMap;
      if (type === "module" || type === "text/javascript" || type === "text/babel" || type === "application/javascript" || lang === "jsx") {
        return "babel";
      }
      if (type === "application/x-typescript" || lang === "ts" || lang === "tsx") {
        return "typescript";
      }
      if (type === "text/markdown") {
        return "markdown";
      }
      if (type === "text/html") {
        return "html";
      }
      if (type && (type.endsWith("json") || type.endsWith("importmap")) || type === "speculationrules") {
        return "json";
      }
      if (type === "text/x-handlebars-template") {
        return "glimmer";
      }
    }
    function inferStyleParser(node, options) {
      const {
        lang
      } = node.attrMap;
      if (!lang || lang === "postcss" || lang === "css") {
        return "css";
      }
      if (lang === "scss") {
        return "scss";
      }
      if (lang === "less") {
        return "less";
      }
      if (lang === "stylus") {
        return inferParserByLanguage("stylus", options);
      }
    }
    function inferScriptParser(node, options) {
      if (node.name === "script" && !node.attrMap.src) {
        if (!node.attrMap.lang && !node.attrMap.type) {
          return "babel";
        }
        return _inferScriptParser(node);
      }
      if (node.name === "style") {
        return inferStyleParser(node, options);
      }
      if (options && isVueNonHtmlBlock(node, options)) {
        return _inferScriptParser(node) || !("src" in node.attrMap) && inferParserByLanguage(node.attrMap.lang, options);
      }
    }
    function isBlockLikeCssDisplay(cssDisplay) {
      return cssDisplay === "block" || cssDisplay === "list-item" || cssDisplay.startsWith("table");
    }
    function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {
      return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
    }
    function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {
      return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
    }
    function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {
      return !isBlockLikeCssDisplay(cssDisplay);
    }
    function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {
      return !isBlockLikeCssDisplay(cssDisplay);
    }
    function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {
      return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
    }
    function isPreLikeNode(node) {
      return getNodeCssStyleWhiteSpace(node).startsWith("pre");
    }
    function countParents(path, predicate) {
      let counter = 0;
      for (let i = path.stack.length - 1; i >= 0; i--) {
        const value = path.stack[i];
        if (value && typeof value === "object" && !Array.isArray(value) && predicate(value)) {
          counter++;
        }
      }
      return counter;
    }
    function hasParent(node, fn) {
      let current = node;
      while (current) {
        if (fn(current)) {
          return true;
        }
        current = current.parent;
      }
      return false;
    }
    function getNodeCssStyleDisplay(node, options) {
      if (node.prev && node.prev.type === "comment") {
        const match = node.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
        if (match) {
          return match[1];
        }
      }
      let isInSvgForeignObject = false;
      if (node.type === "element" && node.namespace === "svg") {
        if (hasParent(node, (parent) => parent.fullName === "svg:foreignObject")) {
          isInSvgForeignObject = true;
        } else {
          return node.name === "svg" ? "inline-block" : "block";
        }
      }
      switch (options.htmlWhitespaceSensitivity) {
        case "strict":
          return "inline";
        case "ignore":
          return "block";
        default: {
          if (options.parser === "vue" && node.parent && node.parent.type === "root") {
            return "block";
          }
          return node.type === "element" && (!node.namespace || isInSvgForeignObject || isUnknownNamespace(node)) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;
        }
      }
    }
    function getNodeCssStyleWhiteSpace(node) {
      return node.type === "element" && (!node.namespace || isUnknownNamespace(node)) && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;
    }
    function getMinIndentation(text) {
      let minIndentation = Number.POSITIVE_INFINITY;
      for (const lineText of text.split("\n")) {
        if (lineText.length === 0) {
          continue;
        }
        if (!HTML_WHITESPACE.has(lineText[0])) {
          return 0;
        }
        const indentation = getLeadingHtmlWhitespace(lineText).length;
        if (lineText.length === indentation) {
          continue;
        }
        if (indentation < minIndentation) {
          minIndentation = indentation;
        }
      }
      return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;
    }
    function dedentString(text, minIndent = getMinIndentation(text)) {
      return minIndent === 0 ? text : text.split("\n").map((lineText) => lineText.slice(minIndent)).join("\n");
    }
    function countChars(text, char) {
      let counter = 0;
      for (let i = 0; i < text.length; i++) {
        if (text[i] === char) {
          counter++;
        }
      }
      return counter;
    }
    function unescapeQuoteEntities(text) {
      return text.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
    }
    var vueRootElementsSet = /* @__PURE__ */ new Set(["template", "style", "script"]);
    function isVueCustomBlock(node, options) {
      return isVueSfcBlock(node, options) && !vueRootElementsSet.has(node.fullName);
    }
    function isVueSfcBlock(node, options) {
      return options.parser === "vue" && node.type === "element" && node.parent.type === "root" && node.fullName.toLowerCase() !== "html";
    }
    function isVueNonHtmlBlock(node, options) {
      return isVueSfcBlock(node, options) && (isVueCustomBlock(node, options) || node.attrMap.lang && node.attrMap.lang !== "html");
    }
    function isVueSlotAttribute(attribute) {
      const attributeName = attribute.fullName;
      return attributeName.charAt(0) === "#" || attributeName === "slot-scope" || attributeName === "v-slot" || attributeName.startsWith("v-slot:");
    }
    function isVueSfcBindingsAttribute(attribute, options) {
      const element = attribute.parent;
      if (!isVueSfcBlock(element, options)) {
        return false;
      }
      const tagName = element.fullName;
      const attributeName = attribute.fullName;
      return tagName === "script" && attributeName === "setup" || tagName === "style" && attributeName === "vars";
    }
    function getTextValueParts(node, value = node.value) {
      return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceTextEndOfLine(value) : replaceTextEndOfLine(dedentString(htmlTrimPreserveIndentation(value)), hardline) : getDocParts(join(line, splitByHtmlWhitespace(value)));
    }
    function isVueScriptTag(node, options) {
      return isVueSfcBlock(node, options) && node.name === "script";
    }
    module2.exports = {
      htmlTrim,
      htmlTrimPreserveIndentation,
      hasHtmlWhitespace,
      getLeadingAndTrailingHtmlWhitespace,
      canHaveInterpolation,
      countChars,
      countParents,
      dedentString,
      forceBreakChildren,
      forceBreakContent,
      forceNextEmptyLine,
      getLastDescendant,
      getNodeCssStyleDisplay,
      getNodeCssStyleWhiteSpace,
      hasPrettierIgnore,
      inferScriptParser,
      isVueCustomBlock,
      isVueNonHtmlBlock,
      isVueScriptTag,
      isVueSlotAttribute,
      isVueSfcBindingsAttribute,
      isVueSfcBlock,
      isDanglingSpaceSensitiveNode,
      isIndentationSensitiveNode,
      isLeadingSpaceSensitiveNode,
      isPreLikeNode,
      isScriptLikeTag,
      isTextLikeNode,
      isTrailingSpaceSensitiveNode,
      isWhitespaceSensitiveNode,
      isUnknownNamespace,
      preferHardlineAsLeadingSpaces,
      preferHardlineAsTrailingSpaces,
      shouldPreserveContent,
      unescapeQuoteEntities,
      getTextValueParts
    };
  }
});
var require_chars = __commonJS2({
  "node_modules/angular-html-parser/lib/compiler/src/chars.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.$EOF = 0;
    exports2.$BSPACE = 8;
    exports2.$TAB = 9;
    exports2.$LF = 10;
    exports2.$VTAB = 11;
    exports2.$FF = 12;
    exports2.$CR = 13;
    exports2.$SPACE = 32;
    exports2.$BANG = 33;
    exports2.$DQ = 34;
    exports2.$HASH = 35;
    exports2.$$ = 36;
    exports2.$PERCENT = 37;
    exports2.$AMPERSAND = 38;
    exports2.$SQ = 39;
    exports2.$LPAREN = 40;
    exports2.$RPAREN = 41;
    exports2.$STAR = 42;
    exports2.$PLUS = 43;
    exports2.$COMMA = 44;
    exports2.$MINUS = 45;
    exports2.$PERIOD = 46;
    exports2.$SLASH = 47;
    exports2.$COLON = 58;
    exports2.$SEMICOLON = 59;
    exports2.$LT = 60;
    exports2.$EQ = 61;
    exports2.$GT = 62;
    exports2.$QUESTION = 63;
    exports2.$0 = 48;
    exports2.$7 = 55;
    exports2.$9 = 57;
    exports2.$A = 65;
    exports2.$E = 69;
    exports2.$F = 70;
    exports2.$X = 88;
    exports2.$Z = 90;
    exports2.$LBRACKET = 91;
    exports2.$BACKSLASH = 92;
    exports2.$RBRACKET = 93;
    exports2.$CARET = 94;
    exports2.$_ = 95;
    exports2.$a = 97;
    exports2.$b = 98;
    exports2.$e = 101;
    exports2.$f = 102;
    exports2.$n = 110;
    exports2.$r = 114;
    exports2.$t = 116;
    exports2.$u = 117;
    exports2.$v = 118;
    exports2.$x = 120;
    exports2.$z = 122;
    exports2.$LBRACE = 123;
    exports2.$BAR = 124;
    exports2.$RBRACE = 125;
    exports2.$NBSP = 160;
    exports2.$PIPE = 124;
    exports2.$TILDA = 126;
    exports2.$AT = 64;
    exports2.$BT = 96;
    function isWhitespace(code) {
      return code >= exports2.$TAB && code <= exports2.$SPACE || code == exports2.$NBSP;
    }
    exports2.isWhitespace = isWhitespace;
    function isDigit(code) {
      return exports2.$0 <= code && code <= exports2.$9;
    }
    exports2.isDigit = isDigit;
    function isAsciiLetter(code) {
      return code >= exports2.$a && code <= exports2.$z || code >= exports2.$A && code <= exports2.$Z;
    }
    exports2.isAsciiLetter = isAsciiLetter;
    function isAsciiHexDigit(code) {
      return code >= exports2.$a && code <= exports2.$f || code >= exports2.$A && code <= exports2.$F || isDigit(code);
    }
    exports2.isAsciiHexDigit = isAsciiHexDigit;
    function isNewLine(code) {
      return code === exports2.$LF || code === exports2.$CR;
    }
    exports2.isNewLine = isNewLine;
    function isOctalDigit(code) {
      return exports2.$0 <= code && code <= exports2.$7;
    }
    exports2.isOctalDigit = isOctalDigit;
  }
});
var require_static_symbol = __commonJS2({
  "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var StaticSymbol = class {
      constructor(filePath, name, members) {
        this.filePath = filePath;
        this.name = name;
        this.members = members;
      }
      assertNoMembers() {
        if (this.members.length) {
          throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
        }
      }
    };
    exports2.StaticSymbol = StaticSymbol;
    var StaticSymbolCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      get(declarationFile, name, members) {
        members = members || [];
        const memberSuffix = members.length ? `.${members.join(".")}` : "";
        const key = `"${declarationFile}".${name}${memberSuffix}`;
        let result = this.cache.get(key);
        if (!result) {
          result = new StaticSymbol(declarationFile, name, members);
          this.cache.set(key, result);
        }
        return result;
      }
    };
    exports2.StaticSymbolCache = StaticSymbolCache;
  }
});
var require_util3 = __commonJS2({
  "node_modules/angular-html-parser/lib/compiler/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    function dashCaseToCamelCase(input) {
      return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
    }
    exports2.dashCaseToCamelCase = dashCaseToCamelCase;
    function splitAtColon(input, defaultValues) {
      return _splitAt(input, ":", defaultValues);
    }
    exports2.splitAtColon = splitAtColon;
    function splitAtPeriod(input, defaultValues) {
      return _splitAt(input, ".", defaultValues);
    }
    exports2.splitAtPeriod = splitAtPeriod;
    function _splitAt(input, character, defaultValues) {
      const characterIndex = input.indexOf(character);
      if (characterIndex == -1)
        return defaultValues;
      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
    }
    function visitValue(value, visitor, context) {
      if (Array.isArray(value)) {
        return visitor.visitArray(value, context);
      }
      if (isStrictStringMap(value)) {
        return visitor.visitStringMap(value, context);
      }
      if (value == null || typeof value == "string" || typeof value == "number" || typeof value == "boolean") {
        return visitor.visitPrimitive(value, context);
      }
      return visitor.visitOther(value, context);
    }
    exports2.visitValue = visitValue;
    function isDefined(val) {
      return val !== null && val !== void 0;
    }
    exports2.isDefined = isDefined;
    function noUndefined(val) {
      return val === void 0 ? null : val;
    }
    exports2.noUndefined = noUndefined;
    var ValueTransformer = class {
      visitArray(arr, context) {
        return arr.map((value) => visitValue(value, this, context));
      }
      visitStringMap(map, context) {
        const result = {};
        Object.keys(map).forEach((key) => {
          result[key] = visitValue(map[key], this, context);
        });
        return result;
      }
      visitPrimitive(value, context) {
        return value;
      }
      visitOther(value, context) {
        return value;
      }
    };
    exports2.ValueTransformer = ValueTransformer;
    exports2.SyncAsync = {
      assertSync: (value) => {
        if (isPromise(value)) {
          throw new Error(`Illegal state: value cannot be a promise`);
        }
        return value;
      },
      then: (value, cb) => {
        return isPromise(value) ? value.then(cb) : cb(value);
      },
      all: (syncAsyncValues) => {
        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;
      }
    };
    function error(msg) {
      throw new Error(`Internal Error: ${msg}`);
    }
    exports2.error = error;
    function syntaxError(msg, parseErrors) {
      const error2 = Error(msg);
      error2[ERROR_SYNTAX_ERROR] = true;
      if (parseErrors)
        error2[ERROR_PARSE_ERRORS] = parseErrors;
      return error2;
    }
    exports2.syntaxError = syntaxError;
    var ERROR_SYNTAX_ERROR = "ngSyntaxError";
    var ERROR_PARSE_ERRORS = "ngParseErrors";
    function isSyntaxError(error2) {
      return error2[ERROR_SYNTAX_ERROR];
    }
    exports2.isSyntaxError = isSyntaxError;
    function getParseErrors(error2) {
      return error2[ERROR_PARSE_ERRORS] || [];
    }
    exports2.getParseErrors = getParseErrors;
    function escapeRegExp(s) {
      return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    }
    exports2.escapeRegExp = escapeRegExp;
    var STRING_MAP_PROTO = Object.getPrototypeOf({});
    function isStrictStringMap(obj) {
      return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
    }
    function utf8Encode(str) {
      let encoded = "";
      for (let index = 0; index < str.length; index++) {
        let codePoint = str.charCodeAt(index);
        if (codePoint >= 55296 && codePoint <= 56319 && str.length > index + 1) {
          const low = str.charCodeAt(index + 1);
          if (low >= 56320 && low <= 57343) {
            index++;
            codePoint = (codePoint - 55296 << 10) + low - 56320 + 65536;
          }
        }
        if (codePoint <= 127) {
          encoded += String.fromCharCode(codePoint);
        } else if (codePoint <= 2047) {
          encoded += String.fromCharCode(codePoint >> 6 & 31 | 192, codePoint & 63 | 128);
        } else if (codePoint <= 65535) {
          encoded += String.fromCharCode(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint <= 2097151) {
          encoded += String.fromCharCode(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        }
      }
      return encoded;
    }
    exports2.utf8Encode = utf8Encode;
    function stringify(token) {
      if (typeof token === "string") {
        return token;
      }
      if (token instanceof Array) {
        return "[" + token.map(stringify).join(", ") + "]";
      }
      if (token == null) {
        return "" + token;
      }
      if (token.overriddenName) {
        return `${token.overriddenName}`;
      }
      if (token.name) {
        return `${token.name}`;
      }
      if (!token.toString) {
        return "object";
      }
      const res = token.toString();
      if (res == null) {
        return "" + res;
      }
      const newLineIndex = res.indexOf("\n");
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    exports2.stringify = stringify;
    function resolveForwardRef(type) {
      if (typeof type === "function" && type.hasOwnProperty("__forward_ref__")) {
        return type();
      } else {
        return type;
      }
    }
    exports2.resolveForwardRef = resolveForwardRef;
    function isPromise(obj) {
      return !!obj && typeof obj.then === "function";
    }
    exports2.isPromise = isPromise;
    var Version = class {
      constructor(full) {
        this.full = full;
        const splits = full.split(".");
        this.major = splits[0];
        this.minor = splits[1];
        this.patch = splits.slice(2).join(".");
      }
    };
    exports2.Version = Version;
    var __window = typeof window !== "undefined" && window;
    var __self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
    var __global = typeof global !== "undefined" && global;
    var _global = __global || __window || __self;
    exports2.global = _global;
  }
});
var require_compile_metadata = __commonJS2({
  "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var static_symbol_1 = require_static_symbol();
    var util_1 = require_util3();
    var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
    function sanitizeIdentifier(name) {
      return name.replace(/\W/g, "_");
    }
    exports2.sanitizeIdentifier = sanitizeIdentifier;
    var _anonymousTypeIndex = 0;
    function identifierName(compileIdentifier) {
      if (!compileIdentifier || !compileIdentifier.reference) {
        return null;
      }
      const ref = compileIdentifier.reference;
      if (ref instanceof static_symbol_1.StaticSymbol) {
        return ref.name;
      }
      if (ref["__anonymousType"]) {
        return ref["__anonymousType"];
      }
      let identifier = util_1.stringify(ref);
      if (identifier.indexOf("(") >= 0) {
        identifier = `anonymous_${_anonymousTypeIndex++}`;
        ref["__anonymousType"] = identifier;
      } else {
        identifier = sanitizeIdentifier(identifier);
      }
      return identifier;
    }
    exports2.identifierName = identifierName;
    function identifierModuleUrl(compileIdentifier) {
      const ref = compileIdentifier.reference;
      if (ref instanceof static_symbol_1.StaticSymbol) {
        return ref.filePath;
      }
      return `./${util_1.stringify(ref)}`;
    }
    exports2.identifierModuleUrl = identifierModuleUrl;
    function viewClassName(compType, embeddedTemplateIndex) {
      return `View_${identifierName({
        reference: compType
      })}_${embeddedTemplateIndex}`;
    }
    exports2.viewClassName = viewClassName;
    function rendererTypeName(compType) {
      return `RenderType_${identifierName({
        reference: compType
      })}`;
    }
    exports2.rendererTypeName = rendererTypeName;
    function hostViewClassName(compType) {
      return `HostView_${identifierName({
        reference: compType
      })}`;
    }
    exports2.hostViewClassName = hostViewClassName;
    function componentFactoryName(compType) {
      return `${identifierName({
        reference: compType
      })}NgFactory`;
    }
    exports2.componentFactoryName = componentFactoryName;
    var CompileSummaryKind;
    (function(CompileSummaryKind2) {
      CompileSummaryKind2[CompileSummaryKind2["Pipe"] = 0] = "Pipe";
      CompileSummaryKind2[CompileSummaryKind2["Directive"] = 1] = "Directive";
      CompileSummaryKind2[CompileSummaryKind2["NgModule"] = 2] = "NgModule";
      CompileSummaryKind2[CompileSummaryKind2["Injectable"] = 3] = "Injectable";
    })(CompileSummaryKind = exports2.CompileSummaryKind || (exports2.CompileSummaryKind = {}));
    function tokenName(token) {
      return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);
    }
    exports2.tokenName = tokenName;
    function tokenReference(token) {
      if (token.identifier != null) {
        return token.identifier.reference;
      } else {
        return token.value;
      }
    }
    exports2.tokenReference = tokenReference;
    var CompileStylesheetMetadata = class {
      constructor({
        moduleUrl,
        styles,
        styleUrls
      } = {}) {
        this.moduleUrl = moduleUrl || null;
        this.styles = _normalizeArray(styles);
        this.styleUrls = _normalizeArray(styleUrls);
      }
    };
    exports2.CompileStylesheetMetadata = CompileStylesheetMetadata;
    var CompileTemplateMetadata = class {
      constructor({
        encapsulation,
        template,
        templateUrl,
        htmlAst,
        styles,
        styleUrls,
        externalStylesheets,
        animations,
        ngContentSelectors,
        interpolation,
        isInline,
        preserveWhitespaces
      }) {
        this.encapsulation = encapsulation;
        this.template = template;
        this.templateUrl = templateUrl;
        this.htmlAst = htmlAst;
        this.styles = _normalizeArray(styles);
        this.styleUrls = _normalizeArray(styleUrls);
        this.externalStylesheets = _normalizeArray(externalStylesheets);
        this.animations = animations ? flatten(animations) : [];
        this.ngContentSelectors = ngContentSelectors || [];
        if (interpolation && interpolation.length != 2) {
          throw new Error(`'interpolation' should have a start and an end symbol.`);
        }
        this.interpolation = interpolation;
        this.isInline = isInline;
        this.preserveWhitespaces = preserveWhitespaces;
      }
      toSummary() {
        return {
          ngContentSelectors: this.ngContentSelectors,
          encapsulation: this.encapsulation,
          styles: this.styles,
          animations: this.animations
        };
      }
    };
    exports2.CompileTemplateMetadata = CompileTemplateMetadata;
    var CompileDirectiveMetadata = class {
      static create({
        isHost,
        type,
        isComponent,
        selector,
        exportAs,
        changeDetection,
        inputs,
        outputs,
        host,
        providers,
        viewProviders,
        queries,
        guards,
        viewQueries,
        entryComponents,
        template,
        componentViewType,
        rendererType,
        componentFactory
      }) {
        const hostListeners = {};
        const hostProperties = {};
        const hostAttributes = {};
        if (host != null) {
          Object.keys(host).forEach((key) => {
            const value = host[key];
            const matches = key.match(HOST_REG_EXP);
            if (matches === null) {
              hostAttributes[key] = value;
            } else if (matches[1] != null) {
              hostProperties[matches[1]] = value;
            } else if (matches[2] != null) {
              hostListeners[matches[2]] = value;
            }
          });
        }
        const inputsMap = {};
        if (inputs != null) {
          inputs.forEach((bindConfig) => {
            const parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
            inputsMap[parts[0]] = parts[1];
          });
        }
        const outputsMap = {};
        if (outputs != null) {
          outputs.forEach((bindConfig) => {
            const parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
            outputsMap[parts[0]] = parts[1];
          });
        }
        return new CompileDirectiveMetadata({
          isHost,
          type,
          isComponent: !!isComponent,
          selector,
          exportAs,
          changeDetection,
          inputs: inputsMap,
          outputs: outputsMap,
          hostListeners,
          hostProperties,
          hostAttributes,
          providers,
          viewProviders,
          queries,
          guards,
          viewQueries,
          entryComponents,
          template,
          componentViewType,
          rendererType,
          componentFactory
        });
      }
      constructor({
        isHost,
        type,
        isComponent,
        selector,
        exportAs,
        changeDetection,
        inputs,
        outputs,
        hostListeners,
        hostProperties,
        hostAttributes,
        providers,
        viewProviders,
        queries,
        guards,
        viewQueries,
        entryComponents,
        template,
        componentViewType,
        rendererType,
        componentFactory
      }) {
        this.isHost = !!isHost;
        this.type = type;
        this.isComponent = isComponent;
        this.selector = selector;
        this.exportAs = exportAs;
        this.changeDetection = changeDetection;
        this.inputs = inputs;
        this.outputs = outputs;
        this.hostListeners = hostListeners;
        this.hostProperties = hostProperties;
        this.hostAttributes = hostAttributes;
        this.providers = _normalizeArray(providers);
        this.viewProviders = _normalizeArray(viewProviders);
        this.queries = _normalizeArray(queries);
        this.guards = guards;
        this.viewQueries = _normalizeArray(viewQueries);
        this.entryComponents = _normalizeArray(entryComponents);
        this.template = template;
        this.componentViewType = componentViewType;
        this.rendererType = rendererType;
        this.componentFactory = componentFactory;
      }
      toSummary() {
        return {
          summaryKind: CompileSummaryKind.Directive,
          type: this.type,
          isComponent: this.isComponent,
          selector: this.selector,
          exportAs: this.exportAs,
          inputs: this.inputs,
          outputs: this.outputs,
          hostListeners: this.hostListeners,
          hostProperties: this.hostProperties,
          hostAttributes: this.hostAttributes,
          providers: this.providers,
          viewProviders: this.viewProviders,
          queries: this.queries,
          guards: this.guards,
          viewQueries: this.viewQueries,
          entryComponents: this.entryComponents,
          changeDetection: this.changeDetection,
          template: this.template && this.template.toSummary(),
          componentViewType: this.componentViewType,
          rendererType: this.rendererType,
          componentFactory: this.componentFactory
        };
      }
    };
    exports2.CompileDirectiveMetadata = CompileDirectiveMetadata;
    var CompilePipeMetadata = class {
      constructor({
        type,
        name,
        pure
      }) {
        this.type = type;
        this.name = name;
        this.pure = !!pure;
      }
      toSummary() {
        return {
          summaryKind: CompileSummaryKind.Pipe,
          type: this.type,
          name: this.name,
          pure: this.pure
        };
      }
    };
    exports2.CompilePipeMetadata = CompilePipeMetadata;
    var CompileShallowModuleMetadata = class {
    };
    exports2.CompileShallowModuleMetadata = CompileShallowModuleMetadata;
    var CompileNgModuleMetadata = class {
      constructor({
        type,
        providers,
        declaredDirectives,
        exportedDirectives,
        declaredPipes,
        exportedPipes,
        entryComponents,
        bootstrapComponents,
        importedModules,
        exportedModules,
        schemas,
        transitiveModule,
        id
      }) {
        this.type = type || null;
        this.declaredDirectives = _normalizeArray(declaredDirectives);
        this.exportedDirectives = _normalizeArray(exportedDirectives);
        this.declaredPipes = _normalizeArray(declaredPipes);
        this.exportedPipes = _normalizeArray(exportedPipes);
        this.providers = _normalizeArray(providers);
        this.entryComponents = _normalizeArray(entryComponents);
        this.bootstrapComponents = _normalizeArray(bootstrapComponents);
        this.importedModules = _normalizeArray(importedModules);
        this.exportedModules = _normalizeArray(exportedModules);
        this.schemas = _normalizeArray(schemas);
        this.id = id || null;
        this.transitiveModule = transitiveModule || null;
      }
      toSummary() {
        const module3 = this.transitiveModule;
        return {
          summaryKind: CompileSummaryKind.NgModule,
          type: this.type,
          entryComponents: module3.entryComponents,
          providers: module3.providers,
          modules: module3.modules,
          exportedDirectives: module3.exportedDirectives,
          exportedPipes: module3.exportedPipes
        };
      }
    };
    exports2.CompileNgModuleMetadata = CompileNgModuleMetadata;
    var TransitiveCompileNgModuleMetadata = class {
      constructor() {
        this.directivesSet = /* @__PURE__ */ new Set();
        this.directives = [];
        this.exportedDirectivesSet = /* @__PURE__ */ new Set();
        this.exportedDirectives = [];
        this.pipesSet = /* @__PURE__ */ new Set();
        this.pipes = [];
        this.exportedPipesSet = /* @__PURE__ */ new Set();
        this.exportedPipes = [];
        this.modulesSet = /* @__PURE__ */ new Set();
        this.modules = [];
        this.entryComponentsSet = /* @__PURE__ */ new Set();
        this.entryComponents = [];
        this.providers = [];
      }
      addProvider(provider, module3) {
        this.providers.push({
          provider,
          module: module3
        });
      }
      addDirective(id) {
        if (!this.directivesSet.has(id.reference)) {
          this.directivesSet.add(id.reference);
          this.directives.push(id);
        }
      }
      addExportedDirective(id) {
        if (!this.exportedDirectivesSet.has(id.reference)) {
          this.exportedDirectivesSet.add(id.reference);
          this.exportedDirectives.push(id);
        }
      }
      addPipe(id) {
        if (!this.pipesSet.has(id.reference)) {
          this.pipesSet.add(id.reference);
          this.pipes.push(id);
        }
      }
      addExportedPipe(id) {
        if (!this.exportedPipesSet.has(id.reference)) {
          this.exportedPipesSet.add(id.reference);
          this.exportedPipes.push(id);
        }
      }
      addModule(id) {
        if (!this.modulesSet.has(id.reference)) {
          this.modulesSet.add(id.reference);
          this.modules.push(id);
        }
      }
      addEntryComponent(ec) {
        if (!this.entryComponentsSet.has(ec.componentType)) {
          this.entryComponentsSet.add(ec.componentType);
          this.entryComponents.push(ec);
        }
      }
    };
    exports2.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;
    function _normalizeArray(obj) {
      return obj || [];
    }
    var ProviderMeta = class {
      constructor(token, {
        useClass,
        useValue,
        useExisting,
        useFactory,
        deps,
        multi
      }) {
        this.token = token;
        this.useClass = useClass || null;
        this.useValue = useValue;
        this.useExisting = useExisting;
        this.useFactory = useFactory || null;
        this.dependencies = deps || null;
        this.multi = !!multi;
      }
    };
    exports2.ProviderMeta = ProviderMeta;
    function flatten(list) {
      return list.reduce((flat, item) => {
        const flatItem = Array.isArray(item) ? flatten(item) : item;
        return flat.concat(flatItem);
      }, []);
    }
    exports2.flatten = flatten;
    function jitSourceUrl(url) {
      return url.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
    }
    function templateSourceUrl(ngModuleType, compMeta, templateMeta) {
      let url;
      if (templateMeta.isInline) {
        if (compMeta.type.reference instanceof static_symbol_1.StaticSymbol) {
          url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;
        } else {
          url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;
        }
      } else {
        url = templateMeta.templateUrl;
      }
      return compMeta.type.reference instanceof static_symbol_1.StaticSymbol ? url : jitSourceUrl(url);
    }
    exports2.templateSourceUrl = templateSourceUrl;
    function sharedStylesheetJitUrl(meta, id) {
      const pathParts = meta.moduleUrl.split(/\/\\/g);
      const baseName = pathParts[pathParts.length - 1];
      return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);
    }
    exports2.sharedStylesheetJitUrl = sharedStylesheetJitUrl;
    function ngModuleJitUrl(moduleMeta) {
      return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);
    }
    exports2.ngModuleJitUrl = ngModuleJitUrl;
    function templateJitUrl(ngModuleType, compMeta) {
      return jitSourceUrl(`${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);
    }
    exports2.templateJitUrl = templateJitUrl;
  }
});
var require_parse_util = __commonJS2({
  "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var chars = require_chars();
    var compile_metadata_1 = require_compile_metadata();
    var ParseLocation = class {
      constructor(file, offset, line, col) {
        this.file = file;
        this.offset = offset;
        this.line = line;
        this.col = col;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(delta) {
        const source = this.file.content;
        const len = source.length;
        let offset = this.offset;
        let line = this.line;
        let col = this.col;
        while (offset > 0 && delta < 0) {
          offset--;
          delta++;
          const ch = source.charCodeAt(offset);
          if (ch == chars.$LF) {
            line--;
            const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));
            col = priorLine > 0 ? offset - priorLine : offset;
          } else {
            col--;
          }
        }
        while (offset < len && delta > 0) {
          const ch = source.charCodeAt(offset);
          offset++;
          delta--;
          if (ch == chars.$LF) {
            line++;
            col = 0;
          } else {
            col++;
          }
        }
        return new ParseLocation(this.file, offset, line, col);
      }
      getContext(maxChars, maxLines) {
        const content = this.file.content;
        let startOffset = this.offset;
        if (startOffset != null) {
          if (startOffset > content.length - 1) {
            startOffset = content.length - 1;
          }
          let endOffset = startOffset;
          let ctxChars = 0;
          let ctxLines = 0;
          while (ctxChars < maxChars && startOffset > 0) {
            startOffset--;
            ctxChars++;
            if (content[startOffset] == "\n") {
              if (++ctxLines == maxLines) {
                break;
              }
            }
          }
          ctxChars = 0;
          ctxLines = 0;
          while (ctxChars < maxChars && endOffset < content.length - 1) {
            endOffset++;
            ctxChars++;
            if (content[endOffset] == "\n") {
              if (++ctxLines == maxLines) {
                break;
              }
            }
          }
          return {
            before: content.substring(startOffset, this.offset),
            after: content.substring(this.offset, endOffset + 1)
          };
        }
        return null;
      }
    };
    exports2.ParseLocation = ParseLocation;
    var ParseSourceFile = class {
      constructor(content, url) {
        this.content = content;
        this.url = url;
      }
    };
    exports2.ParseSourceFile = ParseSourceFile;
    var ParseSourceSpan = class {
      constructor(start, end, details = null) {
        this.start = start;
        this.end = end;
        this.details = details;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    };
    exports2.ParseSourceSpan = ParseSourceSpan;
    exports2.EMPTY_PARSE_LOCATION = new ParseLocation(new ParseSourceFile("", ""), 0, 0, 0);
    exports2.EMPTY_SOURCE_SPAN = new ParseSourceSpan(exports2.EMPTY_PARSE_LOCATION, exports2.EMPTY_PARSE_LOCATION);
    var ParseErrorLevel;
    (function(ParseErrorLevel2) {
      ParseErrorLevel2[ParseErrorLevel2["WARNING"] = 0] = "WARNING";
      ParseErrorLevel2[ParseErrorLevel2["ERROR"] = 1] = "ERROR";
    })(ParseErrorLevel = exports2.ParseErrorLevel || (exports2.ParseErrorLevel = {}));
    var ParseError = class {
      constructor(span, msg, level = ParseErrorLevel.ERROR) {
        this.span = span;
        this.msg = msg;
        this.level = level;
      }
      contextualMessage() {
        const ctx = this.span.start.getContext(100, 3);
        return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` : this.msg;
      }
      toString() {
        const details = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${details}`;
      }
    };
    exports2.ParseError = ParseError;
    function typeSourceSpan(kind, type) {
      const moduleUrl = compile_metadata_1.identifierModuleUrl(type);
      const sourceFileName = moduleUrl != null ? `in ${kind} ${compile_metadata_1.identifierName(type)} in ${moduleUrl}` : `in ${kind} ${compile_metadata_1.identifierName(type)}`;
      const sourceFile = new ParseSourceFile("", sourceFileName);
      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }
    exports2.typeSourceSpan = typeSourceSpan;
    function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
      const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
      const sourceFile = new ParseSourceFile("", sourceFileName);
      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }
    exports2.r3JitTypeSourceSpan = r3JitTypeSourceSpan;
  }
});
var require_print_preprocess3 = __commonJS2({
  "src/language-html/print-preprocess.js"(exports2, module2) {
    "use strict";
    var {
      ParseSourceSpan
    } = require_parse_util();
    var {
      htmlTrim,
      getLeadingAndTrailingHtmlWhitespace,
      hasHtmlWhitespace,
      canHaveInterpolation,
      getNodeCssStyleDisplay,
      isDanglingSpaceSensitiveNode,
      isIndentationSensitiveNode,
      isLeadingSpaceSensitiveNode,
      isTrailingSpaceSensitiveNode,
      isWhitespaceSensitiveNode,
      isVueScriptTag
    } = require_utils11();
    var PREPROCESS_PIPELINE = [removeIgnorableFirstLf, mergeIfConditionalStartEndCommentIntoElementOpeningTag, mergeCdataIntoText, extractInterpolation, extractWhitespaces, addCssDisplay, addIsSelfClosing, addHasHtmComponentClosingTag, addIsSpaceSensitive, mergeSimpleElementIntoText, markTsScript];
    function preprocess(ast, options) {
      for (const fn of PREPROCESS_PIPELINE) {
        fn(ast, options);
      }
      return ast;
    }
    function removeIgnorableFirstLf(ast) {
      ast.walk((node) => {
        if (node.type === "element" && node.tagDefinition.ignoreFirstLf && node.children.length > 0 && node.children[0].type === "text" && node.children[0].value[0] === "\n") {
          const text = node.children[0];
          if (text.value.length === 1) {
            node.removeChild(text);
          } else {
            text.value = text.value.slice(1);
          }
        }
      });
    }
    function mergeIfConditionalStartEndCommentIntoElementOpeningTag(ast) {
      const isTarget = (node) => node.type === "element" && node.prev && node.prev.type === "ieConditionalStartComment" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && node.firstChild && node.firstChild.type === "ieConditionalEndComment" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;
      ast.walk((node) => {
        if (node.children) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (!isTarget(child)) {
              continue;
            }
            const ieConditionalStartComment = child.prev;
            const ieConditionalEndComment = child.firstChild;
            node.removeChild(ieConditionalStartComment);
            i--;
            const startSourceSpan = new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start, ieConditionalEndComment.sourceSpan.end);
            const sourceSpan = new ParseSourceSpan(startSourceSpan.start, child.sourceSpan.end);
            child.condition = ieConditionalStartComment.condition;
            child.sourceSpan = sourceSpan;
            child.startSourceSpan = startSourceSpan;
            child.removeChild(ieConditionalEndComment);
          }
        }
      });
    }
    function mergeNodeIntoText(ast, shouldMerge, getValue) {
      ast.walk((node) => {
        if (node.children) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (child.type !== "text" && !shouldMerge(child)) {
              continue;
            }
            if (child.type !== "text") {
              child.type = "text";
              child.value = getValue(child);
            }
            const prevChild = child.prev;
            if (!prevChild || prevChild.type !== "text") {
              continue;
            }
            prevChild.value += child.value;
            prevChild.sourceSpan = new ParseSourceSpan(prevChild.sourceSpan.start, child.sourceSpan.end);
            node.removeChild(child);
            i--;
          }
        }
      });
    }
    function mergeCdataIntoText(ast) {
      return mergeNodeIntoText(ast, (node) => node.type === "cdata", (node) => `<![CDATA[${node.value}]]>`);
    }
    function mergeSimpleElementIntoText(ast) {
      const isSimpleElement = (node) => node.type === "element" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === "text" && !hasHtmlWhitespace(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && node.prev && node.prev.type === "text" && node.next && node.next.type === "text";
      ast.walk((node) => {
        if (node.children) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (!isSimpleElement(child)) {
              continue;
            }
            const prevChild = child.prev;
            const nextChild = child.next;
            prevChild.value += `<${child.rawName}>` + child.firstChild.value + `</${child.rawName}>` + nextChild.value;
            prevChild.sourceSpan = new ParseSourceSpan(prevChild.sourceSpan.start, nextChild.sourceSpan.end);
            prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;
            prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;
            node.removeChild(child);
            i--;
            node.removeChild(nextChild);
          }
        }
      });
    }
    function extractInterpolation(ast, options) {
      if (options.parser === "html") {
        return;
      }
      const interpolationRegex = /{{(.+?)}}/s;
      ast.walk((node) => {
        if (!canHaveInterpolation(node)) {
          return;
        }
        for (const child of node.children) {
          if (child.type !== "text") {
            continue;
          }
          let startSourceSpan = child.sourceSpan.start;
          let endSourceSpan = null;
          const components = child.value.split(interpolationRegex);
          for (let i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {
            const value = components[i];
            if (i % 2 === 0) {
              endSourceSpan = startSourceSpan.moveBy(value.length);
              if (value.length > 0) {
                node.insertChildBefore(child, {
                  type: "text",
                  value,
                  sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)
                });
              }
              continue;
            }
            endSourceSpan = startSourceSpan.moveBy(value.length + 4);
            node.insertChildBefore(child, {
              type: "interpolation",
              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),
              children: value.length === 0 ? [] : [{
                type: "text",
                value,
                sourceSpan: new ParseSourceSpan(startSourceSpan.moveBy(2), endSourceSpan.moveBy(-2))
              }]
            });
          }
          node.removeChild(child);
        }
      });
    }
    function extractWhitespaces(ast) {
      ast.walk((node) => {
        if (!node.children) {
          return;
        }
        if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "text" && htmlTrim(node.children[0].value).length === 0) {
          node.hasDanglingSpaces = node.children.length > 0;
          node.children = [];
          return;
        }
        const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);
        const isIndentationSensitive = isIndentationSensitiveNode(node);
        if (!isWhitespaceSensitive) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (child.type !== "text") {
              continue;
            }
            const {
              leadingWhitespace,
              text,
              trailingWhitespace
            } = getLeadingAndTrailingHtmlWhitespace(child.value);
            const prevChild = child.prev;
            const nextChild = child.next;
            if (!text) {
              node.removeChild(child);
              i--;
              if (leadingWhitespace || trailingWhitespace) {
                if (prevChild) {
                  prevChild.hasTrailingSpaces = true;
                }
                if (nextChild) {
                  nextChild.hasLeadingSpaces = true;
                }
              }
            } else {
              child.value = text;
              child.sourceSpan = new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingWhitespace.length), child.sourceSpan.end.moveBy(-trailingWhitespace.length));
              if (leadingWhitespace) {
                if (prevChild) {
                  prevChild.hasTrailingSpaces = true;
                }
                child.hasLeadingSpaces = true;
              }
              if (trailingWhitespace) {
                child.hasTrailingSpaces = true;
                if (nextChild) {
                  nextChild.hasLeadingSpaces = true;
                }
              }
            }
          }
        }
        node.isWhitespaceSensitive = isWhitespaceSensitive;
        node.isIndentationSensitive = isIndentationSensitive;
      });
    }
    function addIsSelfClosing(ast) {
      ast.walk((node) => {
        node.isSelfClosing = !node.children || node.type === "element" && (node.tagDefinition.isVoid || node.startSourceSpan === node.endSourceSpan);
      });
    }
    function addHasHtmComponentClosingTag(ast, options) {
      ast.walk((node) => {
        if (node.type !== "element") {
          return;
        }
        node.hasHtmComponentClosingTag = node.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset, node.endSourceSpan.end.offset));
      });
    }
    function addCssDisplay(ast, options) {
      ast.walk((node) => {
        node.cssDisplay = getNodeCssStyleDisplay(node, options);
      });
    }
    function addIsSpaceSensitive(ast, options) {
      ast.walk((node) => {
        const {
          children
        } = node;
        if (!children) {
          return;
        }
        if (children.length === 0) {
          node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);
          return;
        }
        for (const child of children) {
          child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(child, options);
          child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(child, options);
        }
        for (let index = 0; index < children.length; index++) {
          const child = children[index];
          child.isLeadingSpaceSensitive = index === 0 ? child.isLeadingSpaceSensitive : child.prev.isTrailingSpaceSensitive && child.isLeadingSpaceSensitive;
          child.isTrailingSpaceSensitive = index === children.length - 1 ? child.isTrailingSpaceSensitive : child.next.isLeadingSpaceSensitive && child.isTrailingSpaceSensitive;
        }
      });
    }
    function markTsScript(ast, options) {
      if (options.parser === "vue") {
        const vueScriptTag = ast.children.find((child) => isVueScriptTag(child, options));
        if (!vueScriptTag) {
          return;
        }
        const {
          lang
        } = vueScriptTag.attrMap;
        if (lang === "ts" || lang === "typescript") {
          options.__should_parse_vue_template_with_ts = true;
        }
      }
    }
    module2.exports = preprocess;
  }
});
var require_pragma5 = __commonJS2({
  "src/language-html/pragma.js"(exports2, module2) {
    "use strict";
    function hasPragma(text) {
      return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(text);
    }
    function insertPragma(text) {
      return "<!-- @format -->\n\n" + text.replace(/^\s*\n/, "");
    }
    module2.exports = {
      hasPragma,
      insertPragma
    };
  }
});
var require_loc6 = __commonJS2({
  "src/language-html/loc.js"(exports2, module2) {
    "use strict";
    function locStart(node) {
      return node.sourceSpan.start.offset;
    }
    function locEnd(node) {
      return node.sourceSpan.end.offset;
    }
    module2.exports = {
      locStart,
      locEnd
    };
  }
});
var require_tag = __commonJS2({
  "src/language-html/print/tag.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var {
      isNonEmptyArray
    } = require_util();
    var {
      builders: {
        indent,
        join,
        line,
        softline,
        hardline
      },
      utils: {
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var {
      locStart,
      locEnd
    } = require_loc6();
    var {
      isTextLikeNode,
      getLastDescendant,
      isPreLikeNode,
      hasPrettierIgnore,
      shouldPreserveContent,
      isVueSfcBlock
    } = require_utils11();
    function printClosingTag(node, options) {
      return [node.isSelfClosing ? "" : printClosingTagStart(node, options), printClosingTagEnd(node, options)];
    }
    function printClosingTagStart(node, options) {
      return node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild) ? "" : [printClosingTagPrefix(node, options), printClosingTagStartMarker(node, options)];
    }
    function printClosingTagEnd(node, options) {
      return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? "" : [printClosingTagEndMarker(node, options), printClosingTagSuffix(node, options)];
    }
    function printClosingTagPrefix(node, options) {
      return needsToBorrowLastChildClosingTagEndMarker(node) ? printClosingTagEndMarker(node.lastChild, options) : "";
    }
    function printClosingTagSuffix(node, options) {
      return needsToBorrowParentClosingTagStartMarker(node) ? printClosingTagStartMarker(node.parent, options) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : "";
    }
    function printClosingTagStartMarker(node, options) {
      assert(!node.isSelfClosing);
      if (shouldNotPrintClosingTag(node, options)) {
        return "";
      }
      switch (node.type) {
        case "ieConditionalComment":
          return "<!";
        case "element":
          if (node.hasHtmComponentClosingTag) {
            return "<//";
          }
        default:
          return `</${node.rawName}`;
      }
    }
    function printClosingTagEndMarker(node, options) {
      if (shouldNotPrintClosingTag(node, options)) {
        return "";
      }
      switch (node.type) {
        case "ieConditionalComment":
        case "ieConditionalEndComment":
          return "[endif]-->";
        case "ieConditionalStartComment":
          return "]><!-->";
        case "interpolation":
          return "}}";
        case "element":
          if (node.isSelfClosing) {
            return "/>";
          }
        default:
          return ">";
      }
    }
    function shouldNotPrintClosingTag(node, options) {
      return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options));
    }
    function needsToBorrowPrevClosingTagEndMarker(node) {
      return node.prev && node.prev.type !== "docType" && !isTextLikeNode(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
    }
    function needsToBorrowLastChildClosingTagEndMarker(node) {
      return node.lastChild && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces && !isTextLikeNode(getLastDescendant(node.lastChild)) && !isPreLikeNode(node);
    }
    function needsToBorrowParentClosingTagStartMarker(node) {
      return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode(getLastDescendant(node));
    }
    function needsToBorrowNextOpeningTagStartMarker(node) {
      return node.next && !isTextLikeNode(node.next) && isTextLikeNode(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;
    }
    function getPrettierIgnoreAttributeCommentData(value) {
      const match = value.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
      if (!match) {
        return false;
      }
      if (!match[1]) {
        return true;
      }
      return match[1].split(/\s+/);
    }
    function needsToBorrowParentOpeningTagEndMarker(node) {
      return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
    }
    function printAttributes(path, options, print) {
      const node = path.getValue();
      if (!isNonEmptyArray(node.attrs)) {
        return node.isSelfClosing ? " " : "";
      }
      const ignoreAttributeData = node.prev && node.prev.type === "comment" && getPrettierIgnoreAttributeCommentData(node.prev.value);
      const hasPrettierIgnoreAttribute = typeof ignoreAttributeData === "boolean" ? () => ignoreAttributeData : Array.isArray(ignoreAttributeData) ? (attribute) => ignoreAttributeData.includes(attribute.rawName) : () => false;
      const printedAttributes = path.map((attributePath) => {
        const attribute = attributePath.getValue();
        return hasPrettierIgnoreAttribute(attribute) ? replaceTextEndOfLine(options.originalText.slice(locStart(attribute), locEnd(attribute))) : print();
      }, "attrs");
      const forceNotToBreakAttrContent = node.type === "element" && node.fullName === "script" && node.attrs.length === 1 && node.attrs[0].fullName === "src" && node.children.length === 0;
      const shouldPrintAttributePerLine = options.singleAttributePerLine && node.attrs.length > 1 && !isVueSfcBlock(node, options);
      const attributeLine = shouldPrintAttributePerLine ? hardline : line;
      const parts = [indent([forceNotToBreakAttrContent ? " " : line, join(attributeLine, printedAttributes)])];
      if (node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) || node.isSelfClosing && needsToBorrowLastChildClosingTagEndMarker(node.parent) || forceNotToBreakAttrContent) {
        parts.push(node.isSelfClosing ? " " : "");
      } else {
        parts.push(options.bracketSameLine ? node.isSelfClosing ? " " : "" : node.isSelfClosing ? line : softline);
      }
      return parts;
    }
    function printOpeningTagEnd(node) {
      return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? "" : printOpeningTagEndMarker(node);
    }
    function printOpeningTag(path, options, print) {
      const node = path.getValue();
      return [printOpeningTagStart(node, options), printAttributes(path, options, print), node.isSelfClosing ? "" : printOpeningTagEnd(node)];
    }
    function printOpeningTagStart(node, options) {
      return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? "" : [printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)];
    }
    function printOpeningTagPrefix(node, options) {
      return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options) : "";
    }
    function printOpeningTagStartMarker(node) {
      switch (node.type) {
        case "ieConditionalComment":
        case "ieConditionalStartComment":
          return `<!--[if ${node.condition}`;
        case "ieConditionalEndComment":
          return "<!--<!";
        case "interpolation":
          return "{{";
        case "docType":
          return "<!DOCTYPE";
        case "element":
          if (node.condition) {
            return `<!--[if ${node.condition}]><!--><${node.rawName}`;
          }
        default:
          return `<${node.rawName}`;
      }
    }
    function printOpeningTagEndMarker(node) {
      assert(!node.isSelfClosing);
      switch (node.type) {
        case "ieConditionalComment":
          return "]>";
        case "element":
          if (node.condition) {
            return "><!--<![endif]-->";
          }
        default:
          return ">";
      }
    }
    module2.exports = {
      printClosingTag,
      printClosingTagStart,
      printClosingTagStartMarker,
      printClosingTagEndMarker,
      printClosingTagSuffix,
      printClosingTagEnd,
      needsToBorrowLastChildClosingTagEndMarker,
      needsToBorrowParentClosingTagStartMarker,
      needsToBorrowPrevClosingTagEndMarker,
      printOpeningTag,
      printOpeningTagStart,
      printOpeningTagPrefix,
      printOpeningTagStartMarker,
      printOpeningTagEndMarker,
      needsToBorrowNextOpeningTagStartMarker,
      needsToBorrowParentOpeningTagEndMarker
    };
  }
});
var require_parse_srcset = __commonJS2({
  "node_modules/parse-srcset/src/parse-srcset.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.parseSrcset = factory();
      }
    })(exports2, function() {
      return function(input, options) {
        var logger = options && options.logger || console;
        function isSpace(c2) {
          return c2 === " " || c2 === "	" || c2 === "\n" || c2 === "\f" || c2 === "\r";
        }
        function collectCharacters(regEx) {
          var chars, match = regEx.exec(input.substring(pos));
          if (match) {
            chars = match[0];
            pos += chars.length;
            return chars;
          }
        }
        var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];
        while (true) {
          collectCharacters(regexLeadingCommasOrSpaces);
          if (pos >= inputLength) {
            return candidates;
          }
          url = collectCharacters(regexLeadingNotSpaces);
          descriptors = [];
          if (url.slice(-1) === ",") {
            url = url.replace(regexTrailingCommas, "");
            parseDescriptors();
          } else {
            tokenize();
          }
        }
        function tokenize() {
          collectCharacters(regexLeadingSpaces);
          currentDescriptor = "";
          state = "in descriptor";
          while (true) {
            c = input.charAt(pos);
            if (state === "in descriptor") {
              if (isSpace(c)) {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                  currentDescriptor = "";
                  state = "after descriptor";
                }
              } else if (c === ",") {
                pos += 1;
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else if (c === "(") {
                currentDescriptor = currentDescriptor + c;
                state = "in parens";
              } else if (c === "") {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c;
              }
            } else if (state === "in parens") {
              if (c === ")") {
                currentDescriptor = currentDescriptor + c;
                state = "in descriptor";
              } else if (c === "") {
                descriptors.push(currentDescriptor);
                parseDescriptors();
                return;
              } else {
                currentDescriptor = currentDescriptor + c;
              }
            } else if (state === "after descriptor") {
              if (isSpace(c)) {
              } else if (c === "") {
                parseDescriptors();
                return;
              } else {
                state = "in descriptor";
                pos -= 1;
              }
            }
            pos += 1;
          }
        }
        function parseDescriptors() {
          var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;
          for (i = 0; i < descriptors.length; i++) {
            desc = descriptors[i];
            lastChar = desc[desc.length - 1];
            value = desc.substring(0, desc.length - 1);
            intVal = parseInt(value, 10);
            floatVal = parseFloat(value);
            if (regexNonNegativeInteger.test(value) && lastChar === "w") {
              if (w || d) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                w = intVal;
              }
            } else if (regexFloatingPoint.test(value) && lastChar === "x") {
              if (w || d || h) {
                pError = true;
              }
              if (floatVal < 0) {
                pError = true;
              } else {
                d = floatVal;
              }
            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
              if (h || d) {
                pError = true;
              }
              if (intVal === 0) {
                pError = true;
              } else {
                h = intVal;
              }
            } else {
              pError = true;
            }
          }
          if (!pError) {
            candidate.url = url;
            if (w) {
              candidate.w = w;
            }
            if (d) {
              candidate.d = d;
            }
            if (h) {
              candidate.h = h;
            }
            candidates.push(candidate);
          } else if (logger && logger.error) {
            logger.error("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
          }
        }
      };
    });
  }
});
var require_syntax_attribute = __commonJS2({
  "src/language-html/syntax-attribute.js"(exports2, module2) {
    "use strict";
    var parseSrcset = require_parse_srcset();
    var {
      builders: {
        ifBreak,
        join,
        line
      }
    } = require("./doc.js");
    function printImgSrcset(value) {
      const srcset = parseSrcset(value, {
        logger: {
          error(message) {
            throw new Error(message);
          }
        }
      });
      const hasW = srcset.some(({
        w
      }) => w);
      const hasH = srcset.some(({
        h
      }) => h);
      const hasX = srcset.some(({
        d
      }) => d);
      if (hasW + hasH + hasX > 1) {
        throw new Error("Mixed descriptor in srcset is not supported");
      }
      const key = hasW ? "w" : hasH ? "h" : "d";
      const unit = hasW ? "w" : hasH ? "h" : "x";
      const getMax = (values) => Math.max(...values);
      const urls = srcset.map((src) => src.url);
      const maxUrlLength = getMax(urls.map((url) => url.length));
      const descriptors = srcset.map((src) => src[key]).map((descriptor) => descriptor ? descriptor.toString() : "");
      const descriptorLeftLengths = descriptors.map((descriptor) => {
        const index = descriptor.indexOf(".");
        return index === -1 ? descriptor.length : index;
      });
      const maxDescriptorLeftLength = getMax(descriptorLeftLengths);
      return join([",", line], urls.map((url, index) => {
        const parts = [url];
        const descriptor = descriptors[index];
        if (descriptor) {
          const urlPadding = maxUrlLength - url.length + 1;
          const descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];
          const alignment = " ".repeat(urlPadding + descriptorPadding);
          parts.push(ifBreak(alignment, " "), descriptor + unit);
        }
        return parts;
      }));
    }
    function printClassNames(value) {
      return value.trim().split(/\s+/).join(" ");
    }
    module2.exports = {
      printImgSrcset,
      printClassNames
    };
  }
});
var require_syntax_vue = __commonJS2({
  "src/language-html/syntax-vue.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        group
      }
    } = require("./doc.js");
    function printVueFor(value, textToDoc) {
      const {
        left,
        operator,
        right
      } = parseVueFor(value);
      return [group(textToDoc(`function _(${left}) {}`, {
        parser: "babel",
        __isVueForBindingLeft: true
      })), " ", operator, " ", textToDoc(right, {
        parser: "__js_expression"
      }, {
        stripTrailingHardline: true
      })];
    }
    function parseVueFor(value) {
      const forAliasRE = /(.*?)\s+(in|of)\s+(.*)/s;
      const forIteratorRE = /,([^,\]}]*)(?:,([^,\]}]*))?$/;
      const stripParensRE = /^\(|\)$/g;
      const inMatch = value.match(forAliasRE);
      if (!inMatch) {
        return;
      }
      const res = {};
      res.for = inMatch[3].trim();
      if (!res.for) {
        return;
      }
      const alias = inMatch[1].trim().replace(stripParensRE, "");
      const iteratorMatch = alias.match(forIteratorRE);
      if (iteratorMatch) {
        res.alias = alias.replace(forIteratorRE, "");
        res.iterator1 = iteratorMatch[1].trim();
        if (iteratorMatch[2]) {
          res.iterator2 = iteratorMatch[2].trim();
        }
      } else {
        res.alias = alias;
      }
      const left = [res.alias, res.iterator1, res.iterator2];
      if (left.some((part, index) => !part && (index === 0 || left.slice(index + 1).some(Boolean)))) {
        return;
      }
      return {
        left: left.filter(Boolean).join(","),
        operator: inMatch[2],
        right: res.for
      };
    }
    function printVueBindings(value, textToDoc) {
      return textToDoc(`function _(${value}) {}`, {
        parser: "babel",
        __isVueBindings: true
      });
    }
    function isVueEventBindingExpression(eventBindingValue) {
      const fnExpRE = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/;
      const simplePathRE = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/;
      const value = eventBindingValue.trim();
      return fnExpRE.test(value) || simplePathRE.test(value);
    }
    module2.exports = {
      isVueEventBindingExpression,
      printVueFor,
      printVueBindings
    };
  }
});
var require_get_node_content = __commonJS2({
  "src/language-html/get-node-content.js"(exports2, module2) {
    "use strict";
    var {
      needsToBorrowParentClosingTagStartMarker,
      printClosingTagStartMarker,
      needsToBorrowLastChildClosingTagEndMarker,
      printClosingTagEndMarker,
      needsToBorrowParentOpeningTagEndMarker,
      printOpeningTagEndMarker
    } = require_tag();
    function getNodeContent(node, options) {
      let start = node.startSourceSpan.end.offset;
      if (node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild)) {
        start -= printOpeningTagEndMarker(node).length;
      }
      let end = node.endSourceSpan.start.offset;
      if (node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild)) {
        end += printClosingTagStartMarker(node, options).length;
      } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {
        end -= printClosingTagEndMarker(node.lastChild, options).length;
      }
      return options.originalText.slice(start, end);
    }
    module2.exports = getNodeContent;
  }
});
var require_embed4 = __commonJS2({
  "src/language-html/embed.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        breakParent,
        group,
        hardline,
        indent,
        line,
        fill,
        softline
      },
      utils: {
        mapDoc,
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var printFrontMatter = require_print();
    var {
      printClosingTag,
      printClosingTagSuffix,
      needsToBorrowPrevClosingTagEndMarker,
      printOpeningTagPrefix,
      printOpeningTag
    } = require_tag();
    var {
      printImgSrcset,
      printClassNames
    } = require_syntax_attribute();
    var {
      printVueFor,
      printVueBindings,
      isVueEventBindingExpression
    } = require_syntax_vue();
    var {
      isScriptLikeTag,
      isVueNonHtmlBlock,
      inferScriptParser,
      htmlTrimPreserveIndentation,
      dedentString,
      unescapeQuoteEntities,
      isVueSlotAttribute,
      isVueSfcBindingsAttribute,
      getTextValueParts
    } = require_utils11();
    var getNodeContent = require_get_node_content();
    function printEmbeddedAttributeValue(node, htmlTextToDoc, options) {
      const isKeyMatched = (patterns) => new RegExp(patterns.join("|")).test(node.fullName);
      const getValue = () => unescapeQuoteEntities(node.value);
      let shouldHug = false;
      const __onHtmlBindingRoot = (root, options2) => {
        const rootNode = root.type === "NGRoot" ? root.node.type === "NGMicrosyntax" && root.node.body.length === 1 && root.node.body[0].type === "NGMicrosyntaxExpression" ? root.node.body[0].expression : root.node : root.type === "JsExpressionRoot" ? root.node : root;
        if (rootNode && (rootNode.type === "ObjectExpression" || rootNode.type === "ArrayExpression" || options2.parser === "__vue_expression" && (rootNode.type === "TemplateLiteral" || rootNode.type === "StringLiteral"))) {
          shouldHug = true;
        }
      };
      const printHug = (doc2) => group(doc2);
      const printExpand = (doc2, canHaveTrailingWhitespace = true) => group([indent([softline, doc2]), canHaveTrailingWhitespace ? softline : ""]);
      const printMaybeHug = (doc2) => shouldHug ? printHug(doc2) : printExpand(doc2);
      const attributeTextToDoc = (code, opts) => htmlTextToDoc(code, Object.assign({
        __onHtmlBindingRoot,
        __embeddedInHtml: true
      }, opts));
      if (node.fullName === "srcset" && (node.parent.fullName === "img" || node.parent.fullName === "source")) {
        return printExpand(printImgSrcset(getValue()));
      }
      if (node.fullName === "class" && !options.parentParser) {
        const value = getValue();
        if (!value.includes("{{")) {
          return printClassNames(value);
        }
      }
      if (node.fullName === "style" && !options.parentParser) {
        const value = getValue();
        if (!value.includes("{{")) {
          return printExpand(attributeTextToDoc(value, {
            parser: "css",
            __isHTMLStyleAttribute: true
          }));
        }
      }
      if (options.parser === "vue") {
        if (node.fullName === "v-for") {
          return printVueFor(getValue(), attributeTextToDoc);
        }
        if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options)) {
          return printVueBindings(getValue(), attributeTextToDoc);
        }
        const vueEventBindingPatterns = ["^@", "^v-on:"];
        const vueExpressionBindingPatterns = ["^:", "^v-bind:"];
        const jsExpressionBindingPatterns = ["^v-"];
        if (isKeyMatched(vueEventBindingPatterns)) {
          const value = getValue();
          const parser = isVueEventBindingExpression(value) ? "__js_expression" : options.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
          return printMaybeHug(attributeTextToDoc(value, {
            parser
          }));
        }
        if (isKeyMatched(vueExpressionBindingPatterns)) {
          return printMaybeHug(attributeTextToDoc(getValue(), {
            parser: "__vue_expression"
          }));
        }
        if (isKeyMatched(jsExpressionBindingPatterns)) {
          return printMaybeHug(attributeTextToDoc(getValue(), {
            parser: "__js_expression"
          }));
        }
      }
      if (options.parser === "angular") {
        const ngTextToDoc = (code, opts) => attributeTextToDoc(code, Object.assign(Object.assign({}, opts), {}, {
          trailingComma: "none"
        }));
        const ngDirectiveBindingPatterns = ["^\\*"];
        const ngStatementBindingPatterns = ["^\\(.+\\)$", "^on-"];
        const ngExpressionBindingPatterns = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"];
        const ngI18nPatterns = ["^i18n(-.+)?$"];
        if (isKeyMatched(ngStatementBindingPatterns)) {
          return printMaybeHug(ngTextToDoc(getValue(), {
            parser: "__ng_action"
          }));
        }
        if (isKeyMatched(ngExpressionBindingPatterns)) {
          return printMaybeHug(ngTextToDoc(getValue(), {
            parser: "__ng_binding"
          }));
        }
        if (isKeyMatched(ngI18nPatterns)) {
          const value2 = getValue().trim();
          return printExpand(fill(getTextValueParts(node, value2)), !value2.includes("@@"));
        }
        if (isKeyMatched(ngDirectiveBindingPatterns)) {
          return printMaybeHug(ngTextToDoc(getValue(), {
            parser: "__ng_directive"
          }));
        }
        const interpolationRegex = /{{(.+?)}}/s;
        const value = getValue();
        if (interpolationRegex.test(value)) {
          const parts = [];
          for (const [index, part] of value.split(interpolationRegex).entries()) {
            if (index % 2 === 0) {
              parts.push(replaceTextEndOfLine(part));
            } else {
              try {
                parts.push(group(["{{", indent([line, ngTextToDoc(part, {
                  parser: "__ng_interpolation",
                  __isInHtmlInterpolation: true
                })]), line, "}}"]));
              } catch {
                parts.push("{{", replaceTextEndOfLine(part), "}}");
              }
            }
          }
          return group(parts);
        }
      }
      return null;
    }
    function embed(path, print, textToDoc, options) {
      const node = path.getValue();
      switch (node.type) {
        case "element": {
          if (isScriptLikeTag(node) || node.type === "interpolation") {
            return;
          }
          if (!node.isSelfClosing && isVueNonHtmlBlock(node, options)) {
            const parser = inferScriptParser(node, options);
            if (!parser) {
              return;
            }
            const content = getNodeContent(node, options);
            let isEmpty = /^\s*$/.test(content);
            let doc2 = "";
            if (!isEmpty) {
              doc2 = textToDoc(htmlTrimPreserveIndentation(content), {
                parser,
                __embeddedInHtml: true
              }, {
                stripTrailingHardline: true
              });
              isEmpty = doc2 === "";
            }
            return [printOpeningTagPrefix(node, options), group(printOpeningTag(path, options, print)), isEmpty ? "" : hardline, doc2, isEmpty ? "" : hardline, printClosingTag(node, options), printClosingTagSuffix(node, options)];
          }
          break;
        }
        case "text": {
          if (isScriptLikeTag(node.parent)) {
            const parser = inferScriptParser(node.parent, options);
            if (parser) {
              const value = parser === "markdown" ? dedentString(node.value.replace(/^[^\S\n]*\n/, "")) : node.value;
              const textToDocOptions = {
                parser,
                __embeddedInHtml: true
              };
              if (options.parser === "html" && parser === "babel") {
                let sourceType = "script";
                const {
                  attrMap
                } = node.parent;
                if (attrMap && (attrMap.type === "module" || attrMap.type === "text/babel" && attrMap["data-type"] === "module")) {
                  sourceType = "module";
                }
                textToDocOptions.__babelSourceType = sourceType;
              }
              return [breakParent, printOpeningTagPrefix(node, options), textToDoc(value, textToDocOptions, {
                stripTrailingHardline: true
              }), printClosingTagSuffix(node, options)];
            }
          } else if (node.parent.type === "interpolation") {
            const textToDocOptions = {
              __isInHtmlInterpolation: true,
              __embeddedInHtml: true
            };
            if (options.parser === "angular") {
              textToDocOptions.parser = "__ng_interpolation";
              textToDocOptions.trailingComma = "none";
            } else if (options.parser === "vue") {
              textToDocOptions.parser = options.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression";
            } else {
              textToDocOptions.parser = "__js_expression";
            }
            return [indent([line, textToDoc(node.value, textToDocOptions, {
              stripTrailingHardline: true
            })]), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? " " : line];
          }
          break;
        }
        case "attribute": {
          if (!node.value) {
            break;
          }
          if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
            return [node.rawName, "=", node.value];
          }
          if (options.parser === "lwc") {
            const interpolationRegex = /^{.*}$/s;
            if (interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
              return [node.rawName, "=", node.value];
            }
          }
          const embeddedAttributeValueDoc = printEmbeddedAttributeValue(node, (code, opts) => textToDoc(code, Object.assign({
            __isInHtmlAttribute: true,
            __embeddedInHtml: true
          }, opts), {
            stripTrailingHardline: true
          }), options);
          if (embeddedAttributeValueDoc) {
            return [node.rawName, '="', group(mapDoc(embeddedAttributeValueDoc, (doc2) => typeof doc2 === "string" ? doc2.replace(/"/g, "&quot;") : doc2)), '"'];
          }
          break;
        }
        case "front-matter":
          return printFrontMatter(node, textToDoc);
      }
    }
    module2.exports = embed;
  }
});
var require_children = __commonJS2({
  "src/language-html/print/children.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        breakParent,
        group,
        ifBreak,
        line,
        softline,
        hardline
      },
      utils: {
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var {
      locStart,
      locEnd
    } = require_loc6();
    var {
      forceBreakChildren,
      forceNextEmptyLine,
      isTextLikeNode,
      hasPrettierIgnore,
      preferHardlineAsLeadingSpaces
    } = require_utils11();
    var {
      printOpeningTagPrefix,
      needsToBorrowNextOpeningTagStartMarker,
      printOpeningTagStartMarker,
      needsToBorrowPrevClosingTagEndMarker,
      printClosingTagEndMarker,
      printClosingTagSuffix,
      needsToBorrowParentClosingTagStartMarker
    } = require_tag();
    function printChild(childPath, options, print) {
      const child = childPath.getValue();
      if (hasPrettierIgnore(child)) {
        return [printOpeningTagPrefix(child, options), ...replaceTextEndOfLine(options.originalText.slice(locStart(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0), locEnd(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options).length : 0))), printClosingTagSuffix(child, options)];
      }
      return print();
    }
    function printBetweenLine(prevNode, nextNode) {
      return isTextLikeNode(prevNode) && isTextLikeNode(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces(nextNode) ? hardline : line : "" : preferHardlineAsLeadingSpaces(nextNode) ? hardline : softline : needsToBorrowNextOpeningTagStartMarker(prevNode) && (hasPrettierIgnore(nextNode) || nextNode.firstChild || nextNode.isSelfClosing || nextNode.type === "element" && nextNode.attrs.length > 0) || prevNode.type === "element" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? "" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces(nextNode) || needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) && prevNode.lastChild.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild) ? hardline : nextNode.hasLeadingSpaces ? line : softline;
    }
    function printChildren(path, options, print) {
      const node = path.getValue();
      if (forceBreakChildren(node)) {
        return [breakParent, ...path.map((childPath) => {
          const childNode = childPath.getValue();
          const prevBetweenLine = !childNode.prev ? "" : printBetweenLine(childNode.prev, childNode);
          return [!prevBetweenLine ? "" : [prevBetweenLine, forceNextEmptyLine(childNode.prev) ? hardline : ""], printChild(childPath, options, print)];
        }, "children")];
      }
      const groupIds = node.children.map(() => Symbol(""));
      return path.map((childPath, childIndex) => {
        const childNode = childPath.getValue();
        if (isTextLikeNode(childNode)) {
          if (childNode.prev && isTextLikeNode(childNode.prev)) {
            const prevBetweenLine2 = printBetweenLine(childNode.prev, childNode);
            if (prevBetweenLine2) {
              if (forceNextEmptyLine(childNode.prev)) {
                return [hardline, hardline, printChild(childPath, options, print)];
              }
              return [prevBetweenLine2, printChild(childPath, options, print)];
            }
          }
          return printChild(childPath, options, print);
        }
        const prevParts = [];
        const leadingParts = [];
        const trailingParts = [];
        const nextParts = [];
        const prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : "";
        const nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : "";
        if (prevBetweenLine) {
          if (forceNextEmptyLine(childNode.prev)) {
            prevParts.push(hardline, hardline);
          } else if (prevBetweenLine === hardline) {
            prevParts.push(hardline);
          } else {
            if (isTextLikeNode(childNode.prev)) {
              leadingParts.push(prevBetweenLine);
            } else {
              leadingParts.push(ifBreak("", softline, {
                groupId: groupIds[childIndex - 1]
              }));
            }
          }
        }
        if (nextBetweenLine) {
          if (forceNextEmptyLine(childNode)) {
            if (isTextLikeNode(childNode.next)) {
              nextParts.push(hardline, hardline);
            }
          } else if (nextBetweenLine === hardline) {
            if (isTextLikeNode(childNode.next)) {
              nextParts.push(hardline);
            }
          } else {
            trailingParts.push(nextBetweenLine);
          }
        }
        return [...prevParts, group([...leadingParts, group([printChild(childPath, options, print), ...trailingParts], {
          id: groupIds[childIndex]
        })]), ...nextParts];
      }, "children");
    }
    module2.exports = {
      printChildren
    };
  }
});
var require_element = __commonJS2({
  "src/language-html/print/element.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        breakParent,
        dedentToRoot,
        group,
        ifBreak,
        indentIfBreak,
        indent,
        line,
        softline
      },
      utils: {
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var getNodeContent = require_get_node_content();
    var {
      shouldPreserveContent,
      isScriptLikeTag,
      isVueCustomBlock,
      countParents,
      forceBreakContent
    } = require_utils11();
    var {
      printOpeningTagPrefix,
      printOpeningTag,
      printClosingTagSuffix,
      printClosingTag,
      needsToBorrowPrevClosingTagEndMarker,
      needsToBorrowLastChildClosingTagEndMarker
    } = require_tag();
    var {
      printChildren
    } = require_children();
    function printElement(path, options, print) {
      const node = path.getValue();
      if (shouldPreserveContent(node, options)) {
        return [printOpeningTagPrefix(node, options), group(printOpeningTag(path, options, print)), ...replaceTextEndOfLine(getNodeContent(node, options)), ...printClosingTag(node, options), printClosingTagSuffix(node, options)];
      }
      const shouldHugContent = node.children.length === 1 && node.firstChild.type === "interpolation" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;
      const attrGroupId = Symbol("element-attr-group-id");
      const printTag = (doc2) => group([group(printOpeningTag(path, options, print), {
        id: attrGroupId
      }), doc2, printClosingTag(node, options)]);
      const printChildrenDoc = (childrenDoc) => {
        if (shouldHugContent) {
          return indentIfBreak(childrenDoc, {
            groupId: attrGroupId
          });
        }
        if ((isScriptLikeTag(node) || isVueCustomBlock(node, options)) && node.parent.type === "root" && options.parser === "vue" && !options.vueIndentScriptAndStyle) {
          return childrenDoc;
        }
        return indent(childrenDoc);
      };
      const printLineBeforeChildren = () => {
        if (shouldHugContent) {
          return ifBreak(softline, "", {
            groupId: attrGroupId
          });
        }
        if (node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive) {
          return line;
        }
        if (node.firstChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) {
          return dedentToRoot(softline);
        }
        return softline;
      };
      const printLineAfterChildren = () => {
        const needsToBorrow = node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent);
        if (needsToBorrow) {
          if (node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive) {
            return " ";
          }
          return "";
        }
        if (shouldHugContent) {
          return ifBreak(softline, "", {
            groupId: attrGroupId
          });
        }
        if (node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive) {
          return line;
        }
        if ((node.lastChild.type === "comment" || node.lastChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${options.tabWidth * countParents(path, (node2) => node2.parent && node2.parent.type !== "root")}}$`).test(node.lastChild.value)) {
          return "";
        }
        return softline;
      };
      if (node.children.length === 0) {
        return printTag(node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : "");
      }
      return printTag([forceBreakContent(node) ? breakParent : "", printChildrenDoc([printLineBeforeChildren(), printChildren(path, options, print)]), printLineAfterChildren()]);
    }
    module2.exports = {
      printElement
    };
  }
});
var require_printer_html = __commonJS2({
  "src/language-html/printer-html.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        fill,
        group,
        hardline,
        literalline
      },
      utils: {
        cleanDoc,
        getDocParts,
        isConcat,
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var clean = require_clean5();
    var {
      countChars,
      unescapeQuoteEntities,
      getTextValueParts
    } = require_utils11();
    var preprocess = require_print_preprocess3();
    var {
      insertPragma
    } = require_pragma5();
    var {
      locStart,
      locEnd
    } = require_loc6();
    var embed = require_embed4();
    var {
      printClosingTagSuffix,
      printClosingTagEnd,
      printOpeningTagPrefix,
      printOpeningTagStart
    } = require_tag();
    var {
      printElement
    } = require_element();
    var {
      printChildren
    } = require_children();
    function genericPrint(path, options, print) {
      const node = path.getValue();
      switch (node.type) {
        case "front-matter":
          return replaceTextEndOfLine(node.raw);
        case "root":
          if (options.__onHtmlRoot) {
            options.__onHtmlRoot(node);
          }
          return [group(printChildren(path, options, print)), hardline];
        case "element":
        case "ieConditionalComment": {
          return printElement(path, options, print);
        }
        case "ieConditionalStartComment":
        case "ieConditionalEndComment":
          return [printOpeningTagStart(node), printClosingTagEnd(node)];
        case "interpolation":
          return [printOpeningTagStart(node, options), ...path.map(print, "children"), printClosingTagEnd(node, options)];
        case "text": {
          if (node.parent.type === "interpolation") {
            const trailingNewlineRegex = /\n[^\S\n]*$/;
            const hasTrailingNewline = trailingNewlineRegex.test(node.value);
            const value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, "") : node.value;
            return [...replaceTextEndOfLine(value), hasTrailingNewline ? hardline : ""];
          }
          const printed = cleanDoc([printOpeningTagPrefix(node, options), ...getTextValueParts(node), printClosingTagSuffix(node, options)]);
          if (isConcat(printed) || printed.type === "fill") {
            return fill(getDocParts(printed));
          }
          return printed;
        }
        case "docType":
          return [group([printOpeningTagStart(node, options), " ", node.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), printClosingTagEnd(node, options)];
        case "comment": {
          return [printOpeningTagPrefix(node, options), ...replaceTextEndOfLine(options.originalText.slice(locStart(node), locEnd(node)), literalline), printClosingTagSuffix(node, options)];
        }
        case "attribute": {
          if (node.value === null) {
            return node.rawName;
          }
          const value = unescapeQuoteEntities(node.value);
          const singleQuoteCount = countChars(value, "'");
          const doubleQuoteCount = countChars(value, '"');
          const quote = singleQuoteCount < doubleQuoteCount ? "'" : '"';
          return [node.rawName, "=", quote, ...replaceTextEndOfLine(quote === '"' ? value.replace(/"/g, "&quot;") : value.replace(/'/g, "&apos;")), quote];
        }
        default:
          throw new Error(`Unexpected node type ${node.type}`);
      }
    }
    module2.exports = {
      preprocess,
      print: genericPrint,
      insertPragma,
      massageAstNode: clean,
      embed
    };
  }
});
var require_options6 = __commonJS2({
  "src/language-html/options.js"(exports2, module2) {
    "use strict";
    var commonOptions = require_common_options();
    var CATEGORY_HTML = "HTML";
    module2.exports = {
      bracketSameLine: commonOptions.bracketSameLine,
      htmlWhitespaceSensitivity: {
        since: "1.15.0",
        category: CATEGORY_HTML,
        type: "choice",
        default: "css",
        description: "How to handle whitespaces in HTML.",
        choices: [{
          value: "css",
          description: "Respect the default value of CSS display property."
        }, {
          value: "strict",
          description: "Whitespaces are considered sensitive."
        }, {
          value: "ignore",
          description: "Whitespaces are considered insensitive."
        }]
      },
      singleAttributePerLine: commonOptions.singleAttributePerLine,
      vueIndentScriptAndStyle: {
        since: "1.19.0",
        category: CATEGORY_HTML,
        type: "boolean",
        default: false,
        description: "Indent script and style tags in Vue files."
      }
    };
  }
});
var require_parsers6 = __commonJS2({
  "src/language-html/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get html() {
        return require("./parser-html.js").parsers.html;
      },
      get vue() {
        return require("./parser-html.js").parsers.vue;
      },
      get angular() {
        return require("./parser-html.js").parsers.angular;
      },
      get lwc() {
        return require("./parser-html.js").parsers.lwc;
      }
    };
  }
});
var require_HTML = __commonJS2({
  "node_modules/linguist-languages/data/HTML.json"(exports2, module2) {
    module2.exports = {
      name: "HTML",
      type: "markup",
      tmScope: "text.html.basic",
      aceMode: "html",
      codemirrorMode: "htmlmixed",
      codemirrorMimeType: "text/html",
      color: "#e34c26",
      aliases: ["xhtml"],
      extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"],
      languageId: 146
    };
  }
});
var require_Vue = __commonJS2({
  "node_modules/linguist-languages/data/Vue.json"(exports2, module2) {
    module2.exports = {
      name: "Vue",
      type: "markup",
      color: "#41b883",
      extensions: [".vue"],
      tmScope: "text.html.vue",
      aceMode: "html",
      languageId: 391
    };
  }
});
var require_language_html = __commonJS2({
  "src/language-html/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var printer = require_printer_html();
    var options = require_options6();
    var parsers = require_parsers6();
    var languages = [createLanguage(require_HTML(), () => ({
      name: "Angular",
      since: "1.15.0",
      parsers: ["angular"],
      vscodeLanguageIds: ["html"],
      extensions: [".component.html"],
      filenames: []
    })), createLanguage(require_HTML(), (data) => ({
      since: "1.15.0",
      parsers: ["html"],
      vscodeLanguageIds: ["html"],
      extensions: [...data.extensions, ".mjml"]
    })), createLanguage(require_HTML(), () => ({
      name: "Lightning Web Components",
      since: "1.17.0",
      parsers: ["lwc"],
      vscodeLanguageIds: ["html"],
      extensions: [],
      filenames: []
    })), createLanguage(require_Vue(), () => ({
      since: "1.10.0",
      parsers: ["vue"],
      vscodeLanguageIds: ["vue"]
    }))];
    var printers = {
      html: printer
    };
    module2.exports = {
      languages,
      printers,
      options,
      parsers
    };
  }
});
var require_pragma6 = __commonJS2({
  "src/language-yaml/pragma.js"(exports2, module2) {
    "use strict";
    function isPragma(text) {
      return /^\s*@(?:prettier|format)\s*$/.test(text);
    }
    function hasPragma(text) {
      return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(text);
    }
    function insertPragma(text) {
      return `# @format

${text}`;
    }
    module2.exports = {
      isPragma,
      hasPragma,
      insertPragma
    };
  }
});
var require_loc7 = __commonJS2({
  "src/language-yaml/loc.js"(exports2, module2) {
    "use strict";
    function locStart(node) {
      return node.position.start.offset;
    }
    function locEnd(node) {
      return node.position.end.offset;
    }
    module2.exports = {
      locStart,
      locEnd
    };
  }
});
var require_embed5 = __commonJS2({
  "src/language-yaml/embed.js"(exports2, module2) {
    "use strict";
    function embed(path, print, textToDoc, options) {
      const node = path.getValue();
      if (node.type === "root" && options.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(options.filepath)) {
        return textToDoc(options.originalText, Object.assign(Object.assign({}, options), {}, {
          parser: "json"
        }));
      }
    }
    module2.exports = embed;
  }
});
var require_utils12 = __commonJS2({
  "src/language-yaml/utils.js"(exports2, module2) {
    "use strict";
    var {
      getLast,
      isNonEmptyArray
    } = require_util();
    function getAncestorCount(path, filter) {
      let counter = 0;
      const pathStackLength = path.stack.length - 1;
      for (let i = 0; i < pathStackLength; i++) {
        const value = path.stack[i];
        if (isNode(value) && filter(value)) {
          counter++;
        }
      }
      return counter;
    }
    function isNode(value, types) {
      return value && typeof value.type === "string" && (!types || types.includes(value.type));
    }
    function mapNode(node, callback, parent) {
      return callback("children" in node ? Object.assign(Object.assign({}, node), {}, {
        children: node.children.map((childNode) => mapNode(childNode, callback, node))
      }) : node, parent);
    }
    function defineShortcut(x, key, getter) {
      Object.defineProperty(x, key, {
        get: getter,
        enumerable: false
      });
    }
    function isNextLineEmpty(node, text) {
      let newlineCount = 0;
      const textLength = text.length;
      for (let i = node.position.end.offset - 1; i < textLength; i++) {
        const char = text[i];
        if (char === "\n") {
          newlineCount++;
        }
        if (newlineCount === 1 && /\S/.test(char)) {
          return false;
        }
        if (newlineCount === 2) {
          return true;
        }
      }
      return false;
    }
    function isLastDescendantNode(path) {
      const node = path.getValue();
      switch (node.type) {
        case "tag":
        case "anchor":
        case "comment":
          return false;
      }
      const pathStackLength = path.stack.length;
      for (let i = 1; i < pathStackLength; i++) {
        const item = path.stack[i];
        const parentItem = path.stack[i - 1];
        if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {
          return false;
        }
      }
      return true;
    }
    function getLastDescendantNode(node) {
      return isNonEmptyArray(node.children) ? getLastDescendantNode(getLast(node.children)) : node;
    }
    function isPrettierIgnore(comment) {
      return comment.value.trim() === "prettier-ignore";
    }
    function hasPrettierIgnore(path) {
      const node = path.getValue();
      if (node.type === "documentBody") {
        const document2 = path.getParentNode();
        return hasEndComments(document2.head) && isPrettierIgnore(getLast(document2.head.endComments));
      }
      return hasLeadingComments(node) && isPrettierIgnore(getLast(node.leadingComments));
    }
    function isEmptyNode(node) {
      return !isNonEmptyArray(node.children) && !hasComments(node);
    }
    function hasComments(node) {
      return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment(node) || hasEndComments(node);
    }
    function hasLeadingComments(node) {
      return isNonEmptyArray(node === null || node === void 0 ? void 0 : node.leadingComments);
    }
    function hasMiddleComments(node) {
      return isNonEmptyArray(node === null || node === void 0 ? void 0 : node.middleComments);
    }
    function hasIndicatorComment(node) {
      return node === null || node === void 0 ? void 0 : node.indicatorComment;
    }
    function hasTrailingComment(node) {
      return node === null || node === void 0 ? void 0 : node.trailingComment;
    }
    function hasEndComments(node) {
      return isNonEmptyArray(node === null || node === void 0 ? void 0 : node.endComments);
    }
    function splitWithSingleSpace(text) {
      const parts = [];
      let lastPart;
      for (const part of text.split(/( +)/)) {
        if (part !== " ") {
          if (lastPart === " ") {
            parts.push(part);
          } else {
            parts.push((parts.pop() || "") + part);
          }
        } else if (lastPart === void 0) {
          parts.unshift("");
        }
        lastPart = part;
      }
      if (lastPart === " ") {
        parts.push((parts.pop() || "") + " ");
      }
      if (parts[0] === "") {
        parts.shift();
        parts.unshift(" " + (parts.shift() || ""));
      }
      return parts;
    }
    function getFlowScalarLineContents(nodeType, content, options) {
      const rawLineContents = content.split("\n").map((lineContent, index, lineContents) => index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimEnd() : lineContent.trimStart());
      if (options.proseWrap === "preserve") {
        return rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : [lineContent]);
      }
      return rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)).reduce((reduced, lineContentWords, index) => index !== 0 && rawLineContents[index - 1].length > 0 && lineContentWords.length > 0 && !(nodeType === "quoteDouble" && getLast(getLast(reduced)).endsWith("\\")) ? [...reduced.slice(0, -1), [...getLast(reduced), ...lineContentWords]] : [...reduced, lineContentWords], []).map((lineContentWords) => options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords);
    }
    function getBlockValueLineContents(node, {
      parentIndent,
      isLastDescendant,
      options
    }) {
      const content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1];
      let leadingSpaceCount;
      if (node.indent === null) {
        const matches = content.match(/^(?<leadingSpace> *)[^\n\r ]/m);
        leadingSpaceCount = matches ? matches.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
      } else {
        leadingSpaceCount = node.indent - 1 + parentIndent;
      }
      const rawLineContents = content.split("\n").map((lineContent) => lineContent.slice(leadingSpaceCount));
      if (options.proseWrap === "preserve" || node.type === "blockLiteral") {
        return removeUnnecessaryTrailingNewlines(rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : [lineContent]));
      }
      return removeUnnecessaryTrailingNewlines(rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)).reduce((reduced, lineContentWords, index) => index !== 0 && rawLineContents[index - 1].length > 0 && lineContentWords.length > 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(getLast(reduced)) ? [...reduced.slice(0, -1), [...getLast(reduced), ...lineContentWords]] : [...reduced, lineContentWords], []).map((lineContentWords) => lineContentWords.reduce((reduced, word) => reduced.length > 0 && /\s$/.test(getLast(reduced)) ? [...reduced.slice(0, -1), getLast(reduced) + " " + word] : [...reduced, word], [])).map((lineContentWords) => options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords));
      function removeUnnecessaryTrailingNewlines(lineContents) {
        if (node.chomping === "keep") {
          return getLast(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;
        }
        let trailingNewlineCount = 0;
        for (let i = lineContents.length - 1; i >= 0; i--) {
          if (lineContents[i].length === 0) {
            trailingNewlineCount++;
          } else {
            break;
          }
        }
        return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);
      }
    }
    function isInlineNode(node) {
      if (!node) {
        return true;
      }
      switch (node.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
        case "alias":
        case "flowMapping":
        case "flowSequence":
          return true;
        default:
          return false;
      }
    }
    module2.exports = {
      getLast,
      getAncestorCount,
      isNode,
      isEmptyNode,
      isInlineNode,
      mapNode,
      defineShortcut,
      isNextLineEmpty,
      isLastDescendantNode,
      getBlockValueLineContents,
      getFlowScalarLineContents,
      getLastDescendantNode,
      hasPrettierIgnore,
      hasLeadingComments,
      hasMiddleComments,
      hasIndicatorComment,
      hasTrailingComment,
      hasEndComments
    };
  }
});
var require_print_preprocess4 = __commonJS2({
  "src/language-yaml/print-preprocess.js"(exports2, module2) {
    "use strict";
    var {
      defineShortcut,
      mapNode
    } = require_utils12();
    function preprocess(ast) {
      return mapNode(ast, defineShortcuts);
    }
    function defineShortcuts(node) {
      switch (node.type) {
        case "document":
          defineShortcut(node, "head", () => node.children[0]);
          defineShortcut(node, "body", () => node.children[1]);
          break;
        case "documentBody":
        case "sequenceItem":
        case "flowSequenceItem":
        case "mappingKey":
        case "mappingValue":
          defineShortcut(node, "content", () => node.children[0]);
          break;
        case "mappingItem":
        case "flowMappingItem":
          defineShortcut(node, "key", () => node.children[0]);
          defineShortcut(node, "value", () => node.children[1]);
          break;
      }
      return node;
    }
    module2.exports = preprocess;
  }
});
var require_misc2 = __commonJS2({
  "src/language-yaml/print/misc.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        softline,
        align
      }
    } = require("./doc.js");
    var {
      hasEndComments,
      isNextLineEmpty,
      isNode
    } = require_utils12();
    var printedEmptyLineCache = /* @__PURE__ */ new WeakMap();
    function printNextEmptyLine(path, originalText) {
      const node = path.getValue();
      const root = path.stack[0];
      let isNextEmptyLinePrintedSet;
      if (printedEmptyLineCache.has(root)) {
        isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);
      } else {
        isNextEmptyLinePrintedSet = /* @__PURE__ */ new Set();
        printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);
      }
      if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {
        isNextEmptyLinePrintedSet.add(node.position.end.line);
        if (isNextLineEmpty(node, originalText) && !shouldPrintEndComments(path.getParentNode())) {
          return softline;
        }
      }
      return "";
    }
    function shouldPrintEndComments(node) {
      return hasEndComments(node) && !isNode(node, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
    }
    function alignWithSpaces(width, doc2) {
      return align(" ".repeat(width), doc2);
    }
    module2.exports = {
      alignWithSpaces,
      shouldPrintEndComments,
      printNextEmptyLine
    };
  }
});
var require_flow_mapping_sequence = __commonJS2({
  "src/language-yaml/print/flow-mapping-sequence.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        ifBreak,
        line,
        softline,
        hardline,
        join
      }
    } = require("./doc.js");
    var {
      isEmptyNode,
      getLast,
      hasEndComments
    } = require_utils12();
    var {
      printNextEmptyLine,
      alignWithSpaces
    } = require_misc2();
    function printFlowMapping(path, print, options) {
      const node = path.getValue();
      const isMapping = node.type === "flowMapping";
      const openMarker = isMapping ? "{" : "[";
      const closeMarker = isMapping ? "}" : "]";
      let bracketSpacing = softline;
      if (isMapping && node.children.length > 0 && options.bracketSpacing) {
        bracketSpacing = line;
      }
      const lastItem = getLast(node.children);
      const isLastItemEmptyMappingItem = lastItem && lastItem.type === "flowMappingItem" && isEmptyNode(lastItem.key) && isEmptyNode(lastItem.value);
      return [openMarker, alignWithSpaces(options.tabWidth, [bracketSpacing, printChildren(path, print, options), options.trailingComma === "none" ? "" : ifBreak(","), hasEndComments(node) ? [hardline, join(hardline, path.map(print, "endComments"))] : ""]), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker];
    }
    function printChildren(path, print, options) {
      const node = path.getValue();
      const parts = path.map((childPath, index) => [print(), index === node.children.length - 1 ? "" : [",", line, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : ""]], "children");
      return parts;
    }
    module2.exports = {
      printFlowMapping,
      printFlowSequence: printFlowMapping
    };
  }
});
var require_mapping_item = __commonJS2({
  "src/language-yaml/print/mapping-item.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        conditionalGroup,
        group,
        hardline,
        ifBreak,
        join,
        line
      }
    } = require("./doc.js");
    var {
      hasLeadingComments,
      hasMiddleComments,
      hasTrailingComment,
      hasEndComments,
      isNode,
      isEmptyNode,
      isInlineNode
    } = require_utils12();
    var {
      alignWithSpaces
    } = require_misc2();
    function printMappingItem(node, parentNode, path, print, options) {
      const {
        key,
        value
      } = node;
      const isEmptyMappingKey = isEmptyNode(key);
      const isEmptyMappingValue = isEmptyNode(value);
      if (isEmptyMappingKey && isEmptyMappingValue) {
        return ": ";
      }
      const printedKey = print("key");
      const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? " " : "";
      if (isEmptyMappingValue) {
        if (node.type === "flowMappingItem" && parentNode.type === "flowMapping") {
          return printedKey;
        }
        if (node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(key.content, options) && !hasTrailingComment(key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set")) {
          return [printedKey, spaceBeforeColon, ":"];
        }
        return ["? ", alignWithSpaces(2, printedKey)];
      }
      const printedValue = print("value");
      if (isEmptyMappingKey) {
        return [": ", alignWithSpaces(2, printedValue)];
      }
      if (hasLeadingComments(value) || !isInlineNode(key.content)) {
        return ["? ", alignWithSpaces(2, printedKey), hardline, join("", path.map(print, "value", "leadingComments").map((comment) => [comment, hardline])), ": ", alignWithSpaces(2, printedValue)];
      }
      if (isSingleLineNode(key.content) && !hasLeadingComments(key.content) && !hasMiddleComments(key.content) && !hasTrailingComment(key.content) && !hasEndComments(key) && !hasLeadingComments(value.content) && !hasMiddleComments(value.content) && !hasEndComments(value) && isAbsolutelyPrintedAsSingleLineNode(value.content, options)) {
        return [printedKey, spaceBeforeColon, ": ", printedValue];
      }
      const groupId = Symbol("mappingKey");
      const groupedKey = group([ifBreak("? "), group(alignWithSpaces(2, printedKey), {
        id: groupId
      })]);
      const explicitMappingValue = [hardline, ": ", alignWithSpaces(2, printedValue)];
      const implicitMappingValueParts = [spaceBeforeColon, ":"];
      if (hasLeadingComments(value.content) || hasEndComments(value) && value.content && !isNode(value.content, ["mapping", "sequence"]) || parentNode.type === "mapping" && hasTrailingComment(key.content) && isInlineNode(value.content) || isNode(value.content, ["mapping", "sequence"]) && value.content.tag === null && value.content.anchor === null) {
        implicitMappingValueParts.push(hardline);
      } else if (value.content) {
        implicitMappingValueParts.push(line);
      }
      implicitMappingValueParts.push(printedValue);
      const implicitMappingValue = alignWithSpaces(options.tabWidth, implicitMappingValueParts);
      if (isAbsolutelyPrintedAsSingleLineNode(key.content, options) && !hasLeadingComments(key.content) && !hasMiddleComments(key.content) && !hasEndComments(key)) {
        return conditionalGroup([[printedKey, implicitMappingValue]]);
      }
      return conditionalGroup([[groupedKey, ifBreak(explicitMappingValue, implicitMappingValue, {
        groupId
      })]]);
    }
    function isAbsolutelyPrintedAsSingleLineNode(node, options) {
      if (!node) {
        return true;
      }
      switch (node.type) {
        case "plain":
        case "quoteSingle":
        case "quoteDouble":
          break;
        case "alias":
          return true;
        default:
          return false;
      }
      if (options.proseWrap === "preserve") {
        return node.position.start.line === node.position.end.line;
      }
      if (/\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {
        return false;
      }
      switch (options.proseWrap) {
        case "never":
          return !node.value.includes("\n");
        case "always":
          return !/[\n ]/.test(node.value);
        default:
          return false;
      }
    }
    function needsSpaceInFrontOfMappingValue(node) {
      return node.key.content && node.key.content.type === "alias";
    }
    function isSingleLineNode(node) {
      if (!node) {
        return true;
      }
      switch (node.type) {
        case "plain":
        case "quoteDouble":
        case "quoteSingle":
          return node.position.start.line === node.position.end.line;
        case "alias":
          return true;
        default:
          return false;
      }
    }
    module2.exports = printMappingItem;
  }
});
var require_block2 = __commonJS2({
  "src/language-yaml/print/block.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        dedent,
        dedentToRoot,
        fill,
        hardline,
        join,
        line,
        literalline,
        markAsRoot
      },
      utils: {
        getDocParts
      }
    } = require("./doc.js");
    var {
      getAncestorCount,
      getBlockValueLineContents,
      hasIndicatorComment,
      isLastDescendantNode,
      isNode
    } = require_utils12();
    var {
      alignWithSpaces
    } = require_misc2();
    function printBlock(path, print, options) {
      const node = path.getValue();
      const parentIndent = getAncestorCount(path, (ancestorNode) => isNode(ancestorNode, ["sequence", "mapping"]));
      const isLastDescendant = isLastDescendantNode(path);
      const parts = [node.type === "blockFolded" ? ">" : "|"];
      if (node.indent !== null) {
        parts.push(node.indent.toString());
      }
      if (node.chomping !== "clip") {
        parts.push(node.chomping === "keep" ? "+" : "-");
      }
      if (hasIndicatorComment(node)) {
        parts.push(" ", print("indicatorComment"));
      }
      const lineContents = getBlockValueLineContents(node, {
        parentIndent,
        isLastDescendant,
        options
      });
      const contentsParts = [];
      for (const [index, lineWords] of lineContents.entries()) {
        if (index === 0) {
          contentsParts.push(hardline);
        }
        contentsParts.push(fill(getDocParts(join(line, lineWords))));
        if (index !== lineContents.length - 1) {
          contentsParts.push(lineWords.length === 0 ? hardline : markAsRoot(literalline));
        } else if (node.chomping === "keep" && isLastDescendant) {
          contentsParts.push(dedentToRoot(lineWords.length === 0 ? hardline : literalline));
        }
      }
      if (node.indent === null) {
        parts.push(dedent(alignWithSpaces(options.tabWidth, contentsParts)));
      } else {
        parts.push(dedentToRoot(alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)));
      }
      return parts;
    }
    module2.exports = printBlock;
  }
});
var require_printer_yaml = __commonJS2({
  "src/language-yaml/printer-yaml.js"(exports2, module2) {
    "use strict";
    var {
      builders: {
        breakParent,
        fill,
        group,
        hardline,
        join,
        line,
        lineSuffix,
        literalline
      },
      utils: {
        getDocParts,
        replaceTextEndOfLine
      }
    } = require("./doc.js");
    var {
      isPreviousLineEmpty
    } = require_util();
    var {
      insertPragma,
      isPragma
    } = require_pragma6();
    var {
      locStart
    } = require_loc7();
    var embed = require_embed5();
    var {
      getFlowScalarLineContents,
      getLastDescendantNode,
      hasLeadingComments,
      hasMiddleComments,
      hasTrailingComment,
      hasEndComments,
      hasPrettierIgnore,
      isLastDescendantNode,
      isNode,
      isInlineNode
    } = require_utils12();
    var preprocess = require_print_preprocess4();
    var {
      alignWithSpaces,
      printNextEmptyLine,
      shouldPrintEndComments
    } = require_misc2();
    var {
      printFlowMapping,
      printFlowSequence
    } = require_flow_mapping_sequence();
    var printMappingItem = require_mapping_item();
    var printBlock = require_block2();
    function genericPrint(path, options, print) {
      const node = path.getValue();
      const parts = [];
      if (node.type !== "mappingValue" && hasLeadingComments(node)) {
        parts.push([join(hardline, path.map(print, "leadingComments")), hardline]);
      }
      const {
        tag,
        anchor
      } = node;
      if (tag) {
        parts.push(print("tag"));
      }
      if (tag && anchor) {
        parts.push(" ");
      }
      if (anchor) {
        parts.push(print("anchor"));
      }
      let nextEmptyLine = "";
      if (isNode(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode(path)) {
        nextEmptyLine = printNextEmptyLine(path, options.originalText);
      }
      if (tag || anchor) {
        if (isNode(node, ["sequence", "mapping"]) && !hasMiddleComments(node)) {
          parts.push(hardline);
        } else {
          parts.push(" ");
        }
      }
      if (hasMiddleComments(node)) {
        parts.push([node.middleComments.length === 1 ? "" : hardline, join(hardline, path.map(print, "middleComments")), hardline]);
      }
      const parentNode = path.getParentNode();
      if (hasPrettierIgnore(path)) {
        parts.push(replaceTextEndOfLine(options.originalText.slice(node.position.start.offset, node.position.end.offset).trimEnd(), literalline));
      } else {
        parts.push(group(printNode(node, parentNode, path, options, print)));
      }
      if (hasTrailingComment(node) && !isNode(node, ["document", "documentHead"])) {
        parts.push(lineSuffix([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode(node) ? "" : breakParent, print("trailingComment")]));
      }
      if (shouldPrintEndComments(node)) {
        parts.push(alignWithSpaces(node.type === "sequenceItem" ? 2 : 0, [hardline, join(hardline, path.map((path2) => [isPreviousLineEmpty(options.originalText, path2.getValue(), locStart) ? hardline : "", print()], "endComments"))]));
      }
      parts.push(nextEmptyLine);
      return parts;
    }
    function printNode(node, parentNode, path, options, print) {
      switch (node.type) {
        case "root": {
          const {
            children
          } = node;
          const parts = [];
          path.each((childPath, index) => {
            const document2 = children[index];
            const nextDocument = children[index + 1];
            if (index !== 0) {
              parts.push(hardline);
            }
            parts.push(print());
            if (shouldPrintDocumentEndMarker(document2, nextDocument)) {
              parts.push(hardline, "...");
              if (hasTrailingComment(document2)) {
                parts.push(" ", print("trailingComment"));
              }
            } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {
              parts.push(hardline, "---");
            }
          }, "children");
          const lastDescendantNode = getLastDescendantNode(node);
          if (!isNode(lastDescendantNode, ["blockLiteral", "blockFolded"]) || lastDescendantNode.chomping !== "keep") {
            parts.push(hardline);
          }
          return parts;
        }
        case "document": {
          const nextDocument = parentNode.children[path.getName() + 1];
          const parts = [];
          if (shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head") {
            if (node.head.children.length > 0 || node.head.endComments.length > 0) {
              parts.push(print("head"));
            }
            if (hasTrailingComment(node.head)) {
              parts.push(["---", " ", print(["head", "trailingComment"])]);
            } else {
              parts.push("---");
            }
          }
          if (shouldPrintDocumentBody(node)) {
            parts.push(print("body"));
          }
          return join(hardline, parts);
        }
        case "documentHead":
          return join(hardline, [...path.map(print, "children"), ...path.map(print, "endComments")]);
        case "documentBody": {
          const {
            children,
            endComments
          } = node;
          let separator = "";
          if (children.length > 0 && endComments.length > 0) {
            const lastDescendantNode = getLastDescendantNode(node);
            if (isNode(lastDescendantNode, ["blockFolded", "blockLiteral"])) {
              if (lastDescendantNode.chomping !== "keep") {
                separator = [hardline, hardline];
              }
            } else {
              separator = hardline;
            }
          }
          return [join(hardline, path.map(print, "children")), separator, join(hardline, path.map(print, "endComments"))];
        }
        case "directive":
          return ["%", join(" ", [node.name, ...node.parameters])];
        case "comment":
          return ["#", node.value];
        case "alias":
          return ["*", node.value];
        case "tag":
          return options.originalText.slice(node.position.start.offset, node.position.end.offset);
        case "anchor":
          return ["&", node.value];
        case "plain":
          return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);
        case "quoteDouble":
        case "quoteSingle": {
          const singleQuote = "'";
          const doubleQuote = '"';
          const raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);
          if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
            const originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
            return [originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote];
          }
          if (raw.includes(doubleQuote)) {
            return [singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw.replace(/\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote];
          }
          if (raw.includes(singleQuote)) {
            return [doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? raw.replace(/''/g, singleQuote) : raw, options), doubleQuote];
          }
          const quote = options.singleQuote ? singleQuote : doubleQuote;
          return [quote, printFlowScalarContent(node.type, raw, options), quote];
        }
        case "blockFolded":
        case "blockLiteral": {
          return printBlock(path, print, options);
        }
        case "mapping":
        case "sequence":
          return join(hardline, path.map(print, "children"));
        case "sequenceItem":
          return ["- ", alignWithSpaces(2, node.content ? print("content") : "")];
        case "mappingKey":
        case "mappingValue":
          return !node.content ? "" : print("content");
        case "mappingItem":
        case "flowMappingItem": {
          return printMappingItem(node, parentNode, path, print, options);
        }
        case "flowMapping":
          return printFlowMapping(path, print, options);
        case "flowSequence":
          return printFlowSequence(path, print, options);
        case "flowSequenceItem":
          return print("content");
        default:
          throw new Error(`Unexpected node type ${node.type}`);
      }
    }
    function shouldPrintDocumentBody(document2) {
      return document2.body.children.length > 0 || hasEndComments(document2.body);
    }
    function shouldPrintDocumentEndMarker(document2, nextDocument) {
      return hasTrailingComment(document2) || nextDocument && (nextDocument.head.children.length > 0 || hasEndComments(nextDocument.head));
    }
    function shouldPrintDocumentHeadEndMarker(document2, nextDocument, root, options) {
      if (root.children[0] === document2 && /---(?:\s|$)/.test(options.originalText.slice(locStart(document2), locStart(document2) + 4)) || document2.head.children.length > 0 || hasEndComments(document2.head) || hasTrailingComment(document2.head)) {
        return "head";
      }
      if (shouldPrintDocumentEndMarker(document2, nextDocument)) {
        return false;
      }
      return nextDocument ? "root" : false;
    }
    function printFlowScalarContent(nodeType, content, options) {
      const lineContents = getFlowScalarLineContents(nodeType, content, options);
      return join(hardline, lineContents.map((lineContentWords) => fill(getDocParts(join(line, lineContentWords)))));
    }
    function clean(node, newNode) {
      if (isNode(newNode)) {
        delete newNode.position;
        switch (newNode.type) {
          case "comment":
            if (isPragma(newNode.value)) {
              return null;
            }
            break;
          case "quoteDouble":
          case "quoteSingle":
            newNode.type = "quote";
            break;
        }
      }
    }
    module2.exports = {
      preprocess,
      embed,
      print: genericPrint,
      massageAstNode: clean,
      insertPragma
    };
  }
});
var require_options7 = __commonJS2({
  "src/language-yaml/options.js"(exports2, module2) {
    "use strict";
    var commonOptions = require_common_options();
    module2.exports = {
      bracketSpacing: commonOptions.bracketSpacing,
      singleQuote: commonOptions.singleQuote,
      proseWrap: commonOptions.proseWrap
    };
  }
});
var require_parsers7 = __commonJS2({
  "src/language-yaml/parsers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get yaml() {
        return require("./parser-yaml.js").parsers.yaml;
      }
    };
  }
});
var require_YAML = __commonJS2({
  "node_modules/linguist-languages/data/YAML.json"(exports2, module2) {
    module2.exports = {
      name: "YAML",
      type: "data",
      color: "#cb171e",
      tmScope: "source.yaml",
      aliases: ["yml"],
      extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"],
      filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"],
      aceMode: "yaml",
      codemirrorMode: "yaml",
      codemirrorMimeType: "text/x-yaml",
      languageId: 407
    };
  }
});
var require_language_yaml = __commonJS2({
  "src/language-yaml/index.js"(exports2, module2) {
    "use strict";
    var createLanguage = require_create_language();
    var printer = require_printer_yaml();
    var options = require_options7();
    var parsers = require_parsers7();
    var languages = [createLanguage(require_YAML(), (data) => ({
      since: "1.14.0",
      parsers: ["yaml"],
      vscodeLanguageIds: ["yaml", "ansible", "home-assistant"],
      filenames: [...data.filenames.filter((filename) => filename !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"]
    }))];
    module2.exports = {
      languages,
      printers: {
        yaml: printer
      },
      options,
      parsers
    };
  }
});
var require_languages = __commonJS2({
  "src/languages.js"(exports2, module2) {
    "use strict";
    module2.exports = [require_language_js(), require_language_css(), require_language_handlebars(), require_language_graphql(), require_language_markdown(), require_language_html(), require_language_yaml()];
  }
});
var require_load_plugins = __commonJS2({
  "src/common/load-plugins.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var fastGlob = require_out4();
    var partition = require_partition();
    var uniqByKey = require_uniq_by_key();
    var internalPlugins = require_languages();
    var {
      default: mem2,
      memClear: memClear2
    } = (init_dist(), __toCommonJS(dist_exports));
    var thirdParty = require("./third-party.js");
    var resolve = require_resolve2();
    var memoizedLoad = mem2(load, {
      cacheKey: JSON.stringify
    });
    var memoizedSearch = mem2(findPluginsInNodeModules);
    var clearCache = () => {
      memClear2(memoizedLoad);
      memClear2(memoizedSearch);
    };
    function load(plugins2, pluginSearchDirs) {
      if (!plugins2) {
        plugins2 = [];
      }
      if (pluginSearchDirs === false) {
        pluginSearchDirs = [];
      } else {
        pluginSearchDirs = pluginSearchDirs || [];
        if (pluginSearchDirs.length === 0) {
          const autoLoadDir = thirdParty.findParentDir(__dirname, "node_modules");
          if (autoLoadDir) {
            pluginSearchDirs = [autoLoadDir];
          }
        }
      }
      const [externalPluginNames, externalPluginInstances] = partition(plugins2, (plugin) => typeof plugin === "string");
      const externalManualLoadPluginInfos = externalPluginNames.map((pluginName) => {
        let requirePath;
        try {
          requirePath = resolve(path.resolve(process.cwd(), pluginName));
        } catch {
          requirePath = resolve(pluginName, {
            paths: [process.cwd()]
          });
        }
        return {
          name: pluginName,
          requirePath
        };
      });
      const externalAutoLoadPluginInfos = pluginSearchDirs.flatMap((pluginSearchDir) => {
        const resolvedPluginSearchDir = path.resolve(process.cwd(), pluginSearchDir);
        const nodeModulesDir = path.resolve(resolvedPluginSearchDir, "node_modules");
        if (!isDirectory(nodeModulesDir) && !isDirectory(resolvedPluginSearchDir)) {
          throw new Error(`${pluginSearchDir} does not exist or is not a directory`);
        }
        return memoizedSearch(nodeModulesDir).map((pluginName) => ({
          name: pluginName,
          requirePath: resolve(pluginName, {
            paths: [resolvedPluginSearchDir]
          })
        }));
      });
      const externalPlugins = [...uniqByKey([...externalManualLoadPluginInfos, ...externalAutoLoadPluginInfos], "requirePath").map((externalPluginInfo) => Object.assign({
        name: externalPluginInfo.name
      }, require(externalPluginInfo.requirePath))), ...externalPluginInstances];
      return [...internalPlugins, ...externalPlugins];
    }
    function findPluginsInNodeModules(nodeModulesDir) {
      const pluginPackageJsonPaths = fastGlob.sync(["prettier-plugin-*/package.json", "@*/prettier-plugin-*/package.json", "@prettier/plugin-*/package.json"], {
        cwd: nodeModulesDir
      });
      return pluginPackageJsonPaths.map(path.dirname);
    }
    function isDirectory(dir) {
      try {
        return fs.statSync(dir).isDirectory();
      } catch {
        return false;
      }
    }
    module2.exports = {
      loadPlugins: memoizedLoad,
      clearCache
    };
  }
});
var {
  version
} = require("./package.json");
var core = require_core();
var {
  getSupportInfo
} = require_support();
var getFileInfo = require_get_file_info();
var sharedUtil = require_util_shared();
var plugins = require_load_plugins();
var config = require_resolve_config();
var doc = require("./doc.js");
function _withPlugins(fn, optsArgIdx = 1) {
  return (...args) => {
    const opts = args[optsArgIdx] || {};
    args[optsArgIdx] = Object.assign(Object.assign({}, opts), {}, {
      plugins: plugins.loadPlugins(opts.plugins, opts.pluginSearchDirs)
    });
    return fn(...args);
  };
}
function withPlugins(fn, optsArgIdx) {
  const resultingFn = _withPlugins(fn, optsArgIdx);
  if (fn.sync) {
    resultingFn.sync = _withPlugins(fn.sync, optsArgIdx);
  }
  return resultingFn;
}
var formatWithCursor = withPlugins(core.formatWithCursor);
module.exports = {
  formatWithCursor,
  format(text, opts) {
    return formatWithCursor(text, opts).formatted;
  },
  check(text, opts) {
    const {
      formatted
    } = formatWithCursor(text, opts);
    return formatted === text;
  },
  doc,
  resolveConfig: config.resolveConfig,
  resolveConfigFile: config.resolveConfigFile,
  clearConfigCache() {
    config.clearCache();
    plugins.clearCache();
  },
  getFileInfo: withPlugins(getFileInfo),
  getSupportInfo: withPlugins(getSupportInfo, 0),
  version,
  util: sharedUtil,
  __internal: {
    errors: require_errors(),
    coreOptions: require_core_options(),
    createIgnorer: require_create_ignorer(),
    optionsModule: require_options(),
    optionsNormalizer: require_options_normalizer(),
    utils: {
      arrayify: require_arrayify(),
      getLast: require_get_last(),
      partition: require_partition(),
      isNonEmptyArray: require_util().isNonEmptyArray
    }
  },
  __debug: {
    parse: withPlugins(core.parse),
    formatAST: withPlugins(core.formatAST),
    formatDoc: withPlugins(core.formatDoc),
    printToDoc: withPlugins(core.printToDoc),
    printDocToString: withPlugins(core.printDocToString)
  }
};
