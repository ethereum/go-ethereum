package state

import (
	"bytes"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/rlp"
	"io"
	"os"
)

type Witness struct {
	Block           *types.Block
	UsedBlockHashes map[uint64]common.Hash
	Codes           map[common.Hash]Code
	Root            common.Hash
	Lists           map[common.Hash]map[string][]byte
}

type EncodeWitness struct {
	block       *types.Block
	root        common.Hash
	owners      []common.Hash
	paths       [][]string
	nodes       [][][]byte
	blockNums   []uint64
	blockHashes []common.Hash
	codeHashes  []common.Hash
	codes       []Code
}

func (w *Witness) EncodeRLP() []byte {
	var e EncodeWitness
	e.block = w.Block
	for owner, nodeMap := range w.Lists {
		e.owners = append(e.owners, owner)
		var paths []string
		var nodes [][]byte

		for path, node := range nodeMap {
			paths = append(paths, path)
			nodes = append(nodes, node)
		}
		e.paths = append(e.paths, paths)
		e.nodes = append(e.nodes, nodes)
	}

	for codeHash, code := range w.Codes {
		e.codeHashes = append(e.codeHashes, codeHash)
		e.codes = append(e.codes, code)
	}

	for blockNum, blockHash := range w.UsedBlockHashes {
		e.blockNums = append(e.blockNums, blockNum)
		e.blockHashes = append(e.blockHashes, blockHash)
	}
	res := new(bytes.Buffer)
	if err := e.encode(res); err != nil {
		panic(err)
	}
	return res.Bytes()
}

// generated by rlpgen
func (obj *EncodeWitness) encode(_w io.Writer) error {
	w := rlp.NewEncoderBuffer(_w)
	_tmp0 := w.List()
	obj.block.EncodeRLP(w)
	if err := rlp.Encode(w, obj.root); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.owners); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.paths); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.nodes); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.blockNums); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.blockHashes); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.codeHashes); err != nil {
		panic(err)
	}
	if err := rlp.Encode(w, obj.codes); err != nil {
		panic(err)
	}
	w.ListEnd(_tmp0)
	return w.Flush()
}

func newWitness(originalRoot common.Hash) *Witness {
	return &Witness{Root: originalRoot, Lists: make(map[common.Hash]map[string][]byte)}
}

func (w *Witness) addAccessList(owner common.Hash, list map[string][]byte) {
	if len(list) > 0 {
		w.Lists[owner] = list
	}
}

func (w *Witness) Dump() {
	/*
		fmt.Printf("[witness] Root %x\n", w.Root)
		for i, list := range w.Lists {
			owner := w.Owners[i]
			fmt.Printf("[witness] Owner %#x, %d entries: \n", owner, len(list))
			for path, v := range list {
				fmt.Printf("[witness] - '%#x': %#x\n", path, v)
			}
		}
	*/
}

func DumpWitnessToFile(w *Witness) {
	enc := w.EncodeRLP()
	path, err := os.Getwd()
	if err != nil {
		panic("shite")
	}
	err = os.MkdirAll(fmt.Sprintf("%s/block-dump", path), 0755)
	if err != nil {
		panic("shite2")
	}
	outputFName := fmt.Sprintf("%d-%x.rlp", w.Block.NumberU64(), w.Block.Hash())
	err = os.WriteFile(path+"/block-dump/"+outputFName, enc, 0644)
	if err != nil {
		panic("shite 3")
	}
}
