// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package ethclient

import (
	"encoding/json"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/core/types"
)

var _ = (*simulateCallResultMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (s SimulateCallResult) MarshalJSON() ([]byte, error) {
	type SimulateCallResult struct {
		ReturnValue hexutil.Bytes  `json:"returnData"`
		Logs        []*types.Log   `json:"logs"`
		GasUsed     hexutil.Uint64 `json:"gasUsed"`
		Status      hexutil.Uint64 `json:"status"`
		Error       *CallError     `json:"error,omitempty"`
	}
	var enc SimulateCallResult
	enc.ReturnValue = s.ReturnValue
	enc.Logs = s.Logs
	enc.GasUsed = hexutil.Uint64(s.GasUsed)
	enc.Status = hexutil.Uint64(s.Status)
	enc.Error = s.Error
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (s *SimulateCallResult) UnmarshalJSON(input []byte) error {
	type SimulateCallResult struct {
		ReturnValue *hexutil.Bytes  `json:"returnData"`
		Logs        []*types.Log    `json:"logs"`
		GasUsed     *hexutil.Uint64 `json:"gasUsed"`
		Status      *hexutil.Uint64 `json:"status"`
		Error       *CallError      `json:"error,omitempty"`
	}
	var dec SimulateCallResult
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.ReturnValue != nil {
		s.ReturnValue = *dec.ReturnValue
	}
	if dec.Logs != nil {
		s.Logs = dec.Logs
	}
	if dec.GasUsed != nil {
		s.GasUsed = uint64(*dec.GasUsed)
	}
	if dec.Status != nil {
		s.Status = uint64(*dec.Status)
	}
	if dec.Error != nil {
		s.Error = dec.Error
	}
	return nil
}
