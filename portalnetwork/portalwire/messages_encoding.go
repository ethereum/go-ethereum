// Code generated by fastssz. DO NOT EDIT.
// Hash: 26a61b12807ff78c64a029acdd5bcb580dfe35b7bfbf8bf04ceebae1a3d5cac1
// Version: 0.1.3
package portalwire

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the PingPongCustomData object
func (p *PingPongCustomData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PingPongCustomData object to a target array
func (p *PingPongCustomData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Radius'
	if size := len(p.Radius); size != 32 {
		err = ssz.ErrBytesLengthFn("PingPongCustomData.Radius", size, 32)
		return
	}
	dst = append(dst, p.Radius...)

	return
}

// UnmarshalSSZ ssz unmarshals the PingPongCustomData object
func (p *PingPongCustomData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 32 {
		return ssz.ErrSize
	}

	// Field (0) 'Radius'
	if cap(p.Radius) == 0 {
		p.Radius = make([]byte, 0, len(buf[0:32]))
	}
	p.Radius = append(p.Radius, buf[0:32]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PingPongCustomData object
func (p *PingPongCustomData) SizeSSZ() (size int) {
	size = 32
	return
}

// HashTreeRoot ssz hashes the PingPongCustomData object
func (p *PingPongCustomData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PingPongCustomData object with a hasher
func (p *PingPongCustomData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Radius'
	if size := len(p.Radius); size != 32 {
		err = ssz.ErrBytesLengthFn("PingPongCustomData.Radius", size, 32)
		return
	}
	hh.PutBytes(p.Radius)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PingPongCustomData object
func (p *PingPongCustomData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the Ping object
func (p *Ping) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the Ping object to a target array
func (p *Ping) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Field (0) 'EnrSeq'
	dst = ssz.MarshalUint64(dst, p.EnrSeq)

	// Offset (1) 'CustomPayload'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.CustomPayload)

	// Field (1) 'CustomPayload'
	if size := len(p.CustomPayload); size > 2048 {
		err = ssz.ErrBytesLengthFn("Ping.CustomPayload", size, 2048)
		return
	}
	dst = append(dst, p.CustomPayload...)

	return
}

// UnmarshalSSZ ssz unmarshals the Ping object
func (p *Ping) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'EnrSeq'
	p.EnrSeq = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'CustomPayload'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 12 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'CustomPayload'
	{
		buf = tail[o1:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(p.CustomPayload) == 0 {
			p.CustomPayload = make([]byte, 0, len(buf))
		}
		p.CustomPayload = append(p.CustomPayload, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Ping object
func (p *Ping) SizeSSZ() (size int) {
	size = 12

	// Field (1) 'CustomPayload'
	size += len(p.CustomPayload)

	return
}

// HashTreeRoot ssz hashes the Ping object
func (p *Ping) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the Ping object with a hasher
func (p *Ping) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'EnrSeq'
	hh.PutUint64(p.EnrSeq)

	// Field (1) 'CustomPayload'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(p.CustomPayload))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(p.CustomPayload)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Ping object
func (p *Ping) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the FindNodes object
func (f *FindNodes) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FindNodes object to a target array
func (f *FindNodes) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Distances'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(f.Distances) * 2

	// Field (0) 'Distances'
	if size := len(f.Distances); size > 256 {
		err = ssz.ErrListTooBigFn("FindNodes.Distances", size, 256)
		return
	}
	for ii := 0; ii < len(f.Distances); ii++ {
		dst = append(dst, f.Distances[ii][:]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the FindNodes object
func (f *FindNodes) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Distances'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Distances'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 2, 256)
		if err != nil {
			return err
		}
		f.Distances = make([][2]byte, num)
		for ii := 0; ii < num; ii++ {
			copy(f.Distances[ii][:], buf[ii*2:(ii+1)*2])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FindNodes object
func (f *FindNodes) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Distances'
	size += len(f.Distances) * 2

	return
}

// HashTreeRoot ssz hashes the FindNodes object
func (f *FindNodes) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FindNodes object with a hasher
func (f *FindNodes) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Distances'
	{
		if size := len(f.Distances); size > 256 {
			err = ssz.ErrListTooBigFn("FindNodes.Distances", size, 256)
			return
		}
		subIndx := hh.Index()
		for _, i := range f.Distances {
			hh.PutBytes(i[:])
		}
		numItems := uint64(len(f.Distances))
		hh.MerkleizeWithMixin(subIndx, numItems, 256)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the FindNodes object
func (f *FindNodes) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the FindContent object
func (f *FindContent) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FindContent object to a target array
func (f *FindContent) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'ContentKey'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(f.ContentKey)

	// Field (0) 'ContentKey'
	if size := len(f.ContentKey); size > 2048 {
		err = ssz.ErrBytesLengthFn("FindContent.ContentKey", size, 2048)
		return
	}
	dst = append(dst, f.ContentKey...)

	return
}

// UnmarshalSSZ ssz unmarshals the FindContent object
func (f *FindContent) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'ContentKey'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'ContentKey'
	{
		buf = tail[o0:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(f.ContentKey) == 0 {
			f.ContentKey = make([]byte, 0, len(buf))
		}
		f.ContentKey = append(f.ContentKey, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FindContent object
func (f *FindContent) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'ContentKey'
	size += len(f.ContentKey)

	return
}

// HashTreeRoot ssz hashes the FindContent object
func (f *FindContent) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FindContent object with a hasher
func (f *FindContent) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ContentKey'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(f.ContentKey))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(f.ContentKey)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the FindContent object
func (f *FindContent) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the Offer object
func (o *Offer) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(o)
}

// MarshalSSZTo ssz marshals the Offer object to a target array
func (o *Offer) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'ContentKeys'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(o.ContentKeys); ii++ {
		offset += 4
		offset += len(o.ContentKeys[ii])
	}

	// Field (0) 'ContentKeys'
	if size := len(o.ContentKeys); size > 64 {
		err = ssz.ErrListTooBigFn("Offer.ContentKeys", size, 64)
		return
	}
	{
		offset = 4 * len(o.ContentKeys)
		for ii := 0; ii < len(o.ContentKeys); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(o.ContentKeys[ii])
		}
	}
	for ii := 0; ii < len(o.ContentKeys); ii++ {
		if size := len(o.ContentKeys[ii]); size > 2048 {
			err = ssz.ErrBytesLengthFn("Offer.ContentKeys[ii]", size, 2048)
			return
		}
		dst = append(dst, o.ContentKeys[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Offer object
func (o *Offer) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'ContentKeys'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'ContentKeys'
	{
		buf = tail[o0:]
		num, err := ssz.DecodeDynamicLength(buf, 64)
		if err != nil {
			return err
		}
		o.ContentKeys = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 2048 {
				return ssz.ErrBytesLength
			}
			if cap(o.ContentKeys[indx]) == 0 {
				o.ContentKeys[indx] = make([]byte, 0, len(buf))
			}
			o.ContentKeys[indx] = append(o.ContentKeys[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Offer object
func (o *Offer) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'ContentKeys'
	for ii := 0; ii < len(o.ContentKeys); ii++ {
		size += 4
		size += len(o.ContentKeys[ii])
	}

	return
}

// HashTreeRoot ssz hashes the Offer object
func (o *Offer) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(o)
}

// HashTreeRootWith ssz hashes the Offer object with a hasher
func (o *Offer) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ContentKeys'
	{
		subIndx := hh.Index()
		num := uint64(len(o.ContentKeys))
		if num > 64 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range o.ContentKeys {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 2048 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 64)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Offer object
func (o *Offer) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(o)
}

// MarshalSSZ ssz marshals the Pong object
func (p *Pong) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the Pong object to a target array
func (p *Pong) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Field (0) 'EnrSeq'
	dst = ssz.MarshalUint64(dst, p.EnrSeq)

	// Offset (1) 'CustomPayload'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.CustomPayload)

	// Field (1) 'CustomPayload'
	if size := len(p.CustomPayload); size > 2048 {
		err = ssz.ErrBytesLengthFn("Pong.CustomPayload", size, 2048)
		return
	}
	dst = append(dst, p.CustomPayload...)

	return
}

// UnmarshalSSZ ssz unmarshals the Pong object
func (p *Pong) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'EnrSeq'
	p.EnrSeq = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'CustomPayload'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 12 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'CustomPayload'
	{
		buf = tail[o1:]
		if len(buf) > 2048 {
			return ssz.ErrBytesLength
		}
		if cap(p.CustomPayload) == 0 {
			p.CustomPayload = make([]byte, 0, len(buf))
		}
		p.CustomPayload = append(p.CustomPayload, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Pong object
func (p *Pong) SizeSSZ() (size int) {
	size = 12

	// Field (1) 'CustomPayload'
	size += len(p.CustomPayload)

	return
}

// HashTreeRoot ssz hashes the Pong object
func (p *Pong) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the Pong object with a hasher
func (p *Pong) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'EnrSeq'
	hh.PutUint64(p.EnrSeq)

	// Field (1) 'CustomPayload'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(p.CustomPayload))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(p.CustomPayload)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Pong object
func (p *Pong) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the Nodes object
func (n *Nodes) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(n)
}

// MarshalSSZTo ssz marshals the Nodes object to a target array
func (n *Nodes) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(5)

	// Field (0) 'Total'
	dst = ssz.MarshalUint8(dst, n.Total)

	// Offset (1) 'Enrs'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(n.Enrs); ii++ {
		offset += 4
		offset += len(n.Enrs[ii])
	}

	// Field (1) 'Enrs'
	if size := len(n.Enrs); size > 32 {
		err = ssz.ErrListTooBigFn("Nodes.Enrs", size, 32)
		return
	}
	{
		offset = 4 * len(n.Enrs)
		for ii := 0; ii < len(n.Enrs); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(n.Enrs[ii])
		}
	}
	for ii := 0; ii < len(n.Enrs); ii++ {
		if size := len(n.Enrs[ii]); size > 2048 {
			err = ssz.ErrBytesLengthFn("Nodes.Enrs[ii]", size, 2048)
			return
		}
		dst = append(dst, n.Enrs[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Nodes object
func (n *Nodes) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 5 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Total'
	n.Total = ssz.UnmarshallUint8(buf[0:1])

	// Offset (1) 'Enrs'
	if o1 = ssz.ReadOffset(buf[1:5]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 5 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Enrs'
	{
		buf = tail[o1:]
		num, err := ssz.DecodeDynamicLength(buf, 32)
		if err != nil {
			return err
		}
		n.Enrs = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 2048 {
				return ssz.ErrBytesLength
			}
			if cap(n.Enrs[indx]) == 0 {
				n.Enrs[indx] = make([]byte, 0, len(buf))
			}
			n.Enrs[indx] = append(n.Enrs[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Nodes object
func (n *Nodes) SizeSSZ() (size int) {
	size = 5

	// Field (1) 'Enrs'
	for ii := 0; ii < len(n.Enrs); ii++ {
		size += 4
		size += len(n.Enrs[ii])
	}

	return
}

// HashTreeRoot ssz hashes the Nodes object
func (n *Nodes) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(n)
}

// HashTreeRootWith ssz hashes the Nodes object with a hasher
func (n *Nodes) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Total'
	hh.PutUint8(n.Total)

	// Field (1) 'Enrs'
	{
		subIndx := hh.Index()
		num := uint64(len(n.Enrs))
		if num > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range n.Enrs {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 2048 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Nodes object
func (n *Nodes) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(n)
}

// MarshalSSZ ssz marshals the ConnectionId object
func (c *ConnectionId) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ConnectionId object to a target array
func (c *ConnectionId) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Id'
	if size := len(c.Id); size != 2 {
		err = ssz.ErrBytesLengthFn("ConnectionId.Id", size, 2)
		return
	}
	dst = append(dst, c.Id...)

	return
}

// UnmarshalSSZ ssz unmarshals the ConnectionId object
func (c *ConnectionId) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 2 {
		return ssz.ErrSize
	}

	// Field (0) 'Id'
	if cap(c.Id) == 0 {
		c.Id = make([]byte, 0, len(buf[0:2]))
	}
	c.Id = append(c.Id, buf[0:2]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ConnectionId object
func (c *ConnectionId) SizeSSZ() (size int) {
	size = 2
	return
}

// HashTreeRoot ssz hashes the ConnectionId object
func (c *ConnectionId) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ConnectionId object with a hasher
func (c *ConnectionId) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Id'
	if size := len(c.Id); size != 2 {
		err = ssz.ErrBytesLengthFn("ConnectionId.Id", size, 2)
		return
	}
	hh.PutBytes(c.Id)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ConnectionId object
func (c *ConnectionId) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Accept object
func (a *Accept) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Accept object to a target array
func (a *Accept) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(6)

	// Field (0) 'ConnectionId'
	if size := len(a.ConnectionId); size != 2 {
		err = ssz.ErrBytesLengthFn("Accept.ConnectionId", size, 2)
		return
	}
	dst = append(dst, a.ConnectionId...)

	// Offset (1) 'ContentKeys'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(a.ContentKeys)

	// Field (1) 'ContentKeys'
	if size := len(a.ContentKeys); size > 64 {
		err = ssz.ErrBytesLengthFn("Accept.ContentKeys", size, 64)
		return
	}
	dst = append(dst, a.ContentKeys...)

	return
}

// UnmarshalSSZ ssz unmarshals the Accept object
func (a *Accept) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 6 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'ConnectionId'
	if cap(a.ConnectionId) == 0 {
		a.ConnectionId = make([]byte, 0, len(buf[0:2]))
	}
	a.ConnectionId = append(a.ConnectionId, buf[0:2]...)

	// Offset (1) 'ContentKeys'
	if o1 = ssz.ReadOffset(buf[2:6]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 6 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'ContentKeys'
	{
		buf = tail[o1:]
		if err = ssz.ValidateBitlist(buf, 64); err != nil {
			return err
		}
		if cap(a.ContentKeys) == 0 {
			a.ContentKeys = make([]byte, 0, len(buf))
		}
		a.ContentKeys = append(a.ContentKeys, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Accept object
func (a *Accept) SizeSSZ() (size int) {
	size = 6

	// Field (1) 'ContentKeys'
	size += len(a.ContentKeys)

	return
}

// HashTreeRoot ssz hashes the Accept object
func (a *Accept) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Accept object with a hasher
func (a *Accept) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ConnectionId'
	if size := len(a.ConnectionId); size != 2 {
		err = ssz.ErrBytesLengthFn("Accept.ConnectionId", size, 2)
		return
	}
	hh.PutBytes(a.ConnectionId)

	// Field (1) 'ContentKeys'
	if len(a.ContentKeys) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(a.ContentKeys, 64)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Accept object
func (a *Accept) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}
